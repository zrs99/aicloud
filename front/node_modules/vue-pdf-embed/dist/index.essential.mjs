var Yy = Object.defineProperty;
var Wg = (h) => {
  throw TypeError(h);
};
var Ky = (h, e, t) => e in h ? Yy(h, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : h[e] = t;
var K = (h, e, t) => Ky(h, typeof e != "symbol" ? e + "" : e, t), gf = (h, e, t) => e.has(h) || Wg("Cannot " + t);
var a = (h, e, t) => (gf(h, e, "read from private field"), t ? t.call(h) : e.get(h)), b = (h, e, t) => e.has(h) ? Wg("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(h) : e.set(h, t), p = (h, e, t, s) => (gf(h, e, "write to private field"), s ? s.call(h, t) : e.set(h, t), t), v = (h, e, t) => (gf(h, e, "access private method"), t);
var me = (h, e, t, s) => ({
  set _(i) {
    p(h, e, i, t);
  },
  get _() {
    return a(h, e, s);
  }
});
import { shallowRef as xu, watchEffect as Qy, toValue as Gg, watch as Nf, onBeforeUnmount as Jm, defineComponent as Zy, ref as Jy, toRef as qy, computed as tA, openBlock as kl, createElementBlock as Fl, Fragment as eA, renderList as sA, renderSlot as Xg, createElementVNode as qm, normalizeStyle as iA, createCommentVNode as Yg } from "vue";
var nA = {
  /***/
  9306: (
    /***/
    (h, e, t) => {
      var s = t(4901), i = t(6823), n = TypeError;
      h.exports = function(r) {
        if (s(r)) return r;
        throw new n(i(r) + " is not a function");
      };
    }
  ),
  /***/
  3506: (
    /***/
    (h, e, t) => {
      var s = t(3925), i = String, n = TypeError;
      h.exports = function(r) {
        if (s(r)) return r;
        throw new n("Can't set " + i(r) + " as a prototype");
      };
    }
  ),
  /***/
  7080: (
    /***/
    (h, e, t) => {
      var s = t(4402).has;
      h.exports = function(i) {
        return s(i), i;
      };
    }
  ),
  /***/
  679: (
    /***/
    (h, e, t) => {
      var s = t(1625), i = TypeError;
      h.exports = function(n, r) {
        if (s(r, n)) return n;
        throw new i("Incorrect invocation");
      };
    }
  ),
  /***/
  8551: (
    /***/
    (h, e, t) => {
      var s = t(34), i = String, n = TypeError;
      h.exports = function(r) {
        if (s(r)) return r;
        throw new n(i(r) + " is not an object");
      };
    }
  ),
  /***/
  7811: (
    /***/
    (h) => {
      h.exports = typeof ArrayBuffer < "u" && typeof DataView < "u";
    }
  ),
  /***/
  7394: (
    /***/
    (h, e, t) => {
      var s = t(4576), i = t(6706), n = t(2195), r = s.ArrayBuffer, o = s.TypeError;
      h.exports = r && i(r.prototype, "byteLength", "get") || function(l) {
        if (n(l) !== "ArrayBuffer") throw new o("ArrayBuffer expected");
        return l.byteLength;
      };
    }
  ),
  /***/
  3238: (
    /***/
    (h, e, t) => {
      var s = t(4576), i = t(7476), n = t(7394), r = s.ArrayBuffer, o = r && r.prototype, l = o && i(o.slice);
      h.exports = function(c) {
        if (n(c) !== 0 || !l) return !1;
        try {
          return l(c, 0, 0), !1;
        } catch {
          return !0;
        }
      };
    }
  ),
  /***/
  5169: (
    /***/
    (h, e, t) => {
      var s = t(3238), i = TypeError;
      h.exports = function(n) {
        if (s(n)) throw new i("ArrayBuffer is detached");
        return n;
      };
    }
  ),
  /***/
  5636: (
    /***/
    (h, e, t) => {
      var s = t(4576), i = t(9504), n = t(6706), r = t(7696), o = t(5169), l = t(7394), c = t(4483), d = t(1548), u = s.structuredClone, f = s.ArrayBuffer, g = s.DataView, m = Math.min, y = f.prototype, w = g.prototype, A = i(y.slice), E = n(y, "resizable", "get"), S = n(y, "maxByteLength", "get"), T = i(w.getInt8), P = i(w.setInt8);
      h.exports = (d || c) && function(C, R, _) {
        var x = l(C), I = R === void 0 ? x : r(R), L = !E || !E(C), j;
        if (o(C), d && (C = u(C, { transfer: [C] }), x === I && (_ || L)))
          return C;
        if (x >= I && (!_ || L))
          j = A(C, 0, I);
        else {
          var k = _ && !L && S ? { maxByteLength: S(C) } : void 0;
          j = new f(I, k);
          for (var F = new g(C), Y = new g(j), N = m(I, x), D = 0; D < N; D++) P(Y, D, T(F, D));
        }
        return d || c(C), j;
      };
    }
  ),
  /***/
  4644: (
    /***/
    (h, e, t) => {
      var s = t(7811), i = t(3724), n = t(4576), r = t(4901), o = t(34), l = t(9297), c = t(6955), d = t(6823), u = t(6699), f = t(6840), g = t(2106), m = t(1625), y = t(2787), w = t(2967), A = t(8227), E = t(3392), S = t(1181), T = S.enforce, P = S.get, C = n.Int8Array, R = C && C.prototype, _ = n.Uint8ClampedArray, x = _ && _.prototype, I = C && y(C), L = R && y(R), j = Object.prototype, k = n.TypeError, F = A("toStringTag"), Y = E("TYPED_ARRAY_TAG"), N = "TypedArrayConstructor", D = s && !!w && c(n.opera) !== "Opera", et = !1, ft, Et, Dt, yt = {
        Int8Array: 1,
        Uint8Array: 1,
        Uint8ClampedArray: 1,
        Int16Array: 2,
        Uint16Array: 2,
        Int32Array: 4,
        Uint32Array: 4,
        Float32Array: 4,
        Float64Array: 8
      }, St = {
        BigInt64Array: 8,
        BigUint64Array: 8
      }, $s = function(kt) {
        if (!o(kt)) return !1;
        var Ft = c(kt);
        return Ft === "DataView" || l(yt, Ft) || l(St, Ft);
      }, Vs = function(J) {
        var kt = y(J);
        if (o(kt)) {
          var Ft = P(kt);
          return Ft && l(Ft, N) ? Ft[N] : Vs(kt);
        }
      }, $ = function(J) {
        if (!o(J)) return !1;
        var kt = c(J);
        return l(yt, kt) || l(St, kt);
      }, O = function(J) {
        if ($(J)) return J;
        throw new k("Target is not a typed array");
      }, H = function(J) {
        if (r(J) && (!w || m(I, J))) return J;
        throw new k(d(J) + " is not a typed array constructor");
      }, st = function(J, kt, Ft, Us) {
        if (i) {
          if (Ft) for (var Pe in yt) {
            var te = n[Pe];
            if (te && l(te.prototype, J)) try {
              delete te.prototype[J];
            } catch {
              try {
                te.prototype[J] = kt;
              } catch {
              }
            }
          }
          (!L[J] || Ft) && f(L, J, Ft ? kt : D && R[J] || kt, Us);
        }
      }, xt = function(J, kt, Ft) {
        var Us, Pe;
        if (i) {
          if (w) {
            if (Ft) {
              for (Us in yt)
                if (Pe = n[Us], Pe && l(Pe, J)) try {
                  delete Pe[J];
                } catch {
                }
            }
            if (!I[J] || Ft)
              try {
                return f(I, J, Ft ? kt : D && I[J] || kt);
              } catch {
              }
            else return;
          }
          for (Us in yt)
            Pe = n[Us], Pe && (!Pe[J] || Ft) && f(Pe, J, kt);
        }
      };
      for (ft in yt)
        Et = n[ft], Dt = Et && Et.prototype, Dt ? T(Dt)[N] = Et : D = !1;
      for (ft in St)
        Et = n[ft], Dt = Et && Et.prototype, Dt && (T(Dt)[N] = Et);
      if ((!D || !r(I) || I === Function.prototype) && (I = function() {
        throw new k("Incorrect invocation");
      }, D))
        for (ft in yt)
          n[ft] && w(n[ft], I);
      if ((!D || !L || L === j) && (L = I.prototype, D))
        for (ft in yt)
          n[ft] && w(n[ft].prototype, L);
      if (D && y(x) !== L && w(x, L), i && !l(L, F)) {
        et = !0, g(L, F, {
          configurable: !0,
          get: function() {
            return o(this) ? this[Y] : void 0;
          }
        });
        for (ft in yt) n[ft] && u(n[ft], Y, ft);
      }
      h.exports = {
        NATIVE_ARRAY_BUFFER_VIEWS: D,
        TYPED_ARRAY_TAG: et && Y,
        aTypedArray: O,
        aTypedArrayConstructor: H,
        exportTypedArrayMethod: st,
        exportTypedArrayStaticMethod: xt,
        getTypedArrayConstructor: Vs,
        isView: $s,
        isTypedArray: $,
        TypedArray: I,
        TypedArrayPrototype: L
      };
    }
  ),
  /***/
  5370: (
    /***/
    (h, e, t) => {
      var s = t(6198);
      h.exports = function(i, n, r) {
        for (var o = 0, l = arguments.length > 2 ? r : s(n), c = new i(l); l > o; ) c[o] = n[o++];
        return c;
      };
    }
  ),
  /***/
  9617: (
    /***/
    (h, e, t) => {
      var s = t(5397), i = t(5610), n = t(6198), r = function(o) {
        return function(l, c, d) {
          var u = s(l), f = n(u);
          if (f === 0) return !o && -1;
          var g = i(d, f), m;
          if (o && c !== c) {
            for (; f > g; )
              if (m = u[g++], m !== m) return !0;
          } else for (; f > g; g++)
            if ((o || g in u) && u[g] === c) return o || g || 0;
          return !o && -1;
        };
      };
      h.exports = {
        // `Array.prototype.includes` method
        // https://tc39.es/ecma262/#sec-array.prototype.includes
        includes: r(!0),
        // `Array.prototype.indexOf` method
        // https://tc39.es/ecma262/#sec-array.prototype.indexof
        indexOf: r(!1)
      };
    }
  ),
  /***/
  4527: (
    /***/
    (h, e, t) => {
      var s = t(3724), i = t(4376), n = TypeError, r = Object.getOwnPropertyDescriptor, o = s && !function() {
        if (this !== void 0) return !0;
        try {
          Object.defineProperty([], "length", { writable: !1 }).length = 1;
        } catch (l) {
          return l instanceof TypeError;
        }
      }();
      h.exports = o ? function(l, c) {
        if (i(l) && !r(l, "length").writable)
          throw new n("Cannot set read only .length");
        return l.length = c;
      } : function(l, c) {
        return l.length = c;
      };
    }
  ),
  /***/
  7680: (
    /***/
    (h, e, t) => {
      var s = t(9504);
      h.exports = s([].slice);
    }
  ),
  /***/
  7628: (
    /***/
    (h, e, t) => {
      var s = t(6198);
      h.exports = function(i, n) {
        for (var r = s(i), o = new n(r), l = 0; l < r; l++) o[l] = i[r - l - 1];
        return o;
      };
    }
  ),
  /***/
  9928: (
    /***/
    (h, e, t) => {
      var s = t(6198), i = t(1291), n = RangeError;
      h.exports = function(r, o, l, c) {
        var d = s(r), u = i(l), f = u < 0 ? d + u : u;
        if (f >= d || f < 0) throw new n("Incorrect index");
        for (var g = new o(d), m = 0; m < d; m++) g[m] = m === f ? c : r[m];
        return g;
      };
    }
  ),
  /***/
  6319: (
    /***/
    (h, e, t) => {
      var s = t(8551), i = t(9539);
      h.exports = function(n, r, o, l) {
        try {
          return l ? r(s(o)[0], o[1]) : r(o);
        } catch (c) {
          i(n, "throw", c);
        }
      };
    }
  ),
  /***/
  2195: (
    /***/
    (h, e, t) => {
      var s = t(9504), i = s({}.toString), n = s("".slice);
      h.exports = function(r) {
        return n(i(r), 8, -1);
      };
    }
  ),
  /***/
  6955: (
    /***/
    (h, e, t) => {
      var s = t(2140), i = t(4901), n = t(2195), r = t(8227), o = r("toStringTag"), l = Object, c = n(/* @__PURE__ */ function() {
        return arguments;
      }()) === "Arguments", d = function(u, f) {
        try {
          return u[f];
        } catch {
        }
      };
      h.exports = s ? n : function(u) {
        var f, g, m;
        return u === void 0 ? "Undefined" : u === null ? "Null" : typeof (g = d(f = l(u), o)) == "string" ? g : c ? n(f) : (m = n(f)) === "Object" && i(f.callee) ? "Arguments" : m;
      };
    }
  ),
  /***/
  7740: (
    /***/
    (h, e, t) => {
      var s = t(9297), i = t(5031), n = t(7347), r = t(4913);
      h.exports = function(o, l, c) {
        for (var d = i(l), u = r.f, f = n.f, g = 0; g < d.length; g++) {
          var m = d[g];
          !s(o, m) && !(c && s(c, m)) && u(o, m, f(l, m));
        }
      };
    }
  ),
  /***/
  2211: (
    /***/
    (h, e, t) => {
      var s = t(9039);
      h.exports = !s(function() {
        function i() {
        }
        return i.prototype.constructor = null, Object.getPrototypeOf(new i()) !== i.prototype;
      });
    }
  ),
  /***/
  2529: (
    /***/
    (h) => {
      h.exports = function(e, t) {
        return { value: e, done: t };
      };
    }
  ),
  /***/
  6699: (
    /***/
    (h, e, t) => {
      var s = t(3724), i = t(4913), n = t(6980);
      h.exports = s ? function(r, o, l) {
        return i.f(r, o, n(1, l));
      } : function(r, o, l) {
        return r[o] = l, r;
      };
    }
  ),
  /***/
  6980: (
    /***/
    (h) => {
      h.exports = function(e, t) {
        return {
          enumerable: !(e & 1),
          configurable: !(e & 2),
          writable: !(e & 4),
          value: t
        };
      };
    }
  ),
  /***/
  4659: (
    /***/
    (h, e, t) => {
      var s = t(3724), i = t(4913), n = t(6980);
      h.exports = function(r, o, l) {
        s ? i.f(r, o, n(0, l)) : r[o] = l;
      };
    }
  ),
  /***/
  2106: (
    /***/
    (h, e, t) => {
      var s = t(283), i = t(4913);
      h.exports = function(n, r, o) {
        return o.get && s(o.get, r, { getter: !0 }), o.set && s(o.set, r, { setter: !0 }), i.f(n, r, o);
      };
    }
  ),
  /***/
  6840: (
    /***/
    (h, e, t) => {
      var s = t(4901), i = t(4913), n = t(283), r = t(9433);
      h.exports = function(o, l, c, d) {
        d || (d = {});
        var u = d.enumerable, f = d.name !== void 0 ? d.name : l;
        if (s(c) && n(c, f, d), d.global)
          u ? o[l] = c : r(l, c);
        else {
          try {
            d.unsafe ? o[l] && (u = !0) : delete o[l];
          } catch {
          }
          u ? o[l] = c : i.f(o, l, {
            value: c,
            enumerable: !1,
            configurable: !d.nonConfigurable,
            writable: !d.nonWritable
          });
        }
        return o;
      };
    }
  ),
  /***/
  6279: (
    /***/
    (h, e, t) => {
      var s = t(6840);
      h.exports = function(i, n, r) {
        for (var o in n) s(i, o, n[o], r);
        return i;
      };
    }
  ),
  /***/
  9433: (
    /***/
    (h, e, t) => {
      var s = t(4576), i = Object.defineProperty;
      h.exports = function(n, r) {
        try {
          i(s, n, { value: r, configurable: !0, writable: !0 });
        } catch {
          s[n] = r;
        }
        return r;
      };
    }
  ),
  /***/
  3724: (
    /***/
    (h, e, t) => {
      var s = t(9039);
      h.exports = !s(function() {
        return Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1] !== 7;
      });
    }
  ),
  /***/
  4483: (
    /***/
    (h, e, t) => {
      var s = t(4576), i = t(9429), n = t(1548), r = s.structuredClone, o = s.ArrayBuffer, l = s.MessageChannel, c = !1, d, u, f, g;
      if (n)
        c = function(m) {
          r(m, { transfer: [m] });
        };
      else if (o) try {
        l || (d = i("worker_threads"), d && (l = d.MessageChannel)), l && (u = new l(), f = new o(2), g = function(m) {
          u.port1.postMessage(null, [m]);
        }, f.byteLength === 2 && (g(f), f.byteLength === 0 && (c = g)));
      } catch {
      }
      h.exports = c;
    }
  ),
  /***/
  4055: (
    /***/
    (h, e, t) => {
      var s = t(4576), i = t(34), n = s.document, r = i(n) && i(n.createElement);
      h.exports = function(o) {
        return r ? n.createElement(o) : {};
      };
    }
  ),
  /***/
  6837: (
    /***/
    (h) => {
      var e = TypeError, t = 9007199254740991;
      h.exports = function(s) {
        if (s > t) throw e("Maximum allowed index exceeded");
        return s;
      };
    }
  ),
  /***/
  5002: (
    /***/
    (h) => {
      h.exports = {
        IndexSizeError: { s: "INDEX_SIZE_ERR", c: 1, m: 1 },
        DOMStringSizeError: { s: "DOMSTRING_SIZE_ERR", c: 2, m: 0 },
        HierarchyRequestError: { s: "HIERARCHY_REQUEST_ERR", c: 3, m: 1 },
        WrongDocumentError: { s: "WRONG_DOCUMENT_ERR", c: 4, m: 1 },
        InvalidCharacterError: { s: "INVALID_CHARACTER_ERR", c: 5, m: 1 },
        NoDataAllowedError: { s: "NO_DATA_ALLOWED_ERR", c: 6, m: 0 },
        NoModificationAllowedError: { s: "NO_MODIFICATION_ALLOWED_ERR", c: 7, m: 1 },
        NotFoundError: { s: "NOT_FOUND_ERR", c: 8, m: 1 },
        NotSupportedError: { s: "NOT_SUPPORTED_ERR", c: 9, m: 1 },
        InUseAttributeError: { s: "INUSE_ATTRIBUTE_ERR", c: 10, m: 1 },
        InvalidStateError: { s: "INVALID_STATE_ERR", c: 11, m: 1 },
        SyntaxError: { s: "SYNTAX_ERR", c: 12, m: 1 },
        InvalidModificationError: { s: "INVALID_MODIFICATION_ERR", c: 13, m: 1 },
        NamespaceError: { s: "NAMESPACE_ERR", c: 14, m: 1 },
        InvalidAccessError: { s: "INVALID_ACCESS_ERR", c: 15, m: 1 },
        ValidationError: { s: "VALIDATION_ERR", c: 16, m: 0 },
        TypeMismatchError: { s: "TYPE_MISMATCH_ERR", c: 17, m: 1 },
        SecurityError: { s: "SECURITY_ERR", c: 18, m: 1 },
        NetworkError: { s: "NETWORK_ERR", c: 19, m: 1 },
        AbortError: { s: "ABORT_ERR", c: 20, m: 1 },
        URLMismatchError: { s: "URL_MISMATCH_ERR", c: 21, m: 1 },
        QuotaExceededError: { s: "QUOTA_EXCEEDED_ERR", c: 22, m: 1 },
        TimeoutError: { s: "TIMEOUT_ERR", c: 23, m: 1 },
        InvalidNodeTypeError: { s: "INVALID_NODE_TYPE_ERR", c: 24, m: 1 },
        DataCloneError: { s: "DATA_CLONE_ERR", c: 25, m: 1 }
      };
    }
  ),
  /***/
  8727: (
    /***/
    (h) => {
      h.exports = [
        "constructor",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "toLocaleString",
        "toString",
        "valueOf"
      ];
    }
  ),
  /***/
  6193: (
    /***/
    (h, e, t) => {
      var s = t(4215);
      h.exports = s === "NODE";
    }
  ),
  /***/
  2839: (
    /***/
    (h, e, t) => {
      var s = t(4576), i = s.navigator, n = i && i.userAgent;
      h.exports = n ? String(n) : "";
    }
  ),
  /***/
  9519: (
    /***/
    (h, e, t) => {
      var s = t(4576), i = t(2839), n = s.process, r = s.Deno, o = n && n.versions || r && r.version, l = o && o.v8, c, d;
      l && (c = l.split("."), d = c[0] > 0 && c[0] < 4 ? 1 : +(c[0] + c[1])), !d && i && (c = i.match(/Edge\/(\d+)/), (!c || c[1] >= 74) && (c = i.match(/Chrome\/(\d+)/), c && (d = +c[1]))), h.exports = d;
    }
  ),
  /***/
  4215: (
    /***/
    (h, e, t) => {
      var s = t(4576), i = t(2839), n = t(2195), r = function(o) {
        return i.slice(0, o.length) === o;
      };
      h.exports = function() {
        return r("Bun/") ? "BUN" : r("Cloudflare-Workers") ? "CLOUDFLARE" : r("Deno/") ? "DENO" : r("Node.js/") ? "NODE" : s.Bun && typeof Bun.version == "string" ? "BUN" : s.Deno && typeof Deno.version == "object" ? "DENO" : n(s.process) === "process" ? "NODE" : s.window && s.document ? "BROWSER" : "REST";
      }();
    }
  ),
  /***/
  8574: (
    /***/
    (h, e, t) => {
      var s = t(9504), i = Error, n = s("".replace), r = function(c) {
        return String(new i(c).stack);
      }("zxcasd"), o = /\n\s*at [^:]*:[^\n]*/, l = o.test(r);
      h.exports = function(c, d) {
        if (l && typeof c == "string" && !i.prepareStackTrace)
          for (; d--; ) c = n(c, o, "");
        return c;
      };
    }
  ),
  /***/
  6518: (
    /***/
    (h, e, t) => {
      var s = t(4576), i = t(7347).f, n = t(6699), r = t(6840), o = t(9433), l = t(7740), c = t(2796);
      h.exports = function(d, u) {
        var f = d.target, g = d.global, m = d.stat, y, w, A, E, S, T;
        if (g ? w = s : m ? w = s[f] || o(f, {}) : w = s[f] && s[f].prototype, w) for (A in u) {
          if (S = u[A], d.dontCallGetSet ? (T = i(w, A), E = T && T.value) : E = w[A], y = c(g ? A : f + (m ? "." : "#") + A, d.forced), !y && E !== void 0) {
            if (typeof S == typeof E) continue;
            l(S, E);
          }
          (d.sham || E && E.sham) && n(S, "sham", !0), r(w, A, S, d);
        }
      };
    }
  ),
  /***/
  9039: (
    /***/
    (h) => {
      h.exports = function(e) {
        try {
          return !!e();
        } catch {
          return !0;
        }
      };
    }
  ),
  /***/
  8745: (
    /***/
    (h, e, t) => {
      var s = t(616), i = Function.prototype, n = i.apply, r = i.call;
      h.exports = typeof Reflect == "object" && Reflect.apply || (s ? r.bind(n) : function() {
        return r.apply(n, arguments);
      });
    }
  ),
  /***/
  6080: (
    /***/
    (h, e, t) => {
      var s = t(7476), i = t(9306), n = t(616), r = s(s.bind);
      h.exports = function(o, l) {
        return i(o), l === void 0 ? o : n ? r(o, l) : function() {
          return o.apply(l, arguments);
        };
      };
    }
  ),
  /***/
  616: (
    /***/
    (h, e, t) => {
      var s = t(9039);
      h.exports = !s(function() {
        var i = (function() {
        }).bind();
        return typeof i != "function" || i.hasOwnProperty("prototype");
      });
    }
  ),
  /***/
  9565: (
    /***/
    (h, e, t) => {
      var s = t(616), i = Function.prototype.call;
      h.exports = s ? i.bind(i) : function() {
        return i.apply(i, arguments);
      };
    }
  ),
  /***/
  350: (
    /***/
    (h, e, t) => {
      var s = t(3724), i = t(9297), n = Function.prototype, r = s && Object.getOwnPropertyDescriptor, o = i(n, "name"), l = o && (function() {
      }).name === "something", c = o && (!s || s && r(n, "name").configurable);
      h.exports = {
        EXISTS: o,
        PROPER: l,
        CONFIGURABLE: c
      };
    }
  ),
  /***/
  6706: (
    /***/
    (h, e, t) => {
      var s = t(9504), i = t(9306);
      h.exports = function(n, r, o) {
        try {
          return s(i(Object.getOwnPropertyDescriptor(n, r)[o]));
        } catch {
        }
      };
    }
  ),
  /***/
  7476: (
    /***/
    (h, e, t) => {
      var s = t(2195), i = t(9504);
      h.exports = function(n) {
        if (s(n) === "Function") return i(n);
      };
    }
  ),
  /***/
  9504: (
    /***/
    (h, e, t) => {
      var s = t(616), i = Function.prototype, n = i.call, r = s && i.bind.bind(n, n);
      h.exports = s ? r : function(o) {
        return function() {
          return n.apply(o, arguments);
        };
      };
    }
  ),
  /***/
  9429: (
    /***/
    (h, e, t) => {
      var s = t(4576), i = t(6193);
      h.exports = function(n) {
        if (i) {
          try {
            return s.process.getBuiltinModule(n);
          } catch {
          }
          try {
            return Function('return require("' + n + '")')();
          } catch {
          }
        }
      };
    }
  ),
  /***/
  7751: (
    /***/
    (h, e, t) => {
      var s = t(4576), i = t(4901), n = function(r) {
        return i(r) ? r : void 0;
      };
      h.exports = function(r, o) {
        return arguments.length < 2 ? n(s[r]) : s[r] && s[r][o];
      };
    }
  ),
  /***/
  1767: (
    /***/
    (h) => {
      h.exports = function(e) {
        return {
          iterator: e,
          next: e.next,
          done: !1
        };
      };
    }
  ),
  /***/
  8646: (
    /***/
    (h, e, t) => {
      var s = t(9565), i = t(8551), n = t(1767), r = t(851);
      h.exports = function(o, l) {
        (!l || typeof o != "string") && i(o);
        var c = r(o);
        return n(i(c !== void 0 ? s(c, o) : o));
      };
    }
  ),
  /***/
  851: (
    /***/
    (h, e, t) => {
      var s = t(6955), i = t(5966), n = t(4117), r = t(6269), o = t(8227), l = o("iterator");
      h.exports = function(c) {
        if (!n(c)) return i(c, l) || i(c, "@@iterator") || r[s(c)];
      };
    }
  ),
  /***/
  81: (
    /***/
    (h, e, t) => {
      var s = t(9565), i = t(9306), n = t(8551), r = t(6823), o = t(851), l = TypeError;
      h.exports = function(c, d) {
        var u = arguments.length < 2 ? o(c) : d;
        if (i(u)) return n(s(u, c));
        throw new l(r(c) + " is not iterable");
      };
    }
  ),
  /***/
  5966: (
    /***/
    (h, e, t) => {
      var s = t(9306), i = t(4117);
      h.exports = function(n, r) {
        var o = n[r];
        return i(o) ? void 0 : s(o);
      };
    }
  ),
  /***/
  3789: (
    /***/
    (h, e, t) => {
      var s = t(9306), i = t(8551), n = t(9565), r = t(1291), o = t(1767), l = "Invalid size", c = RangeError, d = TypeError, u = Math.max, f = function(g, m) {
        this.set = g, this.size = u(m, 0), this.has = s(g.has), this.keys = s(g.keys);
      };
      f.prototype = {
        getIterator: function() {
          return o(i(n(this.keys, this.set)));
        },
        includes: function(g) {
          return n(this.has, this.set, g);
        }
      }, h.exports = function(g) {
        i(g);
        var m = +g.size;
        if (m !== m) throw new d(l);
        var y = r(m);
        if (y < 0) throw new c(l);
        return new f(g, y);
      };
    }
  ),
  /***/
  4576: (
    /***/
    function(h) {
      var e = function(t) {
        return t && t.Math === Math && t;
      };
      h.exports = // eslint-disable-next-line es/no-global-this -- safe
      e(typeof globalThis == "object" && globalThis) || e(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
      e(typeof self == "object" && self) || e(typeof global == "object" && global) || e(typeof this == "object" && this) || // eslint-disable-next-line no-new-func -- fallback
      /* @__PURE__ */ function() {
        return this;
      }() || Function("return this")();
    }
  ),
  /***/
  9297: (
    /***/
    (h, e, t) => {
      var s = t(9504), i = t(8981), n = s({}.hasOwnProperty);
      h.exports = Object.hasOwn || function(o, l) {
        return n(i(o), l);
      };
    }
  ),
  /***/
  421: (
    /***/
    (h) => {
      h.exports = {};
    }
  ),
  /***/
  397: (
    /***/
    (h, e, t) => {
      var s = t(7751);
      h.exports = s("document", "documentElement");
    }
  ),
  /***/
  5917: (
    /***/
    (h, e, t) => {
      var s = t(3724), i = t(9039), n = t(4055);
      h.exports = !s && !i(function() {
        return Object.defineProperty(n("div"), "a", {
          get: function() {
            return 7;
          }
        }).a !== 7;
      });
    }
  ),
  /***/
  7055: (
    /***/
    (h, e, t) => {
      var s = t(9504), i = t(9039), n = t(2195), r = Object, o = s("".split);
      h.exports = i(function() {
        return !r("z").propertyIsEnumerable(0);
      }) ? function(l) {
        return n(l) === "String" ? o(l, "") : r(l);
      } : r;
    }
  ),
  /***/
  3167: (
    /***/
    (h, e, t) => {
      var s = t(4901), i = t(34), n = t(2967);
      h.exports = function(r, o, l) {
        var c, d;
        return (
          // it can work only with native `setPrototypeOf`
          n && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
          s(c = o.constructor) && c !== l && i(d = c.prototype) && d !== l.prototype && n(r, d), r
        );
      };
    }
  ),
  /***/
  3706: (
    /***/
    (h, e, t) => {
      var s = t(9504), i = t(4901), n = t(7629), r = s(Function.toString);
      i(n.inspectSource) || (n.inspectSource = function(o) {
        return r(o);
      }), h.exports = n.inspectSource;
    }
  ),
  /***/
  1181: (
    /***/
    (h, e, t) => {
      var s = t(8622), i = t(4576), n = t(34), r = t(6699), o = t(9297), l = t(7629), c = t(6119), d = t(421), u = "Object already initialized", f = i.TypeError, g = i.WeakMap, m, y, w, A = function(P) {
        return w(P) ? y(P) : m(P, {});
      }, E = function(P) {
        return function(C) {
          var R;
          if (!n(C) || (R = y(C)).type !== P)
            throw new f("Incompatible receiver, " + P + " required");
          return R;
        };
      };
      if (s || l.state) {
        var S = l.state || (l.state = new g());
        S.get = S.get, S.has = S.has, S.set = S.set, m = function(P, C) {
          if (S.has(P)) throw new f(u);
          return C.facade = P, S.set(P, C), C;
        }, y = function(P) {
          return S.get(P) || {};
        }, w = function(P) {
          return S.has(P);
        };
      } else {
        var T = c("state");
        d[T] = !0, m = function(P, C) {
          if (o(P, T)) throw new f(u);
          return C.facade = P, r(P, T, C), C;
        }, y = function(P) {
          return o(P, T) ? P[T] : {};
        }, w = function(P) {
          return o(P, T);
        };
      }
      h.exports = {
        set: m,
        get: y,
        has: w,
        enforce: A,
        getterFor: E
      };
    }
  ),
  /***/
  4209: (
    /***/
    (h, e, t) => {
      var s = t(8227), i = t(6269), n = s("iterator"), r = Array.prototype;
      h.exports = function(o) {
        return o !== void 0 && (i.Array === o || r[n] === o);
      };
    }
  ),
  /***/
  4376: (
    /***/
    (h, e, t) => {
      var s = t(2195);
      h.exports = Array.isArray || function(n) {
        return s(n) === "Array";
      };
    }
  ),
  /***/
  1108: (
    /***/
    (h, e, t) => {
      var s = t(6955);
      h.exports = function(i) {
        var n = s(i);
        return n === "BigInt64Array" || n === "BigUint64Array";
      };
    }
  ),
  /***/
  4901: (
    /***/
    (h) => {
      var e = typeof document == "object" && document.all;
      h.exports = typeof e > "u" && e !== void 0 ? function(t) {
        return typeof t == "function" || t === e;
      } : function(t) {
        return typeof t == "function";
      };
    }
  ),
  /***/
  2796: (
    /***/
    (h, e, t) => {
      var s = t(9039), i = t(4901), n = /#|\.prototype\./, r = function(u, f) {
        var g = l[o(u)];
        return g === d ? !0 : g === c ? !1 : i(f) ? s(f) : !!f;
      }, o = r.normalize = function(u) {
        return String(u).replace(n, ".").toLowerCase();
      }, l = r.data = {}, c = r.NATIVE = "N", d = r.POLYFILL = "P";
      h.exports = r;
    }
  ),
  /***/
  4117: (
    /***/
    (h) => {
      h.exports = function(e) {
        return e == null;
      };
    }
  ),
  /***/
  34: (
    /***/
    (h, e, t) => {
      var s = t(4901);
      h.exports = function(i) {
        return typeof i == "object" ? i !== null : s(i);
      };
    }
  ),
  /***/
  3925: (
    /***/
    (h, e, t) => {
      var s = t(34);
      h.exports = function(i) {
        return s(i) || i === null;
      };
    }
  ),
  /***/
  6395: (
    /***/
    (h) => {
      h.exports = !1;
    }
  ),
  /***/
  757: (
    /***/
    (h, e, t) => {
      var s = t(7751), i = t(4901), n = t(1625), r = t(7040), o = Object;
      h.exports = r ? function(l) {
        return typeof l == "symbol";
      } : function(l) {
        var c = s("Symbol");
        return i(c) && n(c.prototype, o(l));
      };
    }
  ),
  /***/
  507: (
    /***/
    (h, e, t) => {
      var s = t(9565);
      h.exports = function(i, n, r) {
        for (var o = r ? i : i.iterator, l = i.next, c, d; !(c = s(l, o)).done; )
          if (d = n(c.value), d !== void 0) return d;
      };
    }
  ),
  /***/
  2652: (
    /***/
    (h, e, t) => {
      var s = t(6080), i = t(9565), n = t(8551), r = t(6823), o = t(4209), l = t(6198), c = t(1625), d = t(81), u = t(851), f = t(9539), g = TypeError, m = function(w, A) {
        this.stopped = w, this.result = A;
      }, y = m.prototype;
      h.exports = function(w, A, E) {
        var S = E && E.that, T = !!(E && E.AS_ENTRIES), P = !!(E && E.IS_RECORD), C = !!(E && E.IS_ITERATOR), R = !!(E && E.INTERRUPTED), _ = s(A, S), x, I, L, j, k, F, Y, N = function(et) {
          return x && f(x, "normal", et), new m(!0, et);
        }, D = function(et) {
          return T ? (n(et), R ? _(et[0], et[1], N) : _(et[0], et[1])) : R ? _(et, N) : _(et);
        };
        if (P)
          x = w.iterator;
        else if (C)
          x = w;
        else {
          if (I = u(w), !I) throw new g(r(w) + " is not iterable");
          if (o(I)) {
            for (L = 0, j = l(w); j > L; L++)
              if (k = D(w[L]), k && c(y, k)) return k;
            return new m(!1);
          }
          x = d(w, I);
        }
        for (F = P ? w.next : x.next; !(Y = i(F, x)).done; ) {
          try {
            k = D(Y.value);
          } catch (et) {
            f(x, "throw", et);
          }
          if (typeof k == "object" && k && c(y, k)) return k;
        }
        return new m(!1);
      };
    }
  ),
  /***/
  9539: (
    /***/
    (h, e, t) => {
      var s = t(9565), i = t(8551), n = t(5966);
      h.exports = function(r, o, l) {
        var c, d;
        i(r);
        try {
          if (c = n(r, "return"), !c) {
            if (o === "throw") throw l;
            return l;
          }
          c = s(c, r);
        } catch (u) {
          d = !0, c = u;
        }
        if (o === "throw") throw l;
        if (d) throw c;
        return i(c), l;
      };
    }
  ),
  /***/
  9462: (
    /***/
    (h, e, t) => {
      var s = t(9565), i = t(2360), n = t(6699), r = t(6279), o = t(8227), l = t(1181), c = t(5966), d = t(7657).IteratorPrototype, u = t(2529), f = t(9539), g = o("toStringTag"), m = "IteratorHelper", y = "WrapForValidIterator", w = l.set, A = function(T) {
        var P = l.getterFor(T ? y : m);
        return r(i(d), {
          next: function() {
            var R = P(this);
            if (T) return R.nextHandler();
            try {
              var _ = R.done ? void 0 : R.nextHandler();
              return u(_, R.done);
            } catch (x) {
              throw R.done = !0, x;
            }
          },
          return: function() {
            var C = P(this), R = C.iterator;
            if (C.done = !0, T) {
              var _ = c(R, "return");
              return _ ? s(_, R) : u(void 0, !0);
            }
            if (C.inner) try {
              f(C.inner.iterator, "normal");
            } catch (x) {
              return f(R, "throw", x);
            }
            return R && f(R, "normal"), u(void 0, !0);
          }
        });
      }, E = A(!0), S = A(!1);
      n(S, g, "Iterator Helper"), h.exports = function(T, P) {
        var C = function(_, x) {
          x ? (x.iterator = _.iterator, x.next = _.next) : x = _, x.type = P ? y : m, x.nextHandler = T, x.counter = 0, x.done = !1, w(this, x);
        };
        return C.prototype = P ? E : S, C;
      };
    }
  ),
  /***/
  713: (
    /***/
    (h, e, t) => {
      var s = t(9565), i = t(9306), n = t(8551), r = t(1767), o = t(9462), l = t(6319), c = o(function() {
        var d = this.iterator, u = n(s(this.next, d)), f = this.done = !!u.done;
        if (!f) return l(d, this.mapper, [u.value, this.counter++], !0);
      });
      h.exports = function(u) {
        return n(this), i(u), new c(r(this), {
          mapper: u
        });
      };
    }
  ),
  /***/
  7657: (
    /***/
    (h, e, t) => {
      var s = t(9039), i = t(4901), n = t(34), r = t(2360), o = t(2787), l = t(6840), c = t(8227), d = t(6395), u = c("iterator"), f = !1, g, m, y;
      [].keys && (y = [].keys(), "next" in y ? (m = o(o(y)), m !== Object.prototype && (g = m)) : f = !0);
      var w = !n(g) || s(function() {
        var A = {};
        return g[u].call(A) !== A;
      });
      w ? g = {} : d && (g = r(g)), i(g[u]) || l(g, u, function() {
        return this;
      }), h.exports = {
        IteratorPrototype: g,
        BUGGY_SAFARI_ITERATORS: f
      };
    }
  ),
  /***/
  6269: (
    /***/
    (h) => {
      h.exports = {};
    }
  ),
  /***/
  6198: (
    /***/
    (h, e, t) => {
      var s = t(8014);
      h.exports = function(i) {
        return s(i.length);
      };
    }
  ),
  /***/
  283: (
    /***/
    (h, e, t) => {
      var s = t(9504), i = t(9039), n = t(4901), r = t(9297), o = t(3724), l = t(350).CONFIGURABLE, c = t(3706), d = t(1181), u = d.enforce, f = d.get, g = String, m = Object.defineProperty, y = s("".slice), w = s("".replace), A = s([].join), E = o && !i(function() {
        return m(function() {
        }, "length", { value: 8 }).length !== 8;
      }), S = String(String).split("String"), T = h.exports = function(P, C, R) {
        y(g(C), 0, 7) === "Symbol(" && (C = "[" + w(g(C), /^Symbol\(([^)]*)\).*$/, "$1") + "]"), R && R.getter && (C = "get " + C), R && R.setter && (C = "set " + C), (!r(P, "name") || l && P.name !== C) && (o ? m(P, "name", { value: C, configurable: !0 }) : P.name = C), E && R && r(R, "arity") && P.length !== R.arity && m(P, "length", { value: R.arity });
        try {
          R && r(R, "constructor") && R.constructor ? o && m(P, "prototype", { writable: !1 }) : P.prototype && (P.prototype = void 0);
        } catch {
        }
        var _ = u(P);
        return r(_, "source") || (_.source = A(S, typeof C == "string" ? C : "")), P;
      };
      Function.prototype.toString = T(function() {
        return n(this) && f(this).source || c(this);
      }, "toString");
    }
  ),
  /***/
  741: (
    /***/
    (h) => {
      var e = Math.ceil, t = Math.floor;
      h.exports = Math.trunc || function(i) {
        var n = +i;
        return (n > 0 ? t : e)(n);
      };
    }
  ),
  /***/
  6043: (
    /***/
    (h, e, t) => {
      var s = t(9306), i = TypeError, n = function(r) {
        var o, l;
        this.promise = new r(function(c, d) {
          if (o !== void 0 || l !== void 0) throw new i("Bad Promise constructor");
          o = c, l = d;
        }), this.resolve = s(o), this.reject = s(l);
      };
      h.exports.f = function(r) {
        return new n(r);
      };
    }
  ),
  /***/
  2603: (
    /***/
    (h, e, t) => {
      var s = t(655);
      h.exports = function(i, n) {
        return i === void 0 ? arguments.length < 2 ? "" : n : s(i);
      };
    }
  ),
  /***/
  4149: (
    /***/
    (h) => {
      var e = RangeError;
      h.exports = function(t) {
        if (t === t) return t;
        throw new e("NaN is not allowed");
      };
    }
  ),
  /***/
  2360: (
    /***/
    (h, e, t) => {
      var s = t(8551), i = t(6801), n = t(8727), r = t(421), o = t(397), l = t(4055), c = t(6119), d = ">", u = "<", f = "prototype", g = "script", m = c("IE_PROTO"), y = function() {
      }, w = function(P) {
        return u + g + d + P + u + "/" + g + d;
      }, A = function(P) {
        P.write(w("")), P.close();
        var C = P.parentWindow.Object;
        return P = null, C;
      }, E = function() {
        var P = l("iframe"), C = "java" + g + ":", R;
        return P.style.display = "none", o.appendChild(P), P.src = String(C), R = P.contentWindow.document, R.open(), R.write(w("document.F=Object")), R.close(), R.F;
      }, S, T = function() {
        try {
          S = new ActiveXObject("htmlfile");
        } catch {
        }
        T = typeof document < "u" ? document.domain && S ? A(S) : E() : A(S);
        for (var P = n.length; P--; ) delete T[f][n[P]];
        return T();
      };
      r[m] = !0, h.exports = Object.create || function(C, R) {
        var _;
        return C !== null ? (y[f] = s(C), _ = new y(), y[f] = null, _[m] = C) : _ = T(), R === void 0 ? _ : i.f(_, R);
      };
    }
  ),
  /***/
  6801: (
    /***/
    (h, e, t) => {
      var s = t(3724), i = t(8686), n = t(4913), r = t(8551), o = t(5397), l = t(1072);
      e.f = s && !i ? Object.defineProperties : function(d, u) {
        r(d);
        for (var f = o(u), g = l(u), m = g.length, y = 0, w; m > y; ) n.f(d, w = g[y++], f[w]);
        return d;
      };
    }
  ),
  /***/
  4913: (
    /***/
    (h, e, t) => {
      var s = t(3724), i = t(5917), n = t(8686), r = t(8551), o = t(6969), l = TypeError, c = Object.defineProperty, d = Object.getOwnPropertyDescriptor, u = "enumerable", f = "configurable", g = "writable";
      e.f = s ? n ? function(y, w, A) {
        if (r(y), w = o(w), r(A), typeof y == "function" && w === "prototype" && "value" in A && g in A && !A[g]) {
          var E = d(y, w);
          E && E[g] && (y[w] = A.value, A = {
            configurable: f in A ? A[f] : E[f],
            enumerable: u in A ? A[u] : E[u],
            writable: !1
          });
        }
        return c(y, w, A);
      } : c : function(y, w, A) {
        if (r(y), w = o(w), r(A), i) try {
          return c(y, w, A);
        } catch {
        }
        if ("get" in A || "set" in A) throw new l("Accessors not supported");
        return "value" in A && (y[w] = A.value), y;
      };
    }
  ),
  /***/
  7347: (
    /***/
    (h, e, t) => {
      var s = t(3724), i = t(9565), n = t(8773), r = t(6980), o = t(5397), l = t(6969), c = t(9297), d = t(5917), u = Object.getOwnPropertyDescriptor;
      e.f = s ? u : function(g, m) {
        if (g = o(g), m = l(m), d) try {
          return u(g, m);
        } catch {
        }
        if (c(g, m)) return r(!i(n.f, g, m), g[m]);
      };
    }
  ),
  /***/
  8480: (
    /***/
    (h, e, t) => {
      var s = t(1828), i = t(8727), n = i.concat("length", "prototype");
      e.f = Object.getOwnPropertyNames || function(o) {
        return s(o, n);
      };
    }
  ),
  /***/
  3717: (
    /***/
    (h, e) => {
      e.f = Object.getOwnPropertySymbols;
    }
  ),
  /***/
  2787: (
    /***/
    (h, e, t) => {
      var s = t(9297), i = t(4901), n = t(8981), r = t(6119), o = t(2211), l = r("IE_PROTO"), c = Object, d = c.prototype;
      h.exports = o ? c.getPrototypeOf : function(u) {
        var f = n(u);
        if (s(f, l)) return f[l];
        var g = f.constructor;
        return i(g) && f instanceof g ? g.prototype : f instanceof c ? d : null;
      };
    }
  ),
  /***/
  1625: (
    /***/
    (h, e, t) => {
      var s = t(9504);
      h.exports = s({}.isPrototypeOf);
    }
  ),
  /***/
  1828: (
    /***/
    (h, e, t) => {
      var s = t(9504), i = t(9297), n = t(5397), r = t(9617).indexOf, o = t(421), l = s([].push);
      h.exports = function(c, d) {
        var u = n(c), f = 0, g = [], m;
        for (m in u) !i(o, m) && i(u, m) && l(g, m);
        for (; d.length > f; ) i(u, m = d[f++]) && (~r(g, m) || l(g, m));
        return g;
      };
    }
  ),
  /***/
  1072: (
    /***/
    (h, e, t) => {
      var s = t(1828), i = t(8727);
      h.exports = Object.keys || function(r) {
        return s(r, i);
      };
    }
  ),
  /***/
  8773: (
    /***/
    (h, e) => {
      var t = {}.propertyIsEnumerable, s = Object.getOwnPropertyDescriptor, i = s && !t.call({ 1: 2 }, 1);
      e.f = i ? function(r) {
        var o = s(this, r);
        return !!o && o.enumerable;
      } : t;
    }
  ),
  /***/
  2967: (
    /***/
    (h, e, t) => {
      var s = t(6706), i = t(34), n = t(7750), r = t(3506);
      h.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var o = !1, l = {}, c;
        try {
          c = s(Object.prototype, "__proto__", "set"), c(l, []), o = l instanceof Array;
        } catch {
        }
        return function(u, f) {
          return n(u), r(f), i(u) && (o ? c(u, f) : u.__proto__ = f), u;
        };
      }() : void 0);
    }
  ),
  /***/
  4270: (
    /***/
    (h, e, t) => {
      var s = t(9565), i = t(4901), n = t(34), r = TypeError;
      h.exports = function(o, l) {
        var c, d;
        if (l === "string" && i(c = o.toString) && !n(d = s(c, o)) || i(c = o.valueOf) && !n(d = s(c, o)) || l !== "string" && i(c = o.toString) && !n(d = s(c, o))) return d;
        throw new r("Can't convert object to primitive value");
      };
    }
  ),
  /***/
  5031: (
    /***/
    (h, e, t) => {
      var s = t(7751), i = t(9504), n = t(8480), r = t(3717), o = t(8551), l = i([].concat);
      h.exports = s("Reflect", "ownKeys") || function(d) {
        var u = n.f(o(d)), f = r.f;
        return f ? l(u, f(d)) : u;
      };
    }
  ),
  /***/
  8235: (
    /***/
    (h, e, t) => {
      var s = t(9504), i = t(9297), n = SyntaxError, r = parseInt, o = String.fromCharCode, l = s("".charAt), c = s("".slice), d = s(/./.exec), u = {
        '\\"': '"',
        "\\\\": "\\",
        "\\/": "/",
        "\\b": "\b",
        "\\f": "\f",
        "\\n": `
`,
        "\\r": "\r",
        "\\t": "	"
      }, f = /^[\da-f]{4}$/i, g = /^[\u0000-\u001F]$/;
      h.exports = function(m, y) {
        for (var w = !0, A = ""; y < m.length; ) {
          var E = l(m, y);
          if (E === "\\") {
            var S = c(m, y, y + 2);
            if (i(u, S))
              A += u[S], y += 2;
            else if (S === "\\u") {
              y += 2;
              var T = c(m, y, y + 4);
              if (!d(f, T)) throw new n("Bad Unicode escape at: " + y);
              A += o(r(T, 16)), y += 4;
            } else throw new n('Unknown escape sequence: "' + S + '"');
          } else if (E === '"') {
            w = !1, y++;
            break;
          } else {
            if (d(g, E)) throw new n("Bad control character in string literal at: " + y);
            A += E, y++;
          }
        }
        if (w) throw new n("Unterminated string at: " + y);
        return { value: A, end: y };
      };
    }
  ),
  /***/
  1103: (
    /***/
    (h) => {
      h.exports = function(e) {
        try {
          return { error: !1, value: e() };
        } catch (t) {
          return { error: !0, value: t };
        }
      };
    }
  ),
  /***/
  7750: (
    /***/
    (h, e, t) => {
      var s = t(4117), i = TypeError;
      h.exports = function(n) {
        if (s(n)) throw new i("Can't call method on " + n);
        return n;
      };
    }
  ),
  /***/
  9286: (
    /***/
    (h, e, t) => {
      var s = t(4402), i = t(8469), n = s.Set, r = s.add;
      h.exports = function(o) {
        var l = new n();
        return i(o, function(c) {
          r(l, c);
        }), l;
      };
    }
  ),
  /***/
  3440: (
    /***/
    (h, e, t) => {
      var s = t(7080), i = t(4402), n = t(9286), r = t(5170), o = t(3789), l = t(8469), c = t(507), d = i.has, u = i.remove;
      h.exports = function(g) {
        var m = s(this), y = o(g), w = n(m);
        return r(m) <= y.size ? l(m, function(A) {
          y.includes(A) && u(w, A);
        }) : c(y.getIterator(), function(A) {
          d(m, A) && u(w, A);
        }), w;
      };
    }
  ),
  /***/
  4402: (
    /***/
    (h, e, t) => {
      var s = t(9504), i = Set.prototype;
      h.exports = {
        // eslint-disable-next-line es/no-set -- safe
        Set,
        add: s(i.add),
        has: s(i.has),
        remove: s(i.delete),
        proto: i
      };
    }
  ),
  /***/
  8750: (
    /***/
    (h, e, t) => {
      var s = t(7080), i = t(4402), n = t(5170), r = t(3789), o = t(8469), l = t(507), c = i.Set, d = i.add, u = i.has;
      h.exports = function(g) {
        var m = s(this), y = r(g), w = new c();
        return n(m) > y.size ? l(y.getIterator(), function(A) {
          u(m, A) && d(w, A);
        }) : o(m, function(A) {
          y.includes(A) && d(w, A);
        }), w;
      };
    }
  ),
  /***/
  4449: (
    /***/
    (h, e, t) => {
      var s = t(7080), i = t(4402).has, n = t(5170), r = t(3789), o = t(8469), l = t(507), c = t(9539);
      h.exports = function(u) {
        var f = s(this), g = r(u);
        if (n(f) <= g.size) return o(f, function(y) {
          if (g.includes(y)) return !1;
        }, !0) !== !1;
        var m = g.getIterator();
        return l(m, function(y) {
          if (i(f, y)) return c(m, "normal", !1);
        }) !== !1;
      };
    }
  ),
  /***/
  3838: (
    /***/
    (h, e, t) => {
      var s = t(7080), i = t(5170), n = t(8469), r = t(3789);
      h.exports = function(l) {
        var c = s(this), d = r(l);
        return i(c) > d.size ? !1 : n(c, function(u) {
          if (!d.includes(u)) return !1;
        }, !0) !== !1;
      };
    }
  ),
  /***/
  8527: (
    /***/
    (h, e, t) => {
      var s = t(7080), i = t(4402).has, n = t(5170), r = t(3789), o = t(507), l = t(9539);
      h.exports = function(d) {
        var u = s(this), f = r(d);
        if (n(u) < f.size) return !1;
        var g = f.getIterator();
        return o(g, function(m) {
          if (!i(u, m)) return l(g, "normal", !1);
        }) !== !1;
      };
    }
  ),
  /***/
  8469: (
    /***/
    (h, e, t) => {
      var s = t(9504), i = t(507), n = t(4402), r = n.Set, o = n.proto, l = s(o.forEach), c = s(o.keys), d = c(new r()).next;
      h.exports = function(u, f, g) {
        return g ? i({ iterator: c(u), next: d }, f) : l(u, f);
      };
    }
  ),
  /***/
  4916: (
    /***/
    (h, e, t) => {
      var s = t(7751), i = function(n) {
        return {
          size: n,
          has: function() {
            return !1;
          },
          keys: function() {
            return {
              next: function() {
                return { done: !0 };
              }
            };
          }
        };
      };
      h.exports = function(n) {
        var r = s("Set");
        try {
          new r()[n](i(0));
          try {
            return new r()[n](i(-1)), !1;
          } catch {
            return !0;
          }
        } catch {
          return !1;
        }
      };
    }
  ),
  /***/
  5170: (
    /***/
    (h, e, t) => {
      var s = t(6706), i = t(4402);
      h.exports = s(i.proto, "size", "get") || function(n) {
        return n.size;
      };
    }
  ),
  /***/
  3650: (
    /***/
    (h, e, t) => {
      var s = t(7080), i = t(4402), n = t(9286), r = t(3789), o = t(507), l = i.add, c = i.has, d = i.remove;
      h.exports = function(f) {
        var g = s(this), m = r(f).getIterator(), y = n(g);
        return o(m, function(w) {
          c(g, w) ? d(y, w) : l(y, w);
        }), y;
      };
    }
  ),
  /***/
  4204: (
    /***/
    (h, e, t) => {
      var s = t(7080), i = t(4402).add, n = t(9286), r = t(3789), o = t(507);
      h.exports = function(c) {
        var d = s(this), u = r(c).getIterator(), f = n(d);
        return o(u, function(g) {
          i(f, g);
        }), f;
      };
    }
  ),
  /***/
  6119: (
    /***/
    (h, e, t) => {
      var s = t(5745), i = t(3392), n = s("keys");
      h.exports = function(r) {
        return n[r] || (n[r] = i(r));
      };
    }
  ),
  /***/
  7629: (
    /***/
    (h, e, t) => {
      var s = t(6395), i = t(4576), n = t(9433), r = "__core-js_shared__", o = h.exports = i[r] || n(r, {});
      (o.versions || (o.versions = [])).push({
        version: "3.39.0",
        mode: s ? "pure" : "global",
        copyright: "© 2014-2024 Denis Pushkarev (zloirock.ru)",
        license: "https://github.com/zloirock/core-js/blob/v3.39.0/LICENSE",
        source: "https://github.com/zloirock/core-js"
      });
    }
  ),
  /***/
  5745: (
    /***/
    (h, e, t) => {
      var s = t(7629);
      h.exports = function(i, n) {
        return s[i] || (s[i] = n || {});
      };
    }
  ),
  /***/
  1548: (
    /***/
    (h, e, t) => {
      var s = t(4576), i = t(9039), n = t(9519), r = t(4215), o = s.structuredClone;
      h.exports = !!o && !i(function() {
        if (r === "DENO" && n > 92 || r === "NODE" && n > 94 || r === "BROWSER" && n > 97) return !1;
        var l = new ArrayBuffer(8), c = o(l, { transfer: [l] });
        return l.byteLength !== 0 || c.byteLength !== 8;
      });
    }
  ),
  /***/
  4495: (
    /***/
    (h, e, t) => {
      var s = t(9519), i = t(9039), n = t(4576), r = n.String;
      h.exports = !!Object.getOwnPropertySymbols && !i(function() {
        var o = Symbol("symbol detection");
        return !r(o) || !(Object(o) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
        !Symbol.sham && s && s < 41;
      });
    }
  ),
  /***/
  5610: (
    /***/
    (h, e, t) => {
      var s = t(1291), i = Math.max, n = Math.min;
      h.exports = function(r, o) {
        var l = s(r);
        return l < 0 ? i(l + o, 0) : n(l, o);
      };
    }
  ),
  /***/
  5854: (
    /***/
    (h, e, t) => {
      var s = t(2777), i = TypeError;
      h.exports = function(n) {
        var r = s(n, "number");
        if (typeof r == "number") throw new i("Can't convert number to bigint");
        return BigInt(r);
      };
    }
  ),
  /***/
  7696: (
    /***/
    (h, e, t) => {
      var s = t(1291), i = t(8014), n = RangeError;
      h.exports = function(r) {
        if (r === void 0) return 0;
        var o = s(r), l = i(o);
        if (o !== l) throw new n("Wrong length or index");
        return l;
      };
    }
  ),
  /***/
  5397: (
    /***/
    (h, e, t) => {
      var s = t(7055), i = t(7750);
      h.exports = function(n) {
        return s(i(n));
      };
    }
  ),
  /***/
  1291: (
    /***/
    (h, e, t) => {
      var s = t(741);
      h.exports = function(i) {
        var n = +i;
        return n !== n || n === 0 ? 0 : s(n);
      };
    }
  ),
  /***/
  8014: (
    /***/
    (h, e, t) => {
      var s = t(1291), i = Math.min;
      h.exports = function(n) {
        var r = s(n);
        return r > 0 ? i(r, 9007199254740991) : 0;
      };
    }
  ),
  /***/
  8981: (
    /***/
    (h, e, t) => {
      var s = t(7750), i = Object;
      h.exports = function(n) {
        return i(s(n));
      };
    }
  ),
  /***/
  9590: (
    /***/
    (h, e, t) => {
      var s = t(1291), i = RangeError;
      h.exports = function(n) {
        var r = s(n);
        if (r < 0) throw new i("The argument can't be less than 0");
        return r;
      };
    }
  ),
  /***/
  2777: (
    /***/
    (h, e, t) => {
      var s = t(9565), i = t(34), n = t(757), r = t(5966), o = t(4270), l = t(8227), c = TypeError, d = l("toPrimitive");
      h.exports = function(u, f) {
        if (!i(u) || n(u)) return u;
        var g = r(u, d), m;
        if (g) {
          if (f === void 0 && (f = "default"), m = s(g, u, f), !i(m) || n(m)) return m;
          throw new c("Can't convert object to primitive value");
        }
        return f === void 0 && (f = "number"), o(u, f);
      };
    }
  ),
  /***/
  6969: (
    /***/
    (h, e, t) => {
      var s = t(2777), i = t(757);
      h.exports = function(n) {
        var r = s(n, "string");
        return i(r) ? r : r + "";
      };
    }
  ),
  /***/
  2140: (
    /***/
    (h, e, t) => {
      var s = t(8227), i = s("toStringTag"), n = {};
      n[i] = "z", h.exports = String(n) === "[object z]";
    }
  ),
  /***/
  655: (
    /***/
    (h, e, t) => {
      var s = t(6955), i = String;
      h.exports = function(n) {
        if (s(n) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
        return i(n);
      };
    }
  ),
  /***/
  6823: (
    /***/
    (h) => {
      var e = String;
      h.exports = function(t) {
        try {
          return e(t);
        } catch {
          return "Object";
        }
      };
    }
  ),
  /***/
  3392: (
    /***/
    (h, e, t) => {
      var s = t(9504), i = 0, n = Math.random(), r = s(1 .toString);
      h.exports = function(o) {
        return "Symbol(" + (o === void 0 ? "" : o) + ")_" + r(++i + n, 36);
      };
    }
  ),
  /***/
  7040: (
    /***/
    (h, e, t) => {
      var s = t(4495);
      h.exports = s && !Symbol.sham && typeof Symbol.iterator == "symbol";
    }
  ),
  /***/
  8686: (
    /***/
    (h, e, t) => {
      var s = t(3724), i = t(9039);
      h.exports = s && i(function() {
        return Object.defineProperty(function() {
        }, "prototype", {
          value: 42,
          writable: !1
        }).prototype !== 42;
      });
    }
  ),
  /***/
  2812: (
    /***/
    (h) => {
      var e = TypeError;
      h.exports = function(t, s) {
        if (t < s) throw new e("Not enough arguments");
        return t;
      };
    }
  ),
  /***/
  8622: (
    /***/
    (h, e, t) => {
      var s = t(4576), i = t(4901), n = s.WeakMap;
      h.exports = i(n) && /native code/.test(String(n));
    }
  ),
  /***/
  8227: (
    /***/
    (h, e, t) => {
      var s = t(4576), i = t(5745), n = t(9297), r = t(3392), o = t(4495), l = t(7040), c = s.Symbol, d = i("wks"), u = l ? c.for || c : c && c.withoutSetter || r;
      h.exports = function(f) {
        return n(d, f) || (d[f] = o && n(c, f) ? c[f] : u("Symbol." + f)), d[f];
      };
    }
  ),
  /***/
  6573: (
    /***/
    (h, e, t) => {
      var s = t(3724), i = t(2106), n = t(3238), r = ArrayBuffer.prototype;
      s && !("detached" in r) && i(r, "detached", {
        configurable: !0,
        get: function() {
          return n(this);
        }
      });
    }
  ),
  /***/
  7936: (
    /***/
    (h, e, t) => {
      var s = t(6518), i = t(5636);
      i && s({ target: "ArrayBuffer", proto: !0 }, {
        transferToFixedLength: function() {
          return i(this, arguments.length ? arguments[0] : void 0, !1);
        }
      });
    }
  ),
  /***/
  8100: (
    /***/
    (h, e, t) => {
      var s = t(6518), i = t(5636);
      i && s({ target: "ArrayBuffer", proto: !0 }, {
        transfer: function() {
          return i(this, arguments.length ? arguments[0] : void 0, !0);
        }
      });
    }
  ),
  /***/
  4114: (
    /***/
    (h, e, t) => {
      var s = t(6518), i = t(8981), n = t(6198), r = t(4527), o = t(6837), l = t(9039), c = l(function() {
        return [].push.call({ length: 4294967296 }, 1) !== 4294967297;
      }), d = function() {
        try {
          Object.defineProperty([], "length", { writable: !1 }).push();
        } catch (f) {
          return f instanceof TypeError;
        }
      }, u = c || !d();
      s({ target: "Array", proto: !0, arity: 1, forced: u }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        push: function(g) {
          var m = i(this), y = n(m), w = arguments.length;
          o(y + w);
          for (var A = 0; A < w; A++)
            m[y] = arguments[A], y++;
          return r(m, y), y;
        }
      });
    }
  ),
  /***/
  8111: (
    /***/
    (h, e, t) => {
      var s = t(6518), i = t(4576), n = t(679), r = t(8551), o = t(4901), l = t(2787), c = t(2106), d = t(4659), u = t(9039), f = t(9297), g = t(8227), m = t(7657).IteratorPrototype, y = t(3724), w = t(6395), A = "constructor", E = "Iterator", S = g("toStringTag"), T = TypeError, P = i[E], C = w || !o(P) || P.prototype !== m || !u(function() {
        P({});
      }), R = function() {
        if (n(this, m), l(this) === m) throw new T("Abstract class Iterator not directly constructable");
      }, _ = function(x, I) {
        y ? c(m, x, {
          configurable: !0,
          get: function() {
            return I;
          },
          set: function(L) {
            if (r(this), this === m) throw new T("You can't redefine this property");
            f(this, x) ? this[x] = L : d(this, x, L);
          }
        }) : m[x] = I;
      };
      f(m, S) || _(S, E), (C || !f(m, A) || m[A] === Object) && _(A, R), R.prototype = m, s({ global: !0, constructor: !0, forced: C }, {
        Iterator: R
      });
    }
  ),
  /***/
  9314: (
    /***/
    (h, e, t) => {
      var s = t(6518), i = t(9565), n = t(8551), r = t(1767), o = t(4149), l = t(9590), c = t(9462), d = t(6395), u = c(function() {
        for (var f = this.iterator, g = this.next, m, y; this.remaining; )
          if (this.remaining--, m = n(i(g, f)), y = this.done = !!m.done, y) return;
        if (m = n(i(g, f)), y = this.done = !!m.done, !y) return m.value;
      });
      s({ target: "Iterator", proto: !0, real: !0, forced: d }, {
        drop: function(g) {
          n(this);
          var m = l(o(+g));
          return new u(r(this), {
            remaining: m
          });
        }
      });
    }
  ),
  /***/
  1148: (
    /***/
    (h, e, t) => {
      var s = t(6518), i = t(2652), n = t(9306), r = t(8551), o = t(1767);
      s({ target: "Iterator", proto: !0, real: !0 }, {
        every: function(c) {
          r(this), n(c);
          var d = o(this), u = 0;
          return !i(d, function(f, g) {
            if (!c(f, u++)) return g();
          }, { IS_RECORD: !0, INTERRUPTED: !0 }).stopped;
        }
      });
    }
  ),
  /***/
  2489: (
    /***/
    (h, e, t) => {
      var s = t(6518), i = t(9565), n = t(9306), r = t(8551), o = t(1767), l = t(9462), c = t(6319), d = t(6395), u = l(function() {
        for (var f = this.iterator, g = this.predicate, m = this.next, y, w, A; ; ) {
          if (y = r(i(m, f)), w = this.done = !!y.done, w) return;
          if (A = y.value, c(f, g, [A, this.counter++], !0)) return A;
        }
      });
      s({ target: "Iterator", proto: !0, real: !0, forced: d }, {
        filter: function(g) {
          return r(this), n(g), new u(o(this), {
            predicate: g
          });
        }
      });
    }
  ),
  /***/
  531: (
    /***/
    (h, e, t) => {
      var s = t(6518), i = t(9565), n = t(9306), r = t(8551), o = t(1767), l = t(8646), c = t(9462), d = t(9539), u = t(6395), f = c(function() {
        for (var g = this.iterator, m = this.mapper, y, w; ; ) {
          if (w = this.inner) try {
            if (y = r(i(w.next, w.iterator)), !y.done) return y.value;
            this.inner = null;
          } catch (A) {
            d(g, "throw", A);
          }
          if (y = r(i(this.next, g)), this.done = !!y.done) return;
          try {
            this.inner = l(m(y.value, this.counter++), !1);
          } catch (A) {
            d(g, "throw", A);
          }
        }
      });
      s({ target: "Iterator", proto: !0, real: !0, forced: u }, {
        flatMap: function(m) {
          return r(this), n(m), new f(o(this), {
            mapper: m,
            inner: null
          });
        }
      });
    }
  ),
  /***/
  1701: (
    /***/
    (h, e, t) => {
      var s = t(6518), i = t(713), n = t(6395);
      s({ target: "Iterator", proto: !0, real: !0, forced: n }, {
        map: i
      });
    }
  ),
  /***/
  3579: (
    /***/
    (h, e, t) => {
      var s = t(6518), i = t(2652), n = t(9306), r = t(8551), o = t(1767);
      s({ target: "Iterator", proto: !0, real: !0 }, {
        some: function(c) {
          r(this), n(c);
          var d = o(this), u = 0;
          return i(d, function(f, g) {
            if (c(f, u++)) return g();
          }, { IS_RECORD: !0, INTERRUPTED: !0 }).stopped;
        }
      });
    }
  ),
  /***/
  1689: (
    /***/
    (h, e, t) => {
      var s = t(6518), i = t(4576), n = t(8745), r = t(7680), o = t(6043), l = t(9306), c = t(1103), d = i.Promise, u = !1, f = !d || !d.try || c(function() {
        d.try(function(g) {
          u = g === 8;
        }, 8);
      }).error || !u;
      s({ target: "Promise", stat: !0, forced: f }, {
        try: function(g) {
          var m = arguments.length > 1 ? r(arguments, 1) : [], y = o.f(this), w = c(function() {
            return n(l(g), void 0, m);
          });
          return (w.error ? y.reject : y.resolve)(w.value), y.promise;
        }
      });
    }
  ),
  /***/
  4628: (
    /***/
    (h, e, t) => {
      var s = t(6518), i = t(6043);
      s({ target: "Promise", stat: !0 }, {
        withResolvers: function() {
          var r = i.f(this);
          return {
            promise: r.promise,
            resolve: r.resolve,
            reject: r.reject
          };
        }
      });
    }
  ),
  /***/
  7642: (
    /***/
    (h, e, t) => {
      var s = t(6518), i = t(3440), n = t(4916);
      s({ target: "Set", proto: !0, real: !0, forced: !n("difference") }, {
        difference: i
      });
    }
  ),
  /***/
  8004: (
    /***/
    (h, e, t) => {
      var s = t(6518), i = t(9039), n = t(8750), r = t(4916), o = !r("intersection") || i(function() {
        return String(Array.from((/* @__PURE__ */ new Set([1, 2, 3])).intersection(/* @__PURE__ */ new Set([3, 2])))) !== "3,2";
      });
      s({ target: "Set", proto: !0, real: !0, forced: o }, {
        intersection: n
      });
    }
  ),
  /***/
  3853: (
    /***/
    (h, e, t) => {
      var s = t(6518), i = t(4449), n = t(4916);
      s({ target: "Set", proto: !0, real: !0, forced: !n("isDisjointFrom") }, {
        isDisjointFrom: i
      });
    }
  ),
  /***/
  5876: (
    /***/
    (h, e, t) => {
      var s = t(6518), i = t(3838), n = t(4916);
      s({ target: "Set", proto: !0, real: !0, forced: !n("isSubsetOf") }, {
        isSubsetOf: i
      });
    }
  ),
  /***/
  2475: (
    /***/
    (h, e, t) => {
      var s = t(6518), i = t(8527), n = t(4916);
      s({ target: "Set", proto: !0, real: !0, forced: !n("isSupersetOf") }, {
        isSupersetOf: i
      });
    }
  ),
  /***/
  5024: (
    /***/
    (h, e, t) => {
      var s = t(6518), i = t(3650), n = t(4916);
      s({ target: "Set", proto: !0, real: !0, forced: !n("symmetricDifference") }, {
        symmetricDifference: i
      });
    }
  ),
  /***/
  1698: (
    /***/
    (h, e, t) => {
      var s = t(6518), i = t(4204), n = t(4916);
      s({ target: "Set", proto: !0, real: !0, forced: !n("union") }, {
        union: i
      });
    }
  ),
  /***/
  7467: (
    /***/
    (h, e, t) => {
      var s = t(7628), i = t(4644), n = i.aTypedArray, r = i.exportTypedArrayMethod, o = i.getTypedArrayConstructor;
      r("toReversed", function() {
        return s(n(this), o(this));
      });
    }
  ),
  /***/
  4732: (
    /***/
    (h, e, t) => {
      var s = t(4644), i = t(9504), n = t(9306), r = t(5370), o = s.aTypedArray, l = s.getTypedArrayConstructor, c = s.exportTypedArrayMethod, d = i(s.TypedArrayPrototype.sort);
      c("toSorted", function(f) {
        f !== void 0 && n(f);
        var g = o(this), m = r(l(g), g);
        return d(m, f);
      });
    }
  ),
  /***/
  9577: (
    /***/
    (h, e, t) => {
      var s = t(9928), i = t(4644), n = t(1108), r = t(1291), o = t(5854), l = i.aTypedArray, c = i.getTypedArrayConstructor, d = i.exportTypedArrayMethod, u = !!function() {
        try {
          new Int8Array(1).with(2, { valueOf: function() {
            throw 8;
          } });
        } catch (f) {
          return f === 8;
        }
      }();
      d("with", function(f, g) {
        var m = l(this), y = r(f), w = n(m) ? o(g) : +g;
        return s(m, c(m), y, w);
      }, !u);
    }
  ),
  /***/
  8992: (
    /***/
    (h, e, t) => {
      t(8111);
    }
  ),
  /***/
  4743: (
    /***/
    (h, e, t) => {
      t(9314);
    }
  ),
  /***/
  3215: (
    /***/
    (h, e, t) => {
      t(1148);
    }
  ),
  /***/
  4520: (
    /***/
    (h, e, t) => {
      t(2489);
    }
  ),
  /***/
  670: (
    /***/
    (h, e, t) => {
      t(531);
    }
  ),
  /***/
  1454: (
    /***/
    (h, e, t) => {
      t(1701);
    }
  ),
  /***/
  7550: (
    /***/
    (h, e, t) => {
      t(3579);
    }
  ),
  /***/
  8335: (
    /***/
    (h, e, t) => {
      var s = t(6518), i = t(3724), n = t(4576), r = t(7751), o = t(9504), l = t(9565), c = t(4901), d = t(34), u = t(4376), f = t(9297), g = t(655), m = t(6198), y = t(4659), w = t(9039), A = t(8235), E = t(4495), S = n.JSON, T = n.Number, P = n.SyntaxError, C = S && S.parse, R = r("Object", "keys"), _ = Object.getOwnPropertyDescriptor, x = o("".charAt), I = o("".slice), L = o(/./.exec), j = o([].push), k = /^\d$/, F = /^[1-9]$/, Y = /^[\d-]$/, N = /^[\t\n\r ]$/, D = 0, et = 1, ft = function($, O) {
        $ = g($);
        var H = new St($, 0), st = H.parse(), xt = st.value, J = H.skip(N, st.end);
        if (J < $.length)
          throw new P('Unexpected extra character: "' + x($, J) + '" after the parsed data at: ' + J);
        return c(O) ? Et({ "": xt }, "", O, st) : xt;
      }, Et = function($, O, H, st) {
        var xt = $[O], J = st && xt === st.value, kt = J && typeof st.source == "string" ? { source: st.source } : {}, Ft, Us, Pe, te, Ga;
        if (d(xt)) {
          var pf = u(xt), Td = J ? st.nodes : pf ? [] : {};
          if (pf)
            for (Ft = Td.length, Pe = m(xt), te = 0; te < Pe; te++)
              Dt(xt, te, Et(xt, "" + te, H, te < Ft ? Td[te] : void 0));
          else
            for (Us = R(xt), Pe = m(Us), te = 0; te < Pe; te++)
              Ga = Us[te], Dt(xt, Ga, Et(xt, Ga, H, f(Td, Ga) ? Td[Ga] : void 0));
        }
        return l(H, $, O, xt, kt);
      }, Dt = function($, O, H) {
        if (i) {
          var st = _($, O);
          if (st && !st.configurable) return;
        }
        H === void 0 ? delete $[O] : y($, O, H);
      }, yt = function($, O, H, st) {
        this.value = $, this.end = O, this.source = H, this.nodes = st;
      }, St = function($, O) {
        this.source = $, this.index = O;
      };
      St.prototype = {
        fork: function($) {
          return new St(this.source, $);
        },
        parse: function() {
          var $ = this.source, O = this.skip(N, this.index), H = this.fork(O), st = x($, O);
          if (L(Y, st)) return H.number();
          switch (st) {
            case "{":
              return H.object();
            case "[":
              return H.array();
            case '"':
              return H.string();
            case "t":
              return H.keyword(!0);
            case "f":
              return H.keyword(!1);
            case "n":
              return H.keyword(null);
          }
          throw new P('Unexpected character: "' + st + '" at: ' + O);
        },
        node: function($, O, H, st, xt) {
          return new yt(O, st, $ ? null : I(this.source, H, st), xt);
        },
        object: function() {
          for (var $ = this.source, O = this.index + 1, H = !1, st = {}, xt = {}; O < $.length; ) {
            if (O = this.until(['"', "}"], O), x($, O) === "}" && !H) {
              O++;
              break;
            }
            var J = this.fork(O).string(), kt = J.value;
            O = J.end, O = this.until([":"], O) + 1, O = this.skip(N, O), J = this.fork(O).parse(), y(xt, kt, J), y(st, kt, J.value), O = this.until([",", "}"], J.end);
            var Ft = x($, O);
            if (Ft === ",")
              H = !0, O++;
            else if (Ft === "}") {
              O++;
              break;
            }
          }
          return this.node(et, st, this.index, O, xt);
        },
        array: function() {
          for (var $ = this.source, O = this.index + 1, H = !1, st = [], xt = []; O < $.length; ) {
            if (O = this.skip(N, O), x($, O) === "]" && !H) {
              O++;
              break;
            }
            var J = this.fork(O).parse();
            if (j(xt, J), j(st, J.value), O = this.until([",", "]"], J.end), x($, O) === ",")
              H = !0, O++;
            else if (x($, O) === "]") {
              O++;
              break;
            }
          }
          return this.node(et, st, this.index, O, xt);
        },
        string: function() {
          var $ = this.index, O = A(this.source, this.index + 1);
          return this.node(D, O.value, $, O.end);
        },
        number: function() {
          var $ = this.source, O = this.index, H = O;
          if (x($, H) === "-" && H++, x($, H) === "0") H++;
          else if (L(F, x($, H))) H = this.skip(k, H + 1);
          else throw new P("Failed to parse number at: " + H);
          if (x($, H) === "." && (H = this.skip(k, H + 1)), x($, H) === "e" || x($, H) === "E") {
            H++, (x($, H) === "+" || x($, H) === "-") && H++;
            var st = H;
            if (H = this.skip(k, H), st === H) throw new P("Failed to parse number's exponent value at: " + H);
          }
          return this.node(D, T(I($, O, H)), O, H);
        },
        keyword: function($) {
          var O = "" + $, H = this.index, st = H + O.length;
          if (I(this.source, H, st) !== O) throw new P("Failed to parse value at: " + H);
          return this.node(D, $, H, st);
        },
        skip: function($, O) {
          for (var H = this.source; O < H.length && L($, x(H, O)); O++) ;
          return O;
        },
        until: function($, O) {
          O = this.skip(N, O);
          for (var H = x(this.source, O), st = 0; st < $.length; st++) if ($[st] === H) return O;
          throw new P('Unexpected character: "' + H + '" at: ' + O);
        }
      };
      var $s = w(function() {
        var $ = "9007199254740993", O;
        return C($, function(H, st, xt) {
          O = xt.source;
        }), O !== $;
      }), Vs = E && !w(function() {
        return 1 / C("-0 	") !== -1 / 0;
      });
      s({ target: "JSON", stat: !0, forced: $s }, {
        parse: function(O, H) {
          return Vs && !c(H) ? C(O) : ft(O, H);
        }
      });
    }
  ),
  /***/
  5247: (
    /***/
    (h, e, t) => {
      t(1689);
    }
  ),
  /***/
  4979: (
    /***/
    (h, e, t) => {
      var s = t(6518), i = t(4576), n = t(7751), r = t(6980), o = t(4913).f, l = t(9297), c = t(679), d = t(3167), u = t(2603), f = t(5002), g = t(8574), m = t(3724), y = t(6395), w = "DOMException", A = n("Error"), E = n(w), S = function() {
        c(this, T);
        var N = arguments.length, D = u(N < 1 ? void 0 : arguments[0]), et = u(N < 2 ? void 0 : arguments[1], "Error"), ft = new E(D, et), Et = new A(D);
        return Et.name = w, o(ft, "stack", r(1, g(Et.stack, 1))), d(ft, this, S), ft;
      }, T = S.prototype = E.prototype, P = "stack" in new A(w), C = "stack" in new E(1, 2), R = E && m && Object.getOwnPropertyDescriptor(i, w), _ = !!R && !(R.writable && R.configurable), x = P && !_ && !C;
      s({ global: !0, constructor: !0, forced: y || x }, {
        // TODO: fix export logic
        DOMException: x ? S : E
      });
      var I = n(w), L = I.prototype;
      if (L.constructor !== I) {
        y || o(L, "constructor", r(1, I));
        for (var j in f) if (l(f, j)) {
          var k = f[j], F = k.s;
          l(I, F) || o(I, F, r(6, k.c));
        }
      }
    }
  ),
  /***/
  4603: (
    /***/
    (h, e, t) => {
      var s = t(6840), i = t(9504), n = t(655), r = t(2812), o = URLSearchParams, l = o.prototype, c = i(l.append), d = i(l.delete), u = i(l.forEach), f = i([].push), g = new o("a=1&a=2&b=3");
      g.delete("a", 1), g.delete("b", void 0), g + "" != "a=2" && s(l, "delete", function(m) {
        var y = arguments.length, w = y < 2 ? void 0 : arguments[1];
        if (y && w === void 0) return d(this, m);
        var A = [];
        u(this, function(x, I) {
          f(A, { key: I, value: x });
        }), r(y, 1);
        for (var E = n(m), S = n(w), T = 0, P = 0, C = !1, R = A.length, _; T < R; )
          _ = A[T++], C || _.key === E ? (C = !0, d(this, _.key)) : P++;
        for (; P < R; )
          _ = A[P++], _.key === E && _.value === S || c(this, _.key, _.value);
      }, { enumerable: !0, unsafe: !0 });
    }
  ),
  /***/
  7566: (
    /***/
    (h, e, t) => {
      var s = t(6840), i = t(9504), n = t(655), r = t(2812), o = URLSearchParams, l = o.prototype, c = i(l.getAll), d = i(l.has), u = new o("a=1");
      (u.has("a", 2) || !u.has("a", void 0)) && s(l, "has", function(g) {
        var m = arguments.length, y = m < 2 ? void 0 : arguments[1];
        if (m && y === void 0) return d(this, g);
        var w = c(this, g);
        r(m, 1);
        for (var A = n(y), E = 0; E < w.length; )
          if (w[E++] === A) return !0;
        return !1;
      }, { enumerable: !0, unsafe: !0 });
    }
  ),
  /***/
  8721: (
    /***/
    (h, e, t) => {
      var s = t(3724), i = t(9504), n = t(2106), r = URLSearchParams.prototype, o = i(r.forEach);
      s && !("size" in r) && n(r, "size", {
        get: function() {
          var c = 0;
          return o(this, function() {
            c++;
          }), c;
        },
        configurable: !0,
        enumerable: !0
      });
    }
  )
  /******/
}, Kg = {};
function ut(h) {
  var e = Kg[h];
  if (e !== void 0)
    return e.exports;
  var t = Kg[h] = {
    /******/
    // no module.id needed
    /******/
    // no module.loaded needed
    /******/
    exports: {}
    /******/
  };
  return nA[h].call(t.exports, t, t.exports, ut), t.exports;
}
ut.d = (h, e) => {
  for (var t in e)
    ut.o(e, t) && !ut.o(h, t) && Object.defineProperty(h, t, { enumerable: !0, get: e[t] });
};
ut.o = (h, e) => Object.prototype.hasOwnProperty.call(h, e);
var q = globalThis.pdfjsLib = {};
ut.d(q, {
  AbortException: () => (
    /* reexport */
    dr
  ),
  AnnotationEditorLayer: () => (
    /* reexport */
    nE
  ),
  AnnotationEditorParamsType: () => (
    /* reexport */
    ct
  ),
  AnnotationEditorType: () => (
    /* reexport */
    at
  ),
  AnnotationEditorUIManager: () => (
    /* reexport */
    vh
  ),
  AnnotationLayer: () => (
    /* reexport */
    qw
  ),
  AnnotationMode: () => (
    /* reexport */
    gn
  ),
  ColorPicker: () => (
    /* reexport */
    Db
  ),
  DOMSVGFactory: () => (
    /* reexport */
    Fg
  ),
  DrawLayer: () => (
    /* reexport */
    rE
  ),
  FeatureTest: () => (
    /* reexport */
    Oe
  ),
  GlobalWorkerOptions: () => (
    /* reexport */
    yr
  ),
  ImageKind: () => (
    /* reexport */
    Fd
  ),
  InvalidPDFException: () => (
    /* reexport */
    kf
  ),
  MissingPDFException: () => (
    /* reexport */
    mh
  ),
  OPS: () => (
    /* reexport */
    xs
  ),
  OutputScale: () => (
    /* reexport */
    Bf
  ),
  PDFDataRangeTransport: () => (
    /* reexport */
    ib
  ),
  PDFDateString: () => (
    /* reexport */
    sv
  ),
  PDFWorker: () => (
    /* reexport */
    Qd
  ),
  PasswordResponses: () => (
    /* reexport */
    lA
  ),
  PermissionFlag: () => (
    /* reexport */
    oA
  ),
  PixelsPerInch: () => (
    /* reexport */
    Ll
  ),
  RenderingCancelledException: () => (
    /* reexport */
    Mg
  ),
  TextLayer: () => (
    /* reexport */
    up
  ),
  TouchManager: () => (
    /* reexport */
    wv
  ),
  UnexpectedResponseException: () => (
    /* reexport */
    Tu
  ),
  Util: () => (
    /* reexport */
    X
  ),
  VerbosityLevel: () => (
    /* reexport */
    nf
  ),
  XfaLayer: () => (
    /* reexport */
    rb
  ),
  build: () => (
    /* reexport */
    Ow
  ),
  createValidAbsoluteUrl: () => (
    /* reexport */
    uA
  ),
  fetchData: () => (
    /* reexport */
    lf
  ),
  getDocument: () => (
    /* reexport */
    xw
  ),
  getFilenameFromUrl: () => (
    /* reexport */
    wA
  ),
  getPdfFilenameFromUrl: () => (
    /* reexport */
    EA
  ),
  getXfaPageViewport: () => (
    /* reexport */
    SA
  ),
  isDataScheme: () => (
    /* reexport */
    hf
  ),
  isPdfFile: () => (
    /* reexport */
    Og
  ),
  noContextMenu: () => (
    /* reexport */
    js
  ),
  normalizeUnicode: () => (
    /* reexport */
    bA
  ),
  setLayerDimensions: () => (
    /* reexport */
    Va
  ),
  shadow: () => (
    /* reexport */
    ht
  ),
  stopEvent: () => (
    /* reexport */
    os
  ),
  version: () => (
    /* reexport */
    Mw
  )
});
ut(4114);
ut(6573);
ut(8100);
ut(7936);
ut(7467);
ut(4732);
ut(9577);
ut(5247);
ut(4979);
ut(4603);
ut(7566);
ut(8721);
const Te = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser"), tv = [1, 0, 0, 1, 0, 0], Df = [1e-3, 0, 0, 1e-3, 0, 0], rA = 1e7, mf = 1.35, rs = {
  ANY: 1,
  DISPLAY: 2,
  PRINT: 4,
  SAVE: 8,
  ANNOTATIONS_FORMS: 16,
  ANNOTATIONS_STORAGE: 32,
  ANNOTATIONS_DISABLE: 64,
  IS_EDITING: 128,
  OPLIST: 256
}, gn = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_FORMS: 2,
  ENABLE_STORAGE: 3
}, aA = "pdfjs_internal_editor_", at = {
  DISABLE: -1,
  NONE: 0,
  FREETEXT: 3,
  HIGHLIGHT: 9,
  STAMP: 13,
  INK: 15
}, ct = {
  RESIZE: 1,
  CREATE: 2,
  FREETEXT_SIZE: 11,
  FREETEXT_COLOR: 12,
  FREETEXT_OPACITY: 13,
  INK_COLOR: 21,
  INK_THICKNESS: 22,
  INK_OPACITY: 23,
  HIGHLIGHT_COLOR: 31,
  HIGHLIGHT_DEFAULT_COLOR: 32,
  HIGHLIGHT_THICKNESS: 33,
  HIGHLIGHT_FREE: 34,
  HIGHLIGHT_SHOW_ALL: 35,
  DRAW_STEP: 41
}, oA = {
  PRINT: 4,
  MODIFY_CONTENTS: 8,
  COPY: 16,
  MODIFY_ANNOTATIONS: 32,
  FILL_INTERACTIVE_FORMS: 256,
  COPY_FOR_ACCESSIBILITY: 512,
  ASSEMBLE: 1024,
  PRINT_HIGH_QUALITY: 2048
}, ve = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
}, Fd = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
}, Yt = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
}, Bl = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
}, nf = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
}, xs = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91,
  setStrokeTransparent: 92,
  setFillTransparent: 93
}, lA = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
let rf = nf.WARNINGS;
function hA(h) {
  Number.isInteger(h) && (rf = h);
}
function cA() {
  return rf;
}
function af(h) {
  rf >= nf.INFOS && console.log(`Info: ${h}`);
}
function tt(h) {
  rf >= nf.WARNINGS && console.log(`Warning: ${h}`);
}
function Pt(h) {
  throw new Error(h);
}
function Wt(h, e) {
  h || Pt(e);
}
function dA(h) {
  switch (h == null ? void 0 : h.protocol) {
    case "http:":
    case "https:":
    case "ftp:":
    case "mailto:":
    case "tel:":
      return !0;
    default:
      return !1;
  }
}
function uA(h, e = null, t = null) {
  if (!h)
    return null;
  try {
    if (t && typeof h == "string") {
      if (t.addDefaultProtocol && h.startsWith("www.")) {
        const i = h.match(/\./g);
        (i == null ? void 0 : i.length) >= 2 && (h = `http://${h}`);
      }
      if (t.tryConvertEncoding)
        try {
          h = vA(h);
        } catch {
        }
    }
    const s = e ? new URL(h, e) : new URL(h);
    if (dA(s))
      return s;
  } catch {
  }
  return null;
}
function ht(h, e, t, s = !1) {
  return Object.defineProperty(h, e, {
    value: t,
    enumerable: !s,
    configurable: !0,
    writable: !1
  }), t;
}
const fr = function() {
  function e(t, s) {
    this.message = t, this.name = s;
  }
  return e.prototype = new Error(), e.constructor = e, e;
}();
class Qg extends fr {
  constructor(e, t) {
    super(e, "PasswordException"), this.code = t;
  }
}
class vf extends fr {
  constructor(e, t) {
    super(e, "UnknownErrorException"), this.details = t;
  }
}
let kf = class extends fr {
  constructor(e) {
    super(e, "InvalidPDFException");
  }
}, mh = class extends fr {
  constructor(e) {
    super(e, "MissingPDFException");
  }
}, Tu = class extends fr {
  constructor(e, t) {
    super(e, "UnexpectedResponseException"), this.status = t;
  }
};
class fA extends fr {
  constructor(e) {
    super(e, "FormatError");
  }
}
let dr = class extends fr {
  constructor(e) {
    super(e, "AbortException");
  }
};
function ev(h) {
  (typeof h != "object" || (h == null ? void 0 : h.length) === void 0) && Pt("Invalid argument for bytesToString");
  const e = h.length, t = 8192;
  if (e < t)
    return String.fromCharCode.apply(null, h);
  const s = [];
  for (let i = 0; i < e; i += t) {
    const n = Math.min(i + t, e), r = h.subarray(i, n);
    s.push(String.fromCharCode.apply(null, r));
  }
  return s.join("");
}
function of(h) {
  typeof h != "string" && Pt("Invalid argument for stringToBytes");
  const e = h.length, t = new Uint8Array(e);
  for (let s = 0; s < e; ++s)
    t[s] = h.charCodeAt(s) & 255;
  return t;
}
function pA(h) {
  return String.fromCharCode(h >> 24 & 255, h >> 16 & 255, h >> 8 & 255, h & 255);
}
function _g(h) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const [t, s] of h)
    e[t] = s;
  return e;
}
function gA() {
  const h = new Uint8Array(4);
  return h[0] = 1, new Uint32Array(h.buffer, 0, 1)[0] === 1;
}
function mA() {
  try {
    return new Function(""), !0;
  } catch {
    return !1;
  }
}
class Oe {
  static get isLittleEndian() {
    return ht(this, "isLittleEndian", gA());
  }
  static get isEvalSupported() {
    return ht(this, "isEvalSupported", mA());
  }
  static get isOffscreenCanvasSupported() {
    return ht(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
  }
  static get isImageDecoderSupported() {
    return ht(this, "isImageDecoderSupported", typeof ImageDecoder < "u");
  }
  static get platform() {
    return typeof navigator < "u" && typeof (navigator == null ? void 0 : navigator.platform) == "string" ? ht(this, "platform", {
      isMac: navigator.platform.includes("Mac"),
      isWindows: navigator.platform.includes("Win"),
      isFirefox: typeof (navigator == null ? void 0 : navigator.userAgent) == "string" && navigator.userAgent.includes("Firefox")
    }) : ht(this, "platform", {
      isMac: !1,
      isWindows: !1,
      isFirefox: !1
    });
  }
  static get isCSSRoundSupported() {
    var e, t;
    return ht(this, "isCSSRoundSupported", (t = (e = globalThis.CSS) == null ? void 0 : e.supports) == null ? void 0 : t.call(e, "width: round(1.5px, 1px)"));
  }
}
const bf = Array.from(Array(256).keys(), (h) => h.toString(16).padStart(2, "0"));
var on, Mf, Bd, Ff;
let X = (Mf = class {
  static makeHexColor(e, t, s) {
    return `#${bf[e]}${bf[t]}${bf[s]}`;
  }
  static scaleMinMax(e, t) {
    let s;
    e[0] ? (e[0] < 0 && (s = t[0], t[0] = t[2], t[2] = s), t[0] *= e[0], t[2] *= e[0], e[3] < 0 && (s = t[1], t[1] = t[3], t[3] = s), t[1] *= e[3], t[3] *= e[3]) : (s = t[0], t[0] = t[1], t[1] = s, s = t[2], t[2] = t[3], t[3] = s, e[1] < 0 && (s = t[1], t[1] = t[3], t[3] = s), t[1] *= e[1], t[3] *= e[1], e[2] < 0 && (s = t[0], t[0] = t[2], t[2] = s), t[0] *= e[2], t[2] *= e[2]), t[0] += e[4], t[1] += e[5], t[2] += e[4], t[3] += e[5];
  }
  static transform(e, t) {
    return [e[0] * t[0] + e[2] * t[1], e[1] * t[0] + e[3] * t[1], e[0] * t[2] + e[2] * t[3], e[1] * t[2] + e[3] * t[3], e[0] * t[4] + e[2] * t[5] + e[4], e[1] * t[4] + e[3] * t[5] + e[5]];
  }
  static applyTransform(e, t) {
    const s = e[0] * t[0] + e[1] * t[2] + t[4], i = e[0] * t[1] + e[1] * t[3] + t[5];
    return [s, i];
  }
  static applyInverseTransform(e, t) {
    const s = t[0] * t[3] - t[1] * t[2], i = (e[0] * t[3] - e[1] * t[2] + t[2] * t[5] - t[4] * t[3]) / s, n = (-e[0] * t[1] + e[1] * t[0] + t[4] * t[1] - t[5] * t[0]) / s;
    return [i, n];
  }
  static getAxialAlignedBoundingBox(e, t) {
    const s = this.applyTransform(e, t), i = this.applyTransform(e.slice(2, 4), t), n = this.applyTransform([e[0], e[3]], t), r = this.applyTransform([e[2], e[1]], t);
    return [Math.min(s[0], i[0], n[0], r[0]), Math.min(s[1], i[1], n[1], r[1]), Math.max(s[0], i[0], n[0], r[0]), Math.max(s[1], i[1], n[1], r[1])];
  }
  static inverseTransform(e) {
    const t = e[0] * e[3] - e[1] * e[2];
    return [e[3] / t, -e[1] / t, -e[2] / t, e[0] / t, (e[2] * e[5] - e[4] * e[3]) / t, (e[4] * e[1] - e[5] * e[0]) / t];
  }
  static singularValueDecompose2dScale(e) {
    const t = [e[0], e[2], e[1], e[3]], s = e[0] * t[0] + e[1] * t[2], i = e[0] * t[1] + e[1] * t[3], n = e[2] * t[0] + e[3] * t[2], r = e[2] * t[1] + e[3] * t[3], o = (s + r) / 2, l = Math.sqrt((s + r) ** 2 - 4 * (s * r - n * i)) / 2, c = o + l || 1, d = o - l || 1;
    return [Math.sqrt(c), Math.sqrt(d)];
  }
  static normalizeRect(e) {
    const t = e.slice(0);
    return e[0] > e[2] && (t[0] = e[2], t[2] = e[0]), e[1] > e[3] && (t[1] = e[3], t[3] = e[1]), t;
  }
  static intersect(e, t) {
    const s = Math.max(Math.min(e[0], e[2]), Math.min(t[0], t[2])), i = Math.min(Math.max(e[0], e[2]), Math.max(t[0], t[2]));
    if (s > i)
      return null;
    const n = Math.max(Math.min(e[1], e[3]), Math.min(t[1], t[3])), r = Math.min(Math.max(e[1], e[3]), Math.max(t[1], t[3]));
    return n > r ? null : [s, n, i, r];
  }
  static bezierBoundingBox(e, t, s, i, n, r, o, l, c) {
    return c ? (c[0] = Math.min(c[0], e, o), c[1] = Math.min(c[1], t, l), c[2] = Math.max(c[2], e, o), c[3] = Math.max(c[3], t, l)) : c = [Math.min(e, o), Math.min(t, l), Math.max(e, o), Math.max(t, l)], v(this, on, Ff).call(this, e, s, n, o, t, i, r, l, 3 * (-e + 3 * (s - n) + o), 6 * (e - 2 * s + n), 3 * (s - e), c), v(this, on, Ff).call(this, e, s, n, o, t, i, r, l, 3 * (-t + 3 * (i - r) + l), 6 * (t - 2 * i + r), 3 * (i - t), c), c;
  }
}, on = new WeakSet(), Bd = function(e, t, s, i, n, r, o, l, c, d) {
  if (c <= 0 || c >= 1)
    return;
  const u = 1 - c, f = c * c, g = f * c, m = u * (u * (u * e + 3 * c * t) + 3 * f * s) + g * i, y = u * (u * (u * n + 3 * c * r) + 3 * f * o) + g * l;
  d[0] = Math.min(d[0], m), d[1] = Math.min(d[1], y), d[2] = Math.max(d[2], m), d[3] = Math.max(d[3], y);
}, Ff = function(e, t, s, i, n, r, o, l, c, d, u, f) {
  if (Math.abs(c) < 1e-12) {
    Math.abs(d) >= 1e-12 && v(this, on, Bd).call(this, e, t, s, i, n, r, o, l, -u / d, f);
    return;
  }
  const g = d ** 2 - 4 * u * c;
  if (g < 0)
    return;
  const m = Math.sqrt(g), y = 2 * c;
  v(this, on, Bd).call(this, e, t, s, i, n, r, o, l, (-d + m) / y, f), v(this, on, Bd).call(this, e, t, s, i, n, r, o, l, (-d - m) / y, f);
}, b(Mf, on), Mf);
function vA(h) {
  return decodeURIComponent(escape(h));
}
let yf = null, Zg = null;
function bA(h) {
  return yf || (yf = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, Zg = /* @__PURE__ */ new Map([["ﬅ", "ſt"]])), h.replaceAll(yf, (e, t, s) => t ? t.normalize("NFKC") : Zg.get(s));
}
function yA() {
  if (typeof crypto.randomUUID == "function")
    return crypto.randomUUID();
  const h = new Uint8Array(32);
  return crypto.getRandomValues(h), ev(h);
}
const Lg = "pdfjs_internal_id_";
function AA(h) {
  return Uint8Array.prototype.toBase64 ? h.toBase64() : btoa(ev(h));
}
ut(4628);
ut(7642);
ut(8004);
ut(3853);
ut(5876);
ut(2475);
ut(5024);
ut(1698);
ut(1454);
ut(8992);
ut(4743);
ut(3215);
ut(7550);
ut(8335);
const Ai = "http://www.w3.org/2000/svg";
var mi;
let Ll = (mi = class {
}, K(mi, "CSS", 96), K(mi, "PDF", 72), K(mi, "PDF_TO_CSS_UNITS", mi.CSS / mi.PDF), mi);
async function lf(h, e = "text") {
  if (Ul(h, document.baseURI)) {
    const t = await fetch(h);
    if (!t.ok)
      throw new Error(t.statusText);
    switch (e) {
      case "arraybuffer":
        return t.arrayBuffer();
      case "blob":
        return t.blob();
      case "json":
        return t.json();
    }
    return t.text();
  }
  return new Promise((t, s) => {
    const i = new XMLHttpRequest();
    i.open("GET", h, !0), i.responseType = e, i.onreadystatechange = () => {
      if (i.readyState === XMLHttpRequest.DONE) {
        if (i.status === 200 || i.status === 0) {
          switch (e) {
            case "arraybuffer":
            case "blob":
            case "json":
              t(i.response);
              return;
          }
          t(i.responseText);
          return;
        }
        s(new Error(i.statusText));
      }
    }, i.send(null);
  });
}
class Ed {
  constructor({
    viewBox: e,
    userUnit: t,
    scale: s,
    rotation: i,
    offsetX: n = 0,
    offsetY: r = 0,
    dontFlip: o = !1
  }) {
    this.viewBox = e, this.userUnit = t, this.scale = s, this.rotation = i, this.offsetX = n, this.offsetY = r, s *= t;
    const l = (e[2] + e[0]) / 2, c = (e[3] + e[1]) / 2;
    let d, u, f, g;
    switch (i %= 360, i < 0 && (i += 360), i) {
      case 180:
        d = -1, u = 0, f = 0, g = 1;
        break;
      case 90:
        d = 0, u = 1, f = 1, g = 0;
        break;
      case 270:
        d = 0, u = -1, f = -1, g = 0;
        break;
      case 0:
        d = 1, u = 0, f = 0, g = -1;
        break;
      default:
        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
    }
    o && (f = -f, g = -g);
    let m, y, w, A;
    d === 0 ? (m = Math.abs(c - e[1]) * s + n, y = Math.abs(l - e[0]) * s + r, w = (e[3] - e[1]) * s, A = (e[2] - e[0]) * s) : (m = Math.abs(l - e[0]) * s + n, y = Math.abs(c - e[1]) * s + r, w = (e[2] - e[0]) * s, A = (e[3] - e[1]) * s), this.transform = [d * s, u * s, f * s, g * s, m - d * s * l - f * s * c, y - u * s * l - g * s * c], this.width = w, this.height = A;
  }
  get rawDims() {
    const {
      userUnit: e,
      viewBox: t
    } = this, s = t.map((i) => i * e);
    return ht(this, "rawDims", {
      pageWidth: s[2] - s[0],
      pageHeight: s[3] - s[1],
      pageX: s[0],
      pageY: s[1]
    });
  }
  clone({
    scale: e = this.scale,
    rotation: t = this.rotation,
    offsetX: s = this.offsetX,
    offsetY: i = this.offsetY,
    dontFlip: n = !1
  } = {}) {
    return new Ed({
      viewBox: this.viewBox.slice(),
      userUnit: this.userUnit,
      scale: e,
      rotation: t,
      offsetX: s,
      offsetY: i,
      dontFlip: n
    });
  }
  convertToViewportPoint(e, t) {
    return X.applyTransform([e, t], this.transform);
  }
  convertToViewportRectangle(e) {
    const t = X.applyTransform([e[0], e[1]], this.transform), s = X.applyTransform([e[2], e[3]], this.transform);
    return [t[0], t[1], s[0], s[1]];
  }
  convertToPdfPoint(e, t) {
    return X.applyInverseTransform([e, t], this.transform);
  }
}
let Mg = class extends fr {
  constructor(e, t = 0) {
    super(e, "RenderingCancelledException"), this.extraDelay = t;
  }
};
function hf(h) {
  const e = h.length;
  let t = 0;
  for (; t < e && h[t].trim() === ""; )
    t++;
  return h.substring(t, t + 5).toLowerCase() === "data:";
}
function Og(h) {
  return typeof h == "string" && /\.pdf$/i.test(h);
}
function wA(h) {
  return [h] = h.split(/[#?]/, 1), h.substring(h.lastIndexOf("/") + 1);
}
function EA(h, e = "document.pdf") {
  if (typeof h != "string")
    return e;
  if (hf(h))
    return tt('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), e;
  const t = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/, s = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, i = t.exec(h);
  let n = s.exec(i[1]) || s.exec(i[2]) || s.exec(i[3]);
  if (n && (n = n[0], n.includes("%")))
    try {
      n = s.exec(decodeURIComponent(n))[0];
    } catch {
    }
  return n || e;
}
class Jg {
  constructor() {
    K(this, "started", /* @__PURE__ */ Object.create(null));
    K(this, "times", []);
  }
  time(e) {
    e in this.started && tt(`Timer is already running for ${e}`), this.started[e] = Date.now();
  }
  timeEnd(e) {
    e in this.started || tt(`Timer has not been started for ${e}`), this.times.push({
      name: e,
      start: this.started[e],
      end: Date.now()
    }), delete this.started[e];
  }
  toString() {
    const e = [];
    let t = 0;
    for (const {
      name: s
    } of this.times)
      t = Math.max(s.length, t);
    for (const {
      name: s,
      start: i,
      end: n
    } of this.times)
      e.push(`${s.padEnd(t)} ${n - i}ms
`);
    return e.join("");
  }
}
function Ul(h, e) {
  try {
    const {
      protocol: t
    } = e ? new URL(h, e) : new URL(h);
    return t === "http:" || t === "https:";
  } catch {
    return !1;
  }
}
function js(h) {
  h.preventDefault();
}
function os(h) {
  h.preventDefault(), h.stopPropagation();
}
var Of, wh;
let sv = (Of = class {
  static toDateObject(e) {
    if (!e || typeof e != "string")
      return null;
    a(this, wh) || p(this, wh, new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
    const t = a(this, wh).exec(e);
    if (!t)
      return null;
    const s = parseInt(t[1], 10);
    let i = parseInt(t[2], 10);
    i = i >= 1 && i <= 12 ? i - 1 : 0;
    let n = parseInt(t[3], 10);
    n = n >= 1 && n <= 31 ? n : 1;
    let r = parseInt(t[4], 10);
    r = r >= 0 && r <= 23 ? r : 0;
    let o = parseInt(t[5], 10);
    o = o >= 0 && o <= 59 ? o : 0;
    let l = parseInt(t[6], 10);
    l = l >= 0 && l <= 59 ? l : 0;
    const c = t[7] || "Z";
    let d = parseInt(t[8], 10);
    d = d >= 0 && d <= 23 ? d : 0;
    let u = parseInt(t[9], 10) || 0;
    return u = u >= 0 && u <= 59 ? u : 0, c === "-" ? (r += d, o += u) : c === "+" && (r -= d, o -= u), new Date(Date.UTC(s, i, n, r, o, l));
  }
}, wh = new WeakMap(), b(Of, wh), Of);
function SA(h, {
  scale: e = 1,
  rotation: t = 0
}) {
  const {
    width: s,
    height: i
  } = h.attributes.style, n = [0, 0, parseInt(s), parseInt(i)];
  return new Ed({
    viewBox: n,
    userUnit: 1,
    scale: e,
    rotation: t
  });
}
function Ng(h) {
  if (h.startsWith("#")) {
    const e = parseInt(h.slice(1), 16);
    return [(e & 16711680) >> 16, (e & 65280) >> 8, e & 255];
  }
  return h.startsWith("rgb(") ? h.slice(4, -1).split(",").map((e) => parseInt(e)) : h.startsWith("rgba(") ? h.slice(5, -1).split(",").map((e) => parseInt(e)).slice(0, 3) : (tt(`Not a valid color format: "${h}"`), [0, 0, 0]);
}
function xA(h) {
  const e = document.createElement("span");
  e.style.visibility = "hidden", document.body.append(e);
  for (const t of h.keys()) {
    e.style.color = t;
    const s = window.getComputedStyle(e).color;
    h.set(t, Ng(s));
  }
  e.remove();
}
function It(h) {
  const {
    a: e,
    b: t,
    c: s,
    d: i,
    e: n,
    f: r
  } = h.getTransform();
  return [e, t, s, i, n, r];
}
function zs(h) {
  const {
    a: e,
    b: t,
    c: s,
    d: i,
    e: n,
    f: r
  } = h.getTransform().invertSelf();
  return [e, t, s, i, n, r];
}
function Va(h, e, t = !1, s = !0) {
  if (e instanceof Ed) {
    const {
      pageWidth: i,
      pageHeight: n
    } = e.rawDims, {
      style: r
    } = h, o = Oe.isCSSRoundSupported, l = `var(--scale-factor) * ${i}px`, c = `var(--scale-factor) * ${n}px`, d = o ? `round(down, ${l}, var(--scale-round-x, 1px))` : `calc(${l})`, u = o ? `round(down, ${c}, var(--scale-round-y, 1px))` : `calc(${c})`;
    !t || e.rotation % 180 === 0 ? (r.width = d, r.height = u) : (r.width = u, r.height = d);
  }
  s && h.setAttribute("data-main-rotation", e.rotation);
}
let Bf = class {
  constructor() {
    const e = window.devicePixelRatio || 1;
    this.sx = e, this.sy = e;
  }
  get scaled() {
    return this.sx !== 1 || this.sy !== 1;
  }
  get symmetric() {
    return this.sx === this.sy;
  }
};
var mn, Er, Ts, Sr, Eh, Sh, Du, iv, Ne, nv, rv, jd, av, Hf;
const xi = class xi {
  constructor(e) {
    b(this, Ne);
    b(this, mn, null);
    b(this, Er, null);
    b(this, Ts);
    b(this, Sr, null);
    b(this, Eh, null);
    p(this, Ts, e), a(xi, Sh) || p(xi, Sh, Object.freeze({
      freetext: "pdfjs-editor-remove-freetext-button",
      highlight: "pdfjs-editor-remove-highlight-button",
      ink: "pdfjs-editor-remove-ink-button",
      stamp: "pdfjs-editor-remove-stamp-button"
    }));
  }
  render() {
    const e = p(this, mn, document.createElement("div"));
    e.classList.add("editToolbar", "hidden"), e.setAttribute("role", "toolbar");
    const t = a(this, Ts)._uiManager._signal;
    e.addEventListener("contextmenu", js, {
      signal: t
    }), e.addEventListener("pointerdown", v(xi, Du, iv), {
      signal: t
    });
    const s = p(this, Sr, document.createElement("div"));
    s.className = "buttons", e.append(s);
    const i = a(this, Ts).toolbarPosition;
    if (i) {
      const {
        style: n
      } = e, r = a(this, Ts)._uiManager.direction === "ltr" ? 1 - i[0] : i[0];
      n.insetInlineEnd = `${100 * r}%`, n.top = `calc(${100 * i[1]}% + var(--editor-toolbar-vert-offset))`;
    }
    return v(this, Ne, av).call(this), e;
  }
  get div() {
    return a(this, mn);
  }
  hide() {
    var e;
    a(this, mn).classList.add("hidden"), (e = a(this, Er)) == null || e.hideDropdown();
  }
  show() {
    var e;
    a(this, mn).classList.remove("hidden"), (e = a(this, Eh)) == null || e.shown();
  }
  async addAltText(e) {
    const t = await e.render();
    v(this, Ne, jd).call(this, t), a(this, Sr).prepend(t, a(this, Ne, Hf)), p(this, Eh, e);
  }
  addColorPicker(e) {
    p(this, Er, e);
    const t = e.renderButton();
    v(this, Ne, jd).call(this, t), a(this, Sr).prepend(t, a(this, Ne, Hf));
  }
  remove() {
    var e;
    a(this, mn).remove(), (e = a(this, Er)) == null || e.destroy(), p(this, Er, null);
  }
};
mn = new WeakMap(), Er = new WeakMap(), Ts = new WeakMap(), Sr = new WeakMap(), Eh = new WeakMap(), Sh = new WeakMap(), Du = new WeakSet(), iv = function(e) {
  e.stopPropagation();
}, Ne = new WeakSet(), nv = function(e) {
  a(this, Ts)._focusEventsAllowed = !1, os(e);
}, rv = function(e) {
  a(this, Ts)._focusEventsAllowed = !0, os(e);
}, jd = function(e) {
  const t = a(this, Ts)._uiManager._signal;
  e.addEventListener("focusin", v(this, Ne, nv).bind(this), {
    capture: !0,
    signal: t
  }), e.addEventListener("focusout", v(this, Ne, rv).bind(this), {
    capture: !0,
    signal: t
  }), e.addEventListener("contextmenu", js, {
    signal: t
  });
}, av = function() {
  const {
    editorType: e,
    _uiManager: t
  } = a(this, Ts), s = document.createElement("button");
  s.className = "delete", s.tabIndex = 0, s.setAttribute("data-l10n-id", a(xi, Sh)[e]), v(this, Ne, jd).call(this, s), s.addEventListener("click", (i) => {
    t.delete();
  }, {
    signal: t._signal
  }), a(this, Sr).append(s);
}, Hf = function() {
  const e = document.createElement("div");
  return e.className = "divider", e;
}, b(xi, Du), b(xi, Sh, null);
let jf = xi;
var xh, xr, Tr, ur, ov, lv, hv;
class TA {
  constructor(e) {
    b(this, ur);
    b(this, xh, null);
    b(this, xr, null);
    b(this, Tr);
    p(this, Tr, e);
  }
  show(e, t, s) {
    const [i, n] = v(this, ur, lv).call(this, t, s), {
      style: r
    } = a(this, xr) || p(this, xr, v(this, ur, ov).call(this));
    e.append(a(this, xr)), r.insetInlineEnd = `${100 * i}%`, r.top = `calc(${100 * n}% + var(--editor-toolbar-vert-offset))`;
  }
  hide() {
    a(this, xr).remove();
  }
}
xh = new WeakMap(), xr = new WeakMap(), Tr = new WeakMap(), ur = new WeakSet(), ov = function() {
  const e = p(this, xr, document.createElement("div"));
  e.className = "editToolbar", e.setAttribute("role", "toolbar"), e.addEventListener("contextmenu", js, {
    signal: a(this, Tr)._signal
  });
  const t = p(this, xh, document.createElement("div"));
  return t.className = "buttons", e.append(t), v(this, ur, hv).call(this), e;
}, lv = function(e, t) {
  let s = 0, i = 0;
  for (const n of e) {
    const r = n.y + n.height;
    if (r < s)
      continue;
    const o = n.x + (t ? n.width : 0);
    if (r > s) {
      i = o, s = r;
      continue;
    }
    t ? o > i && (i = o) : o < i && (i = o);
  }
  return [t ? 1 - i : i, s];
}, hv = function() {
  const e = document.createElement("button");
  e.className = "highlightButton", e.tabIndex = 0, e.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button1");
  const t = document.createElement("span");
  e.append(t), t.className = "visuallyHidden", t.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button-label");
  const s = a(this, Tr)._signal;
  e.addEventListener("contextmenu", js, {
    signal: s
  }), e.addEventListener("click", () => {
    a(this, Tr).highlightSelection("floating_button");
  }, {
    signal: s
  }), a(this, xh).append(e);
};
function Pu(h, e, t) {
  for (const s of t)
    e.addEventListener(s, h[s].bind(h));
}
var ku;
class PA {
  constructor() {
    b(this, ku, 0);
  }
  get id() {
    return `${aA}${me(this, ku)._++}`;
  }
}
ku = new WeakMap();
var ao, Th, ye, oo, Hd;
const Hg = class Hg {
  constructor() {
    b(this, oo);
    b(this, ao, yA());
    b(this, Th, 0);
    b(this, ye, null);
  }
  static get _isSVGFittingCanvas() {
    const e = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>', s = new OffscreenCanvas(1, 3).getContext("2d", {
      willReadFrequently: !0
    }), i = new Image();
    i.src = e;
    const n = i.decode().then(() => (s.drawImage(i, 0, 0, 1, 1, 0, 0, 1, 3), new Uint32Array(s.getImageData(0, 0, 1, 1).data.buffer)[0] === 0));
    return ht(this, "_isSVGFittingCanvas", n);
  }
  async getFromFile(e) {
    const {
      lastModified: t,
      name: s,
      size: i,
      type: n
    } = e;
    return v(this, oo, Hd).call(this, `${t}_${s}_${i}_${n}`, e);
  }
  async getFromUrl(e) {
    return v(this, oo, Hd).call(this, e, e);
  }
  async getFromBlob(e, t) {
    const s = await t;
    return v(this, oo, Hd).call(this, e, s);
  }
  async getFromId(e) {
    a(this, ye) || p(this, ye, /* @__PURE__ */ new Map());
    const t = a(this, ye).get(e);
    if (!t)
      return null;
    if (t.bitmap)
      return t.refCounter += 1, t;
    if (t.file)
      return this.getFromFile(t.file);
    if (t.blobPromise) {
      const {
        blobPromise: s
      } = t;
      return delete t.blobPromise, this.getFromBlob(t.id, s);
    }
    return this.getFromUrl(t.url);
  }
  getFromCanvas(e, t) {
    a(this, ye) || p(this, ye, /* @__PURE__ */ new Map());
    let s = a(this, ye).get(e);
    if (s != null && s.bitmap)
      return s.refCounter += 1, s;
    const i = new OffscreenCanvas(t.width, t.height);
    return i.getContext("2d").drawImage(t, 0, 0), s = {
      bitmap: i.transferToImageBitmap(),
      id: `image_${a(this, ao)}_${me(this, Th)._++}`,
      refCounter: 1,
      isSvg: !1
    }, a(this, ye).set(e, s), a(this, ye).set(s.id, s), s;
  }
  getSvgUrl(e) {
    const t = a(this, ye).get(e);
    return t != null && t.isSvg ? t.svgUrl : null;
  }
  deleteId(e) {
    var i;
    a(this, ye) || p(this, ye, /* @__PURE__ */ new Map());
    const t = a(this, ye).get(e);
    if (!t || (t.refCounter -= 1, t.refCounter !== 0))
      return;
    const {
      bitmap: s
    } = t;
    if (!t.url && !t.file) {
      const n = new OffscreenCanvas(s.width, s.height);
      n.getContext("bitmaprenderer").transferFromImageBitmap(s), t.blobPromise = n.convertToBlob();
    }
    (i = s.close) == null || i.call(s), t.bitmap = null;
  }
  isValidId(e) {
    return e.startsWith(`image_${a(this, ao)}_`);
  }
};
ao = new WeakMap(), Th = new WeakMap(), ye = new WeakMap(), oo = new WeakSet(), Hd = async function(e, t) {
  a(this, ye) || p(this, ye, /* @__PURE__ */ new Map());
  let s = a(this, ye).get(e);
  if (s === null)
    return null;
  if (s != null && s.bitmap)
    return s.refCounter += 1, s;
  try {
    s || (s = {
      bitmap: null,
      id: `image_${a(this, ao)}_${me(this, Th)._++}`,
      refCounter: 0,
      isSvg: !1
    });
    let i;
    if (typeof t == "string" ? (s.url = t, i = await lf(t, "blob")) : t instanceof File ? i = s.file = t : t instanceof Blob && (i = t), i.type === "image/svg+xml") {
      const n = Hg._isSVGFittingCanvas, r = new FileReader(), o = new Image(), l = new Promise((c, d) => {
        o.onload = () => {
          s.bitmap = o, s.isSvg = !0, c();
        }, r.onload = async () => {
          const u = s.svgUrl = r.result;
          o.src = await n ? `${u}#svgView(preserveAspectRatio(none))` : u;
        }, o.onerror = r.onerror = d;
      });
      r.readAsDataURL(i), await l;
    } else
      s.bitmap = await createImageBitmap(i);
    s.refCounter = 1;
  } catch (i) {
    tt(i), s = null;
  }
  return a(this, ye).set(e, s), s && a(this, ye).set(s.id, s), s;
};
let $f = Hg;
var $t, vn, Ph, Lt;
class CA {
  constructor(e = 128) {
    b(this, $t, []);
    b(this, vn, !1);
    b(this, Ph);
    b(this, Lt, -1);
    p(this, Ph, e);
  }
  add({
    cmd: e,
    undo: t,
    post: s,
    mustExec: i,
    type: n = NaN,
    overwriteIfSameType: r = !1,
    keepUndo: o = !1
  }) {
    if (i && e(), a(this, vn))
      return;
    const l = {
      cmd: e,
      undo: t,
      post: s,
      type: n
    };
    if (a(this, Lt) === -1) {
      a(this, $t).length > 0 && (a(this, $t).length = 0), p(this, Lt, 0), a(this, $t).push(l);
      return;
    }
    if (r && a(this, $t)[a(this, Lt)].type === n) {
      o && (l.undo = a(this, $t)[a(this, Lt)].undo), a(this, $t)[a(this, Lt)] = l;
      return;
    }
    const c = a(this, Lt) + 1;
    c === a(this, Ph) ? a(this, $t).splice(0, 1) : (p(this, Lt, c), c < a(this, $t).length && a(this, $t).splice(c)), a(this, $t).push(l);
  }
  undo() {
    if (a(this, Lt) === -1)
      return;
    p(this, vn, !0);
    const {
      undo: e,
      post: t
    } = a(this, $t)[a(this, Lt)];
    e(), t == null || t(), p(this, vn, !1), p(this, Lt, a(this, Lt) - 1);
  }
  redo() {
    if (a(this, Lt) < a(this, $t).length - 1) {
      p(this, Lt, a(this, Lt) + 1), p(this, vn, !0);
      const {
        cmd: e,
        post: t
      } = a(this, $t)[a(this, Lt)];
      e(), t == null || t(), p(this, vn, !1);
    }
  }
  hasSomethingToUndo() {
    return a(this, Lt) !== -1;
  }
  hasSomethingToRedo() {
    return a(this, Lt) < a(this, $t).length - 1;
  }
  cleanType(e) {
    if (a(this, Lt) !== -1) {
      for (let t = a(this, Lt); t >= 0; t--)
        if (a(this, $t)[t].type !== e) {
          a(this, $t).splice(t + 1, a(this, Lt) - t), p(this, Lt, t);
          return;
        }
      a(this, $t).length = 0, p(this, Lt, -1);
    }
  }
  destroy() {
    p(this, $t, null);
  }
}
$t = new WeakMap(), vn = new WeakMap(), Ph = new WeakMap(), Lt = new WeakMap();
var Fu, cv;
class Sd {
  constructor(e) {
    b(this, Fu);
    this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
    const {
      isMac: t
    } = Oe.platform;
    for (const [s, i, n = {}] of e)
      for (const r of s) {
        const o = r.startsWith("mac+");
        t && o ? (this.callbacks.set(r.slice(4), {
          callback: i,
          options: n
        }), this.allKeys.add(r.split("+").at(-1))) : !t && !o && (this.callbacks.set(r, {
          callback: i,
          options: n
        }), this.allKeys.add(r.split("+").at(-1)));
      }
  }
  exec(e, t) {
    if (!this.allKeys.has(t.key))
      return;
    const s = this.callbacks.get(v(this, Fu, cv).call(this, t));
    if (!s)
      return;
    const {
      callback: i,
      options: {
        bubbles: n = !1,
        args: r = [],
        checker: o = null
      }
    } = s;
    o && !o(e, t) || (i.bind(e, ...r, t)(), n || os(t));
  }
}
Fu = new WeakSet(), cv = function(e) {
  e.altKey && this.buffer.push("alt"), e.ctrlKey && this.buffer.push("ctrl"), e.metaKey && this.buffer.push("meta"), e.shiftKey && this.buffer.push("shift"), this.buffer.push(e.key);
  const t = this.buffer.join("+");
  return this.buffer.length = 0, t;
};
const Bu = class Bu {
  get _colors() {
    const e = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
    return xA(e), ht(this, "_colors", e);
  }
  convert(e) {
    const t = Ng(e);
    if (!window.matchMedia("(forced-colors: active)").matches)
      return t;
    for (const [s, i] of this._colors)
      if (i.every((n, r) => n === t[r]))
        return Bu._colorsMapping.get(s);
    return t;
  }
  getHexCode(e) {
    const t = this._colors.get(e);
    return t ? X.makeHexColor(...t) : e;
  }
};
K(Bu, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
let Vf = Bu;
var lo, Ge, Kt, he, ho, Ci, co, ds, bn, Pr, uo, Cr, Ys, Ps, Rr, Ch, Rh, fo, Ih, Ks, yn, po, An, Qs, ju, wn, _h, En, Ir, Lh, Mh, ee, vt, Ri, _r, Oh, Nh, Sn, Zs, Ii, Dh, us, rn, B, $d, Uf, dv, uv, Vd, fv, pv, gv, zf, mv, Wf, Gf, vv, Ce, wi, bv, yv, Xf, Av, zl, Yf;
let vh = (rn = class {
  constructor(e, t, s, i, n, r, o, l, c, d, u, f, g) {
    b(this, B);
    b(this, lo, new AbortController());
    b(this, Ge, null);
    b(this, Kt, /* @__PURE__ */ new Map());
    b(this, he, /* @__PURE__ */ new Map());
    b(this, ho, null);
    b(this, Ci, null);
    b(this, co, null);
    b(this, ds, new CA());
    b(this, bn, null);
    b(this, Pr, null);
    b(this, uo, 0);
    b(this, Cr, /* @__PURE__ */ new Set());
    b(this, Ys, null);
    b(this, Ps, null);
    b(this, Rr, /* @__PURE__ */ new Set());
    K(this, "_editorUndoBar", null);
    b(this, Ch, !1);
    b(this, Rh, !1);
    b(this, fo, !1);
    b(this, Ih, null);
    b(this, Ks, null);
    b(this, yn, null);
    b(this, po, null);
    b(this, An, !1);
    b(this, Qs, null);
    b(this, ju, new PA());
    b(this, wn, !1);
    b(this, _h, !1);
    b(this, En, null);
    b(this, Ir, null);
    b(this, Lh, null);
    b(this, Mh, null);
    b(this, ee, at.NONE);
    b(this, vt, /* @__PURE__ */ new Set());
    b(this, Ri, null);
    b(this, _r, null);
    b(this, Oh, null);
    b(this, Nh, {
      isEditing: !1,
      isEmpty: !0,
      hasSomethingToUndo: !1,
      hasSomethingToRedo: !1,
      hasSelectedEditor: !1,
      hasSelectedText: !1
    });
    b(this, Sn, [0, 0]);
    b(this, Zs, null);
    b(this, Ii, null);
    b(this, Dh, null);
    b(this, us, null);
    const m = this._signal = a(this, lo).signal;
    p(this, Ii, e), p(this, Dh, t), p(this, ho, s), this._eventBus = i, i._on("editingaction", this.onEditingAction.bind(this), {
      signal: m
    }), i._on("pagechanging", this.onPageChanging.bind(this), {
      signal: m
    }), i._on("scalechanging", this.onScaleChanging.bind(this), {
      signal: m
    }), i._on("rotationchanging", this.onRotationChanging.bind(this), {
      signal: m
    }), i._on("setpreference", this.onSetPreference.bind(this), {
      signal: m
    }), i._on("switchannotationeditorparams", (y) => this.updateParams(y.type, y.value), {
      signal: m
    }), v(this, B, fv).call(this), v(this, B, vv).call(this), v(this, B, zf).call(this), p(this, Ci, n.annotationStorage), p(this, Ih, n.filterFactory), p(this, _r, r), p(this, po, o || null), p(this, Ch, l), p(this, Rh, c), p(this, fo, d), p(this, Mh, u || null), this.viewParameters = {
      realScale: Ll.PDF_TO_CSS_UNITS,
      rotation: 0
    }, this.isShiftKeyDown = !1, this._editorUndoBar = f || null, this._supportsPinchToZoom = g !== !1;
  }
  static get _keyboardManager() {
    const e = rn.prototype, t = (r) => a(r, Ii).contains(document.activeElement) && document.activeElement.tagName !== "BUTTON" && r.hasSomethingToControl(), s = (r, {
      target: o
    }) => {
      if (o instanceof HTMLInputElement) {
        const {
          type: l
        } = o;
        return l !== "text" && l !== "number";
      }
      return !0;
    }, i = this.TRANSLATE_SMALL, n = this.TRANSLATE_BIG;
    return ht(this, "_keyboardManager", new Sd([[["ctrl+a", "mac+meta+a"], e.selectAll, {
      checker: s
    }], [["ctrl+z", "mac+meta+z"], e.undo, {
      checker: s
    }], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], e.redo, {
      checker: s
    }], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], e.delete, {
      checker: s
    }], [["Enter", "mac+Enter"], e.addNewEditorFromKeyboard, {
      checker: (r, {
        target: o
      }) => !(o instanceof HTMLButtonElement) && a(r, Ii).contains(o) && !r.isEnterHandled
    }], [[" ", "mac+ "], e.addNewEditorFromKeyboard, {
      checker: (r, {
        target: o
      }) => !(o instanceof HTMLButtonElement) && a(r, Ii).contains(document.activeElement)
    }], [["Escape", "mac+Escape"], e.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], e.translateSelectedEditors, {
      args: [-i, 0],
      checker: t
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], e.translateSelectedEditors, {
      args: [-n, 0],
      checker: t
    }], [["ArrowRight", "mac+ArrowRight"], e.translateSelectedEditors, {
      args: [i, 0],
      checker: t
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], e.translateSelectedEditors, {
      args: [n, 0],
      checker: t
    }], [["ArrowUp", "mac+ArrowUp"], e.translateSelectedEditors, {
      args: [0, -i],
      checker: t
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], e.translateSelectedEditors, {
      args: [0, -n],
      checker: t
    }], [["ArrowDown", "mac+ArrowDown"], e.translateSelectedEditors, {
      args: [0, i],
      checker: t
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], e.translateSelectedEditors, {
      args: [0, n],
      checker: t
    }]]));
  }
  destroy() {
    var e, t, s, i, n;
    (e = a(this, us)) == null || e.resolve(), p(this, us, null), (t = a(this, lo)) == null || t.abort(), p(this, lo, null), this._signal = null;
    for (const r of a(this, he).values())
      r.destroy();
    a(this, he).clear(), a(this, Kt).clear(), a(this, Rr).clear(), p(this, Ge, null), a(this, vt).clear(), a(this, ds).destroy(), (s = a(this, ho)) == null || s.destroy(), (i = a(this, Qs)) == null || i.hide(), p(this, Qs, null), a(this, Ks) && (clearTimeout(a(this, Ks)), p(this, Ks, null)), a(this, Zs) && (clearTimeout(a(this, Zs)), p(this, Zs, null)), (n = this._editorUndoBar) == null || n.destroy();
  }
  combinedSignal(e) {
    return AbortSignal.any([this._signal, e.signal]);
  }
  get mlManager() {
    return a(this, Mh);
  }
  get useNewAltTextFlow() {
    return a(this, Rh);
  }
  get useNewAltTextWhenAddingImage() {
    return a(this, fo);
  }
  get hcmFilter() {
    return ht(this, "hcmFilter", a(this, _r) ? a(this, Ih).addHCMFilter(a(this, _r).foreground, a(this, _r).background) : "none");
  }
  get direction() {
    return ht(this, "direction", getComputedStyle(a(this, Ii)).direction);
  }
  get highlightColors() {
    return ht(this, "highlightColors", a(this, po) ? new Map(a(this, po).split(",").map((e) => e.split("=").map((t) => t.trim()))) : null);
  }
  get highlightColorNames() {
    return ht(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, (e) => e.reverse())) : null);
  }
  setCurrentDrawingSession(e) {
    e ? (this.unselectAll(), this.disableUserSelect(!0)) : this.disableUserSelect(!1), p(this, Pr, e);
  }
  setMainHighlightColorPicker(e) {
    p(this, Lh, e);
  }
  editAltText(e, t = !1) {
    var s;
    (s = a(this, ho)) == null || s.editAltText(this, e, t);
  }
  switchToMode(e, t) {
    this._eventBus.on("annotationeditormodechanged", t, {
      once: !0,
      signal: this._signal
    }), this._eventBus.dispatch("showannotationeditorui", {
      source: this,
      mode: e
    });
  }
  setPreference(e, t) {
    this._eventBus.dispatch("setpreference", {
      source: this,
      name: e,
      value: t
    });
  }
  onSetPreference({
    name: e,
    value: t
  }) {
    switch (e) {
      case "enableNewAltTextWhenAddingImage":
        p(this, fo, t);
        break;
    }
  }
  onPageChanging({
    pageNumber: e
  }) {
    p(this, uo, e - 1);
  }
  focusMainContainer() {
    a(this, Ii).focus();
  }
  findParent(e, t) {
    for (const s of a(this, he).values()) {
      const {
        x: i,
        y: n,
        width: r,
        height: o
      } = s.div.getBoundingClientRect();
      if (e >= i && e <= i + r && t >= n && t <= n + o)
        return s;
    }
    return null;
  }
  disableUserSelect(e = !1) {
    a(this, Dh).classList.toggle("noUserSelect", e);
  }
  addShouldRescale(e) {
    a(this, Rr).add(e);
  }
  removeShouldRescale(e) {
    a(this, Rr).delete(e);
  }
  onScaleChanging({
    scale: e
  }) {
    var t;
    this.commitOrRemove(), this.viewParameters.realScale = e * Ll.PDF_TO_CSS_UNITS;
    for (const s of a(this, Rr))
      s.onScaleChanging();
    (t = a(this, Pr)) == null || t.onScaleChanging();
  }
  onRotationChanging({
    pagesRotation: e
  }) {
    this.commitOrRemove(), this.viewParameters.rotation = e;
  }
  highlightSelection(e = "") {
    const t = document.getSelection();
    if (!t || t.isCollapsed)
      return;
    const {
      anchorNode: s,
      anchorOffset: i,
      focusNode: n,
      focusOffset: r
    } = t, o = t.toString(), c = v(this, B, $d).call(this, t).closest(".textLayer"), d = this.getSelectionBoxes(c);
    if (!d)
      return;
    t.empty();
    const u = v(this, B, Uf).call(this, c), f = a(this, ee) === at.NONE, g = () => {
      u == null || u.createAndAddNewEditor({
        x: 0,
        y: 0
      }, !1, {
        methodOfCreation: e,
        boxes: d,
        anchorNode: s,
        anchorOffset: i,
        focusNode: n,
        focusOffset: r,
        text: o
      }), f && this.showAllEditors("highlight", !0, !0);
    };
    if (f) {
      this.switchToMode(at.HIGHLIGHT, g);
      return;
    }
    g();
  }
  addToAnnotationStorage(e) {
    !e.isEmpty() && a(this, Ci) && !a(this, Ci).has(e.id) && a(this, Ci).setValue(e.id, e);
  }
  blur() {
    if (this.isShiftKeyDown = !1, a(this, An) && (p(this, An, !1), v(this, B, Vd).call(this, "main_toolbar")), !this.hasSelection)
      return;
    const {
      activeElement: e
    } = document;
    for (const t of a(this, vt))
      if (t.div.contains(e)) {
        p(this, Ir, [t, e]), t._focusEventsAllowed = !1;
        break;
      }
  }
  focus() {
    if (!a(this, Ir))
      return;
    const [e, t] = a(this, Ir);
    p(this, Ir, null), t.addEventListener("focusin", () => {
      e._focusEventsAllowed = !0;
    }, {
      once: !0,
      signal: this._signal
    }), t.focus();
  }
  addEditListeners() {
    v(this, B, zf).call(this), v(this, B, Wf).call(this);
  }
  removeEditListeners() {
    v(this, B, mv).call(this), v(this, B, Gf).call(this);
  }
  dragOver(e) {
    for (const {
      type: t
    } of e.dataTransfer.items)
      for (const s of a(this, Ps))
        if (s.isHandlingMimeForPasting(t)) {
          e.dataTransfer.dropEffect = "copy", e.preventDefault();
          return;
        }
  }
  drop(e) {
    for (const t of e.dataTransfer.items)
      for (const s of a(this, Ps))
        if (s.isHandlingMimeForPasting(t.type)) {
          s.paste(t, this.currentLayer), e.preventDefault();
          return;
        }
  }
  copy(e) {
    var s;
    if (e.preventDefault(), (s = a(this, Ge)) == null || s.commitOrRemove(), !this.hasSelection)
      return;
    const t = [];
    for (const i of a(this, vt)) {
      const n = i.serialize(!0);
      n && t.push(n);
    }
    t.length !== 0 && e.clipboardData.setData("application/pdfjs", JSON.stringify(t));
  }
  cut(e) {
    this.copy(e), this.delete();
  }
  async paste(e) {
    e.preventDefault();
    const {
      clipboardData: t
    } = e;
    for (const n of t.items)
      for (const r of a(this, Ps))
        if (r.isHandlingMimeForPasting(n.type)) {
          r.paste(n, this.currentLayer);
          return;
        }
    let s = t.getData("application/pdfjs");
    if (!s)
      return;
    try {
      s = JSON.parse(s);
    } catch (n) {
      tt(`paste: "${n.message}".`);
      return;
    }
    if (!Array.isArray(s))
      return;
    this.unselectAll();
    const i = this.currentLayer;
    try {
      const n = [];
      for (const l of s) {
        const c = await i.deserialize(l);
        if (!c)
          return;
        n.push(c);
      }
      const r = () => {
        for (const l of n)
          v(this, B, Xf).call(this, l);
        v(this, B, Yf).call(this, n);
      }, o = () => {
        for (const l of n)
          l.remove();
      };
      this.addCommands({
        cmd: r,
        undo: o,
        mustExec: !0
      });
    } catch (n) {
      tt(`paste: "${n.message}".`);
    }
  }
  keydown(e) {
    !this.isShiftKeyDown && e.key === "Shift" && (this.isShiftKeyDown = !0), a(this, ee) !== at.NONE && !this.isEditorHandlingKeyboard && rn._keyboardManager.exec(this, e);
  }
  keyup(e) {
    this.isShiftKeyDown && e.key === "Shift" && (this.isShiftKeyDown = !1, a(this, An) && (p(this, An, !1), v(this, B, Vd).call(this, "main_toolbar")));
  }
  onEditingAction({
    name: e
  }) {
    switch (e) {
      case "undo":
      case "redo":
      case "delete":
      case "selectAll":
        this[e]();
        break;
      case "highlightSelection":
        this.highlightSelection("context_menu");
        break;
    }
  }
  setEditingState(e) {
    e ? (v(this, B, pv).call(this), v(this, B, Wf).call(this), v(this, B, Ce).call(this, {
      isEditing: a(this, ee) !== at.NONE,
      isEmpty: v(this, B, zl).call(this),
      hasSomethingToUndo: a(this, ds).hasSomethingToUndo(),
      hasSomethingToRedo: a(this, ds).hasSomethingToRedo(),
      hasSelectedEditor: !1
    })) : (v(this, B, gv).call(this), v(this, B, Gf).call(this), v(this, B, Ce).call(this, {
      isEditing: !1
    }), this.disableUserSelect(!1));
  }
  registerEditorTypes(e) {
    if (!a(this, Ps)) {
      p(this, Ps, e);
      for (const t of a(this, Ps))
        v(this, B, wi).call(this, t.defaultPropertiesToUpdate);
    }
  }
  getId() {
    return a(this, ju).id;
  }
  get currentLayer() {
    return a(this, he).get(a(this, uo));
  }
  getLayer(e) {
    return a(this, he).get(e);
  }
  get currentPageIndex() {
    return a(this, uo);
  }
  addLayer(e) {
    a(this, he).set(e.pageIndex, e), a(this, wn) ? e.enable() : e.disable();
  }
  removeLayer(e) {
    a(this, he).delete(e.pageIndex);
  }
  async updateMode(e, t = null, s = !1) {
    var i;
    if (a(this, ee) !== e && !(a(this, us) && (await a(this, us).promise, !a(this, us)))) {
      if (p(this, us, Promise.withResolvers()), p(this, ee, e), e === at.NONE) {
        this.setEditingState(!1), v(this, B, yv).call(this), (i = this._editorUndoBar) == null || i.hide(), a(this, us).resolve();
        return;
      }
      this.setEditingState(!0), await v(this, B, bv).call(this), this.unselectAll();
      for (const n of a(this, he).values())
        n.updateMode(e);
      if (!t) {
        s && this.addNewEditorFromKeyboard(), a(this, us).resolve();
        return;
      }
      for (const n of a(this, Kt).values())
        n.annotationElementId === t ? (this.setSelected(n), n.enterInEditMode()) : n.unselect();
      a(this, us).resolve();
    }
  }
  addNewEditorFromKeyboard() {
    this.currentLayer.canCreateNewEmptyEditor() && this.currentLayer.addNewEditor();
  }
  updateToolbar(e) {
    e !== a(this, ee) && this._eventBus.dispatch("switchannotationeditormode", {
      source: this,
      mode: e
    });
  }
  updateParams(e, t) {
    var s;
    if (a(this, Ps)) {
      switch (e) {
        case ct.CREATE:
          this.currentLayer.addNewEditor();
          return;
        case ct.HIGHLIGHT_DEFAULT_COLOR:
          (s = a(this, Lh)) == null || s.updateColor(t);
          break;
        case ct.HIGHLIGHT_SHOW_ALL:
          this._eventBus.dispatch("reporttelemetry", {
            source: this,
            details: {
              type: "editing",
              data: {
                type: "highlight",
                action: "toggle_visibility"
              }
            }
          }), (a(this, Oh) || p(this, Oh, /* @__PURE__ */ new Map())).set(e, t), this.showAllEditors("highlight", t);
          break;
      }
      for (const i of a(this, vt))
        i.updateParams(e, t);
      for (const i of a(this, Ps))
        i.updateDefaultParams(e, t);
    }
  }
  showAllEditors(e, t, s = !1) {
    var n;
    for (const r of a(this, Kt).values())
      r.editorType === e && r.show(t);
    (((n = a(this, Oh)) == null ? void 0 : n.get(ct.HIGHLIGHT_SHOW_ALL)) ?? !0) !== t && v(this, B, wi).call(this, [[ct.HIGHLIGHT_SHOW_ALL, t]]);
  }
  enableWaiting(e = !1) {
    if (a(this, _h) !== e) {
      p(this, _h, e);
      for (const t of a(this, he).values())
        e ? t.disableClick() : t.enableClick(), t.div.classList.toggle("waiting", e);
    }
  }
  getEditors(e) {
    const t = [];
    for (const s of a(this, Kt).values())
      s.pageIndex === e && t.push(s);
    return t;
  }
  getEditor(e) {
    return a(this, Kt).get(e);
  }
  addEditor(e) {
    a(this, Kt).set(e.id, e);
  }
  removeEditor(e) {
    var t;
    e.div.contains(document.activeElement) && (a(this, Ks) && clearTimeout(a(this, Ks)), p(this, Ks, setTimeout(() => {
      this.focusMainContainer(), p(this, Ks, null);
    }, 0))), a(this, Kt).delete(e.id), this.unselect(e), (!e.annotationElementId || !a(this, Cr).has(e.annotationElementId)) && ((t = a(this, Ci)) == null || t.remove(e.id));
  }
  addDeletedAnnotationElement(e) {
    a(this, Cr).add(e.annotationElementId), this.addChangedExistingAnnotation(e), e.deleted = !0;
  }
  isDeletedAnnotationElement(e) {
    return a(this, Cr).has(e);
  }
  removeDeletedAnnotationElement(e) {
    a(this, Cr).delete(e.annotationElementId), this.removeChangedExistingAnnotation(e), e.deleted = !1;
  }
  setActiveEditor(e) {
    a(this, Ge) !== e && (p(this, Ge, e), e && v(this, B, wi).call(this, e.propertiesToUpdate));
  }
  updateUI(e) {
    a(this, B, Av) === e && v(this, B, wi).call(this, e.propertiesToUpdate);
  }
  updateUIForDefaultProperties(e) {
    v(this, B, wi).call(this, e.defaultPropertiesToUpdate);
  }
  toggleSelected(e) {
    if (a(this, vt).has(e)) {
      a(this, vt).delete(e), e.unselect(), v(this, B, Ce).call(this, {
        hasSelectedEditor: this.hasSelection
      });
      return;
    }
    a(this, vt).add(e), e.select(), v(this, B, wi).call(this, e.propertiesToUpdate), v(this, B, Ce).call(this, {
      hasSelectedEditor: !0
    });
  }
  setSelected(e) {
    var t;
    (t = a(this, Pr)) == null || t.commitOrRemove();
    for (const s of a(this, vt))
      s !== e && s.unselect();
    a(this, vt).clear(), a(this, vt).add(e), e.select(), v(this, B, wi).call(this, e.propertiesToUpdate), v(this, B, Ce).call(this, {
      hasSelectedEditor: !0
    });
  }
  isSelected(e) {
    return a(this, vt).has(e);
  }
  get firstSelectedEditor() {
    return a(this, vt).values().next().value;
  }
  unselect(e) {
    e.unselect(), a(this, vt).delete(e), v(this, B, Ce).call(this, {
      hasSelectedEditor: this.hasSelection
    });
  }
  get hasSelection() {
    return a(this, vt).size !== 0;
  }
  get isEnterHandled() {
    return a(this, vt).size === 1 && this.firstSelectedEditor.isEnterHandled;
  }
  undo() {
    var e;
    a(this, ds).undo(), v(this, B, Ce).call(this, {
      hasSomethingToUndo: a(this, ds).hasSomethingToUndo(),
      hasSomethingToRedo: !0,
      isEmpty: v(this, B, zl).call(this)
    }), (e = this._editorUndoBar) == null || e.hide();
  }
  redo() {
    a(this, ds).redo(), v(this, B, Ce).call(this, {
      hasSomethingToUndo: !0,
      hasSomethingToRedo: a(this, ds).hasSomethingToRedo(),
      isEmpty: v(this, B, zl).call(this)
    });
  }
  addCommands(e) {
    a(this, ds).add(e), v(this, B, Ce).call(this, {
      hasSomethingToUndo: !0,
      hasSomethingToRedo: !1,
      isEmpty: v(this, B, zl).call(this)
    });
  }
  cleanUndoStack(e) {
    a(this, ds).cleanType(e);
  }
  delete() {
    var n;
    this.commitOrRemove();
    const e = (n = this.currentLayer) == null ? void 0 : n.endDrawingSession(!0);
    if (!this.hasSelection && !e)
      return;
    const t = e ? [e] : [...a(this, vt)], s = () => {
      var r;
      (r = this._editorUndoBar) == null || r.show(i, t.length === 1 ? t[0].editorType : t.length);
      for (const o of t)
        o.remove();
    }, i = () => {
      for (const r of t)
        v(this, B, Xf).call(this, r);
    };
    this.addCommands({
      cmd: s,
      undo: i,
      mustExec: !0
    });
  }
  commitOrRemove() {
    var e;
    (e = a(this, Ge)) == null || e.commitOrRemove();
  }
  hasSomethingToControl() {
    return a(this, Ge) || this.hasSelection;
  }
  selectAll() {
    for (const e of a(this, vt))
      e.commit();
    v(this, B, Yf).call(this, a(this, Kt).values());
  }
  unselectAll() {
    var e;
    if (!(a(this, Ge) && (a(this, Ge).commitOrRemove(), a(this, ee) !== at.NONE)) && !((e = a(this, Pr)) != null && e.commitOrRemove()) && this.hasSelection) {
      for (const t of a(this, vt))
        t.unselect();
      a(this, vt).clear(), v(this, B, Ce).call(this, {
        hasSelectedEditor: !1
      });
    }
  }
  translateSelectedEditors(e, t, s = !1) {
    if (s || this.commitOrRemove(), !this.hasSelection)
      return;
    a(this, Sn)[0] += e, a(this, Sn)[1] += t;
    const [i, n] = a(this, Sn), r = [...a(this, vt)], o = 1e3;
    a(this, Zs) && clearTimeout(a(this, Zs)), p(this, Zs, setTimeout(() => {
      p(this, Zs, null), a(this, Sn)[0] = a(this, Sn)[1] = 0, this.addCommands({
        cmd: () => {
          for (const l of r)
            a(this, Kt).has(l.id) && l.translateInPage(i, n);
        },
        undo: () => {
          for (const l of r)
            a(this, Kt).has(l.id) && l.translateInPage(-i, -n);
        },
        mustExec: !1
      });
    }, o));
    for (const l of r)
      l.translateInPage(e, t);
  }
  setUpDragSession() {
    if (this.hasSelection) {
      this.disableUserSelect(!0), p(this, Ys, /* @__PURE__ */ new Map());
      for (const e of a(this, vt))
        a(this, Ys).set(e, {
          savedX: e.x,
          savedY: e.y,
          savedPageIndex: e.pageIndex,
          newX: 0,
          newY: 0,
          newPageIndex: -1
        });
    }
  }
  endDragSession() {
    if (!a(this, Ys))
      return !1;
    this.disableUserSelect(!1);
    const e = a(this, Ys);
    p(this, Ys, null);
    let t = !1;
    for (const [{
      x: i,
      y: n,
      pageIndex: r
    }, o] of e)
      o.newX = i, o.newY = n, o.newPageIndex = r, t || (t = i !== o.savedX || n !== o.savedY || r !== o.savedPageIndex);
    if (!t)
      return !1;
    const s = (i, n, r, o) => {
      if (a(this, Kt).has(i.id)) {
        const l = a(this, he).get(o);
        l ? i._setParentAndPosition(l, n, r) : (i.pageIndex = o, i.x = n, i.y = r);
      }
    };
    return this.addCommands({
      cmd: () => {
        for (const [i, {
          newX: n,
          newY: r,
          newPageIndex: o
        }] of e)
          s(i, n, r, o);
      },
      undo: () => {
        for (const [i, {
          savedX: n,
          savedY: r,
          savedPageIndex: o
        }] of e)
          s(i, n, r, o);
      },
      mustExec: !0
    }), !0;
  }
  dragSelectedEditors(e, t) {
    if (a(this, Ys))
      for (const s of a(this, Ys).keys())
        s.drag(e, t);
  }
  rebuild(e) {
    if (e.parent === null) {
      const t = this.getLayer(e.pageIndex);
      t ? (t.changeParent(e), t.addOrRebuild(e)) : (this.addEditor(e), this.addToAnnotationStorage(e), e.rebuild());
    } else
      e.parent.addOrRebuild(e);
  }
  get isEditorHandlingKeyboard() {
    var e;
    return ((e = this.getActive()) == null ? void 0 : e.shouldGetKeyboardEvents()) || a(this, vt).size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();
  }
  isActive(e) {
    return a(this, Ge) === e;
  }
  getActive() {
    return a(this, Ge);
  }
  getMode() {
    return a(this, ee);
  }
  get imageManager() {
    return ht(this, "imageManager", new $f());
  }
  getSelectionBoxes(e) {
    if (!e)
      return null;
    const t = document.getSelection();
    for (let c = 0, d = t.rangeCount; c < d; c++)
      if (!e.contains(t.getRangeAt(c).commonAncestorContainer))
        return null;
    const {
      x: s,
      y: i,
      width: n,
      height: r
    } = e.getBoundingClientRect();
    let o;
    switch (e.getAttribute("data-main-rotation")) {
      case "90":
        o = (c, d, u, f) => ({
          x: (d - i) / r,
          y: 1 - (c + u - s) / n,
          width: f / r,
          height: u / n
        });
        break;
      case "180":
        o = (c, d, u, f) => ({
          x: 1 - (c + u - s) / n,
          y: 1 - (d + f - i) / r,
          width: u / n,
          height: f / r
        });
        break;
      case "270":
        o = (c, d, u, f) => ({
          x: 1 - (d + f - i) / r,
          y: (c - s) / n,
          width: f / r,
          height: u / n
        });
        break;
      default:
        o = (c, d, u, f) => ({
          x: (c - s) / n,
          y: (d - i) / r,
          width: u / n,
          height: f / r
        });
        break;
    }
    const l = [];
    for (let c = 0, d = t.rangeCount; c < d; c++) {
      const u = t.getRangeAt(c);
      if (!u.collapsed)
        for (const {
          x: f,
          y: g,
          width: m,
          height: y
        } of u.getClientRects())
          m === 0 || y === 0 || l.push(o(f, g, m, y));
    }
    return l.length === 0 ? null : l;
  }
  addChangedExistingAnnotation({
    annotationElementId: e,
    id: t
  }) {
    (a(this, co) || p(this, co, /* @__PURE__ */ new Map())).set(e, t);
  }
  removeChangedExistingAnnotation({
    annotationElementId: e
  }) {
    var t;
    (t = a(this, co)) == null || t.delete(e);
  }
  renderAnnotationElement(e) {
    var i;
    const t = (i = a(this, co)) == null ? void 0 : i.get(e.data.id);
    if (!t)
      return;
    const s = a(this, Ci).getRawValue(t);
    s && (a(this, ee) === at.NONE && !s.hasBeenModified || s.renderAnnotationElement(e));
  }
}, lo = new WeakMap(), Ge = new WeakMap(), Kt = new WeakMap(), he = new WeakMap(), ho = new WeakMap(), Ci = new WeakMap(), co = new WeakMap(), ds = new WeakMap(), bn = new WeakMap(), Pr = new WeakMap(), uo = new WeakMap(), Cr = new WeakMap(), Ys = new WeakMap(), Ps = new WeakMap(), Rr = new WeakMap(), Ch = new WeakMap(), Rh = new WeakMap(), fo = new WeakMap(), Ih = new WeakMap(), Ks = new WeakMap(), yn = new WeakMap(), po = new WeakMap(), An = new WeakMap(), Qs = new WeakMap(), ju = new WeakMap(), wn = new WeakMap(), _h = new WeakMap(), En = new WeakMap(), Ir = new WeakMap(), Lh = new WeakMap(), Mh = new WeakMap(), ee = new WeakMap(), vt = new WeakMap(), Ri = new WeakMap(), _r = new WeakMap(), Oh = new WeakMap(), Nh = new WeakMap(), Sn = new WeakMap(), Zs = new WeakMap(), Ii = new WeakMap(), Dh = new WeakMap(), us = new WeakMap(), B = new WeakSet(), $d = function({
  anchorNode: e
}) {
  return e.nodeType === Node.TEXT_NODE ? e.parentElement : e;
}, Uf = function(e) {
  const {
    currentLayer: t
  } = this;
  if (t.hasTextLayer(e))
    return t;
  for (const s of a(this, he).values())
    if (s.hasTextLayer(e))
      return s;
  return null;
}, dv = function() {
  const e = document.getSelection();
  if (!e || e.isCollapsed)
    return;
  const s = v(this, B, $d).call(this, e).closest(".textLayer"), i = this.getSelectionBoxes(s);
  i && (a(this, Qs) || p(this, Qs, new TA(this)), a(this, Qs).show(s, i, this.direction === "ltr"));
}, uv = function() {
  var n, r, o;
  const e = document.getSelection();
  if (!e || e.isCollapsed) {
    a(this, Ri) && ((n = a(this, Qs)) == null || n.hide(), p(this, Ri, null), v(this, B, Ce).call(this, {
      hasSelectedText: !1
    }));
    return;
  }
  const {
    anchorNode: t
  } = e;
  if (t === a(this, Ri))
    return;
  const i = v(this, B, $d).call(this, e).closest(".textLayer");
  if (!i) {
    a(this, Ri) && ((r = a(this, Qs)) == null || r.hide(), p(this, Ri, null), v(this, B, Ce).call(this, {
      hasSelectedText: !1
    }));
    return;
  }
  if ((o = a(this, Qs)) == null || o.hide(), p(this, Ri, t), v(this, B, Ce).call(this, {
    hasSelectedText: !0
  }), !(a(this, ee) !== at.HIGHLIGHT && a(this, ee) !== at.NONE) && (a(this, ee) === at.HIGHLIGHT && this.showAllEditors("highlight", !0, !0), p(this, An, this.isShiftKeyDown), !this.isShiftKeyDown)) {
    const l = a(this, ee) === at.HIGHLIGHT ? v(this, B, Uf).call(this, i) : null;
    l == null || l.toggleDrawing();
    const c = new AbortController(), d = this.combinedSignal(c), u = (f) => {
      f.type === "pointerup" && f.button !== 0 || (c.abort(), l == null || l.toggleDrawing(!0), f.type === "pointerup" && v(this, B, Vd).call(this, "main_toolbar"));
    };
    window.addEventListener("pointerup", u, {
      signal: d
    }), window.addEventListener("blur", u, {
      signal: d
    });
  }
}, Vd = function(e = "") {
  a(this, ee) === at.HIGHLIGHT ? this.highlightSelection(e) : a(this, Ch) && v(this, B, dv).call(this);
}, fv = function() {
  document.addEventListener("selectionchange", v(this, B, uv).bind(this), {
    signal: this._signal
  });
}, pv = function() {
  if (a(this, yn))
    return;
  p(this, yn, new AbortController());
  const e = this.combinedSignal(a(this, yn));
  window.addEventListener("focus", this.focus.bind(this), {
    signal: e
  }), window.addEventListener("blur", this.blur.bind(this), {
    signal: e
  });
}, gv = function() {
  var e;
  (e = a(this, yn)) == null || e.abort(), p(this, yn, null);
}, zf = function() {
  if (a(this, En))
    return;
  p(this, En, new AbortController());
  const e = this.combinedSignal(a(this, En));
  window.addEventListener("keydown", this.keydown.bind(this), {
    signal: e
  }), window.addEventListener("keyup", this.keyup.bind(this), {
    signal: e
  });
}, mv = function() {
  var e;
  (e = a(this, En)) == null || e.abort(), p(this, En, null);
}, Wf = function() {
  if (a(this, bn))
    return;
  p(this, bn, new AbortController());
  const e = this.combinedSignal(a(this, bn));
  document.addEventListener("copy", this.copy.bind(this), {
    signal: e
  }), document.addEventListener("cut", this.cut.bind(this), {
    signal: e
  }), document.addEventListener("paste", this.paste.bind(this), {
    signal: e
  });
}, Gf = function() {
  var e;
  (e = a(this, bn)) == null || e.abort(), p(this, bn, null);
}, vv = function() {
  const e = this._signal;
  document.addEventListener("dragover", this.dragOver.bind(this), {
    signal: e
  }), document.addEventListener("drop", this.drop.bind(this), {
    signal: e
  });
}, Ce = function(e) {
  Object.entries(e).some(([s, i]) => a(this, Nh)[s] !== i) && (this._eventBus.dispatch("annotationeditorstateschanged", {
    source: this,
    details: Object.assign(a(this, Nh), e)
  }), a(this, ee) === at.HIGHLIGHT && e.hasSelectedEditor === !1 && v(this, B, wi).call(this, [[ct.HIGHLIGHT_FREE, !0]]));
}, wi = function(e) {
  this._eventBus.dispatch("annotationeditorparamschanged", {
    source: this,
    details: e
  });
}, bv = async function() {
  if (!a(this, wn)) {
    p(this, wn, !0);
    const e = [];
    for (const t of a(this, he).values())
      e.push(t.enable());
    await Promise.all(e);
    for (const t of a(this, Kt).values())
      t.enable();
  }
}, yv = function() {
  if (this.unselectAll(), a(this, wn)) {
    p(this, wn, !1);
    for (const e of a(this, he).values())
      e.disable();
    for (const e of a(this, Kt).values())
      e.disable();
  }
}, Xf = function(e) {
  const t = a(this, he).get(e.pageIndex);
  t ? t.addOrRebuild(e) : (this.addEditor(e), this.addToAnnotationStorage(e));
}, Av = function() {
  let e = null;
  for (e of a(this, vt))
    ;
  return e;
}, zl = function() {
  if (a(this, Kt).size === 0)
    return !0;
  if (a(this, Kt).size === 1)
    for (const e of a(this, Kt).values())
      return e.isEmpty();
  return !1;
}, Yf = function(e) {
  for (const t of a(this, vt))
    t.unselect();
  a(this, vt).clear();
  for (const t of e)
    t.isEmpty() || (a(this, vt).add(t), t.select());
  v(this, B, Ce).call(this, {
    hasSelectedEditor: this.hasSelection
  });
}, K(rn, "TRANSLATE_SMALL", 1), K(rn, "TRANSLATE_BIG", 10), rn);
var se, Js, Cs, go, qs, Xe, mo, ti, Be, _i, Lr, ei, xn, Bs, Wl, Ud;
const Re = class Re {
  constructor(e) {
    b(this, Bs);
    b(this, se, null);
    b(this, Js, !1);
    b(this, Cs, null);
    b(this, go, null);
    b(this, qs, null);
    b(this, Xe, null);
    b(this, mo, !1);
    b(this, ti, null);
    b(this, Be, null);
    b(this, _i, null);
    b(this, Lr, null);
    b(this, ei, !1);
    p(this, Be, e), p(this, ei, e._uiManager.useNewAltTextFlow), a(Re, xn) || p(Re, xn, Object.freeze({
      added: "pdfjs-editor-new-alt-text-added-button",
      "added-label": "pdfjs-editor-new-alt-text-added-button-label",
      missing: "pdfjs-editor-new-alt-text-missing-button",
      "missing-label": "pdfjs-editor-new-alt-text-missing-button-label",
      review: "pdfjs-editor-new-alt-text-to-review-button",
      "review-label": "pdfjs-editor-new-alt-text-to-review-button-label"
    }));
  }
  static initialize(e) {
    Re._l10n ?? (Re._l10n = e);
  }
  async render() {
    const e = p(this, Cs, document.createElement("button"));
    e.className = "altText", e.tabIndex = "0";
    const t = p(this, go, document.createElement("span"));
    e.append(t), a(this, ei) ? (e.classList.add("new"), e.setAttribute("data-l10n-id", a(Re, xn).missing), t.setAttribute("data-l10n-id", a(Re, xn)["missing-label"])) : (e.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button"), t.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button-label"));
    const s = a(this, Be)._uiManager._signal;
    e.addEventListener("contextmenu", js, {
      signal: s
    }), e.addEventListener("pointerdown", (n) => n.stopPropagation(), {
      signal: s
    });
    const i = (n) => {
      n.preventDefault(), a(this, Be)._uiManager.editAltText(a(this, Be)), a(this, ei) && a(this, Be)._reportTelemetry({
        action: "pdfjs.image.alt_text.image_status_label_clicked",
        data: {
          label: a(this, Bs, Wl)
        }
      });
    };
    return e.addEventListener("click", i, {
      capture: !0,
      signal: s
    }), e.addEventListener("keydown", (n) => {
      n.target === e && n.key === "Enter" && (p(this, mo, !0), i(n));
    }, {
      signal: s
    }), await v(this, Bs, Ud).call(this), e;
  }
  finish() {
    a(this, Cs) && (a(this, Cs).focus({
      focusVisible: a(this, mo)
    }), p(this, mo, !1));
  }
  isEmpty() {
    return a(this, ei) ? a(this, se) === null : !a(this, se) && !a(this, Js);
  }
  hasData() {
    return a(this, ei) ? a(this, se) !== null || !!a(this, _i) : this.isEmpty();
  }
  get guessedText() {
    return a(this, _i);
  }
  async setGuessedText(e) {
    a(this, se) === null && (p(this, _i, e), p(this, Lr, await Re._l10n.get("pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer", {
      generatedAltText: e
    })), v(this, Bs, Ud).call(this));
  }
  toggleAltTextBadge(e = !1) {
    var t;
    if (!a(this, ei) || a(this, se)) {
      (t = a(this, ti)) == null || t.remove(), p(this, ti, null);
      return;
    }
    if (!a(this, ti)) {
      const s = p(this, ti, document.createElement("div"));
      s.className = "noAltTextBadge", a(this, Be).div.append(s);
    }
    a(this, ti).classList.toggle("hidden", !e);
  }
  serialize(e) {
    let t = a(this, se);
    return !e && a(this, _i) === t && (t = a(this, Lr)), {
      altText: t,
      decorative: a(this, Js),
      guessedText: a(this, _i),
      textWithDisclaimer: a(this, Lr)
    };
  }
  get data() {
    return {
      altText: a(this, se),
      decorative: a(this, Js)
    };
  }
  set data({
    altText: e,
    decorative: t,
    guessedText: s,
    textWithDisclaimer: i,
    cancel: n = !1
  }) {
    s && (p(this, _i, s), p(this, Lr, i)), !(a(this, se) === e && a(this, Js) === t) && (n || (p(this, se, e), p(this, Js, t)), v(this, Bs, Ud).call(this));
  }
  toggle(e = !1) {
    a(this, Cs) && (!e && a(this, Xe) && (clearTimeout(a(this, Xe)), p(this, Xe, null)), a(this, Cs).disabled = !e);
  }
  shown() {
    a(this, Be)._reportTelemetry({
      action: "pdfjs.image.alt_text.image_status_label_displayed",
      data: {
        label: a(this, Bs, Wl)
      }
    });
  }
  destroy() {
    var e, t;
    (e = a(this, Cs)) == null || e.remove(), p(this, Cs, null), p(this, go, null), p(this, qs, null), (t = a(this, ti)) == null || t.remove(), p(this, ti, null);
  }
};
se = new WeakMap(), Js = new WeakMap(), Cs = new WeakMap(), go = new WeakMap(), qs = new WeakMap(), Xe = new WeakMap(), mo = new WeakMap(), ti = new WeakMap(), Be = new WeakMap(), _i = new WeakMap(), Lr = new WeakMap(), ei = new WeakMap(), xn = new WeakMap(), Bs = new WeakSet(), Wl = function() {
  return a(this, se) && "added" || a(this, se) === null && this.guessedText && "review" || "missing";
}, Ud = async function() {
  var i, n, r;
  const e = a(this, Cs);
  if (!e)
    return;
  if (a(this, ei)) {
    if (e.classList.toggle("done", !!a(this, se)), e.setAttribute("data-l10n-id", a(Re, xn)[a(this, Bs, Wl)]), (i = a(this, go)) == null || i.setAttribute("data-l10n-id", a(Re, xn)[`${a(this, Bs, Wl)}-label`]), !a(this, se)) {
      (n = a(this, qs)) == null || n.remove();
      return;
    }
  } else {
    if (!a(this, se) && !a(this, Js)) {
      e.classList.remove("done"), (r = a(this, qs)) == null || r.remove();
      return;
    }
    e.classList.add("done"), e.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-edit-button");
  }
  let t = a(this, qs);
  if (!t) {
    p(this, qs, t = document.createElement("span")), t.className = "tooltip", t.setAttribute("role", "tooltip"), t.id = `alt-text-tooltip-${a(this, Be).id}`;
    const o = 100, l = a(this, Be)._uiManager._signal;
    l.addEventListener("abort", () => {
      clearTimeout(a(this, Xe)), p(this, Xe, null);
    }, {
      once: !0
    }), e.addEventListener("mouseenter", () => {
      p(this, Xe, setTimeout(() => {
        p(this, Xe, null), a(this, qs).classList.add("show"), a(this, Be)._reportTelemetry({
          action: "alt_text_tooltip"
        });
      }, o));
    }, {
      signal: l
    }), e.addEventListener("mouseleave", () => {
      var c;
      a(this, Xe) && (clearTimeout(a(this, Xe)), p(this, Xe, null)), (c = a(this, qs)) == null || c.classList.remove("show");
    }, {
      signal: l
    });
  }
  a(this, Js) ? t.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-decorative-tooltip") : (t.removeAttribute("data-l10n-id"), t.textContent = a(this, se)), t.parentNode || e.append(t);
  const s = a(this, Be).getImageForAltText();
  s == null || s.setAttribute("aria-describedby", t.id);
}, b(Re, xn, null), K(Re, "_l10n", null);
let Cu = Re;
var kh, Mr, Fh, Bh, jh, Hh, $h, vo, Li, Or, Tn, hn, Ev, Sv, Kf, bo;
let wv = (bo = class {
  constructor({
    container: e,
    isPinchingDisabled: t = null,
    isPinchingStopped: s = null,
    onPinchStart: i = null,
    onPinching: n = null,
    onPinchEnd: r = null,
    signal: o
  }) {
    b(this, hn);
    b(this, kh);
    b(this, Mr, !1);
    b(this, Fh, null);
    b(this, Bh);
    b(this, jh);
    b(this, Hh);
    b(this, $h);
    b(this, vo);
    b(this, Li, null);
    b(this, Or);
    b(this, Tn, null);
    p(this, kh, e), p(this, Fh, s), p(this, Bh, t), p(this, jh, i), p(this, Hh, n), p(this, $h, r), p(this, Or, new AbortController()), p(this, vo, AbortSignal.any([o, a(this, Or).signal])), e.addEventListener("touchstart", v(this, hn, Ev).bind(this), {
      passive: !1,
      signal: a(this, vo)
    });
  }
  get MIN_TOUCH_DISTANCE_TO_PINCH() {
    return ht(this, "MIN_TOUCH_DISTANCE_TO_PINCH", 35 / (window.devicePixelRatio || 1));
  }
  destroy() {
    var e;
    (e = a(this, Or)) == null || e.abort(), p(this, Or, null);
  }
}, kh = new WeakMap(), Mr = new WeakMap(), Fh = new WeakMap(), Bh = new WeakMap(), jh = new WeakMap(), Hh = new WeakMap(), $h = new WeakMap(), vo = new WeakMap(), Li = new WeakMap(), Or = new WeakMap(), Tn = new WeakMap(), hn = new WeakSet(), Ev = function(e) {
  var i, n, r;
  if ((i = a(this, Bh)) != null && i.call(this) || e.touches.length < 2)
    return;
  if (!a(this, Tn)) {
    p(this, Tn, new AbortController());
    const o = AbortSignal.any([a(this, vo), a(this, Tn).signal]), l = a(this, kh), c = {
      signal: o,
      passive: !1
    };
    l.addEventListener("touchmove", v(this, hn, Sv).bind(this), c), l.addEventListener("touchend", v(this, hn, Kf).bind(this), c), l.addEventListener("touchcancel", v(this, hn, Kf).bind(this), c), (n = a(this, jh)) == null || n.call(this);
  }
  if (os(e), e.touches.length !== 2 || (r = a(this, Fh)) != null && r.call(this)) {
    p(this, Li, null);
    return;
  }
  let [t, s] = e.touches;
  t.identifier > s.identifier && ([t, s] = [s, t]), p(this, Li, {
    touch0X: t.screenX,
    touch0Y: t.screenY,
    touch1X: s.screenX,
    touch1Y: s.screenY
  });
}, Sv = function(e) {
  var T;
  if (!a(this, Li) || e.touches.length !== 2)
    return;
  let [t, s] = e.touches;
  t.identifier > s.identifier && ([t, s] = [s, t]);
  const {
    screenX: i,
    screenY: n
  } = t, {
    screenX: r,
    screenY: o
  } = s, l = a(this, Li), {
    touch0X: c,
    touch0Y: d,
    touch1X: u,
    touch1Y: f
  } = l, g = u - c, m = f - d, y = r - i, w = o - n, A = Math.hypot(y, w) || 1, E = Math.hypot(g, m) || 1;
  if (!a(this, Mr) && Math.abs(E - A) <= bo.MIN_TOUCH_DISTANCE_TO_PINCH)
    return;
  if (l.touch0X = i, l.touch0Y = n, l.touch1X = r, l.touch1Y = o, e.preventDefault(), !a(this, Mr)) {
    p(this, Mr, !0);
    return;
  }
  const S = [(i + r) / 2, (n + o) / 2];
  (T = a(this, Hh)) == null || T.call(this, S, E, A);
}, Kf = function(e) {
  var t;
  a(this, Tn).abort(), p(this, Tn, null), (t = a(this, $h)) == null || t.call(this), a(this, Li) && (e.preventDefault(), p(this, Li, null), p(this, Mr, !1));
}, bo);
var Nr, Rs, Rt, yo, Pn, Vh, Dr, ce, kr, Mi, Cn, Uh, Fr, Ye, zh, Br, Oi, si, Ao, wo, fs, jr, Wh, Hu, Q, Qf, Gh, Zf, zd, xv, Tv, Jf, Wd, qf, Pv, Cv, Rv, tp, Iv, ep, _v, Lv, Mv, sp, Gl;
const ot = class ot {
  constructor(e) {
    b(this, Q);
    b(this, Nr, null);
    b(this, Rs, null);
    b(this, Rt, null);
    b(this, yo, !1);
    b(this, Pn, null);
    b(this, Vh, "");
    b(this, Dr, !1);
    b(this, ce, null);
    b(this, kr, null);
    b(this, Mi, null);
    b(this, Cn, null);
    b(this, Uh, "");
    b(this, Fr, !1);
    b(this, Ye, null);
    b(this, zh, !1);
    b(this, Br, !1);
    b(this, Oi, !1);
    b(this, si, null);
    b(this, Ao, 0);
    b(this, wo, 0);
    b(this, fs, null);
    b(this, jr, null);
    K(this, "_editToolbar", null);
    K(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
    K(this, "_initialData", null);
    K(this, "_isVisible", !0);
    K(this, "_uiManager", null);
    K(this, "_focusEventsAllowed", !0);
    b(this, Wh, !1);
    b(this, Hu, ot._zIndex++);
    this.parent = e.parent, this.id = e.id, this.width = this.height = null, this.pageIndex = e.parent.pageIndex, this.name = e.name, this.div = null, this._uiManager = e.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = !1, this._initialOptions.isCentered = e.isCentered, this._structTreeParentId = null;
    const {
      rotation: t,
      rawDims: {
        pageWidth: s,
        pageHeight: i,
        pageX: n,
        pageY: r
      }
    } = this.parent.viewport;
    this.rotation = t, this.pageRotation = (360 + t - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [s, i], this.pageTranslation = [n, r];
    const [o, l] = this.parentDimensions;
    this.x = e.x / o, this.y = e.y / l, this.isAttachedToDOM = !1, this.deleted = !1;
  }
  static get _resizerKeyboardManager() {
    const e = ot.prototype._resizeWithKeyboard, t = vh.TRANSLATE_SMALL, s = vh.TRANSLATE_BIG;
    return ht(this, "_resizerKeyboardManager", new Sd([[["ArrowLeft", "mac+ArrowLeft"], e, {
      args: [-t, 0]
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], e, {
      args: [-s, 0]
    }], [["ArrowRight", "mac+ArrowRight"], e, {
      args: [t, 0]
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], e, {
      args: [s, 0]
    }], [["ArrowUp", "mac+ArrowUp"], e, {
      args: [0, -t]
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], e, {
      args: [0, -s]
    }], [["ArrowDown", "mac+ArrowDown"], e, {
      args: [0, t]
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], e, {
      args: [0, s]
    }], [["Escape", "mac+Escape"], ot.prototype._stopResizingWithKeyboard]]));
  }
  get editorType() {
    return Object.getPrototypeOf(this).constructor._type;
  }
  static get isDrawer() {
    return !1;
  }
  static get _defaultLineColor() {
    return ht(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
  }
  static deleteAnnotationElement(e) {
    const t = new RA({
      id: e.parent.getNextId(),
      parent: e.parent,
      uiManager: e._uiManager
    });
    t.annotationElementId = e.annotationElementId, t.deleted = !0, t._uiManager.addToAnnotationStorage(t);
  }
  static initialize(e, t) {
    if (ot._l10n ?? (ot._l10n = e), ot._l10nResizer || (ot._l10nResizer = Object.freeze({
      topLeft: "pdfjs-editor-resizer-top-left",
      topMiddle: "pdfjs-editor-resizer-top-middle",
      topRight: "pdfjs-editor-resizer-top-right",
      middleRight: "pdfjs-editor-resizer-middle-right",
      bottomRight: "pdfjs-editor-resizer-bottom-right",
      bottomMiddle: "pdfjs-editor-resizer-bottom-middle",
      bottomLeft: "pdfjs-editor-resizer-bottom-left",
      middleLeft: "pdfjs-editor-resizer-middle-left"
    })), ot._borderLineWidth !== -1)
      return;
    const s = getComputedStyle(document.documentElement);
    ot._borderLineWidth = parseFloat(s.getPropertyValue("--outline-width")) || 0;
  }
  static updateDefaultParams(e, t) {
  }
  static get defaultPropertiesToUpdate() {
    return [];
  }
  static isHandlingMimeForPasting(e) {
    return !1;
  }
  static paste(e, t) {
    Pt("Not implemented");
  }
  get propertiesToUpdate() {
    return [];
  }
  get _isDraggable() {
    return a(this, Wh);
  }
  set _isDraggable(e) {
    var t;
    p(this, Wh, e), (t = this.div) == null || t.classList.toggle("draggable", e);
  }
  get isEnterHandled() {
    return !0;
  }
  center() {
    const [e, t] = this.pageDimensions;
    switch (this.parentRotation) {
      case 90:
        this.x -= this.height * t / (e * 2), this.y += this.width * e / (t * 2);
        break;
      case 180:
        this.x += this.width / 2, this.y += this.height / 2;
        break;
      case 270:
        this.x += this.height * t / (e * 2), this.y -= this.width * e / (t * 2);
        break;
      default:
        this.x -= this.width / 2, this.y -= this.height / 2;
        break;
    }
    this.fixAndSetPosition();
  }
  addCommands(e) {
    this._uiManager.addCommands(e);
  }
  get currentLayer() {
    return this._uiManager.currentLayer;
  }
  setInBackground() {
    this.div.style.zIndex = 0;
  }
  setInForeground() {
    this.div.style.zIndex = a(this, Hu);
  }
  setParent(e) {
    e !== null ? (this.pageIndex = e.pageIndex, this.pageDimensions = e.pageDimensions) : v(this, Q, Gl).call(this), this.parent = e;
  }
  focusin(e) {
    this._focusEventsAllowed && (a(this, Fr) ? p(this, Fr, !1) : this.parent.setSelected(this));
  }
  focusout(e) {
    var s;
    if (!this._focusEventsAllowed || !this.isAttachedToDOM)
      return;
    const t = e.relatedTarget;
    t != null && t.closest(`#${this.id}`) || (e.preventDefault(), (s = this.parent) != null && s.isMultipleSelection || this.commitOrRemove());
  }
  commitOrRemove() {
    this.isEmpty() ? this.remove() : this.commit();
  }
  commit() {
    this.addToAnnotationStorage();
  }
  addToAnnotationStorage() {
    this._uiManager.addToAnnotationStorage(this);
  }
  setAt(e, t, s, i) {
    const [n, r] = this.parentDimensions;
    [s, i] = this.screenToPageTranslation(s, i), this.x = (e + s) / n, this.y = (t + i) / r, this.fixAndSetPosition();
  }
  translate(e, t) {
    v(this, Q, Qf).call(this, this.parentDimensions, e, t);
  }
  translateInPage(e, t) {
    a(this, Ye) || p(this, Ye, [this.x, this.y, this.width, this.height]), v(this, Q, Qf).call(this, this.pageDimensions, e, t), this.div.scrollIntoView({
      block: "nearest"
    });
  }
  drag(e, t) {
    a(this, Ye) || p(this, Ye, [this.x, this.y, this.width, this.height]);
    const {
      div: s,
      parentDimensions: [i, n]
    } = this;
    if (this.x += e / i, this.y += t / n, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
      const {
        x: u,
        y: f
      } = this.div.getBoundingClientRect();
      this.parent.findNewParent(this, u, f) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y));
    }
    let {
      x: r,
      y: o
    } = this;
    const [l, c] = this.getBaseTranslation();
    r += l, o += c;
    const {
      style: d
    } = s;
    d.left = `${(100 * r).toFixed(2)}%`, d.top = `${(100 * o).toFixed(2)}%`, this._onTranslating(r, o), s.scrollIntoView({
      block: "nearest"
    });
  }
  _onTranslating(e, t) {
  }
  _onTranslated(e, t) {
  }
  get _hasBeenMoved() {
    return !!a(this, Ye) && (a(this, Ye)[0] !== this.x || a(this, Ye)[1] !== this.y);
  }
  get _hasBeenResized() {
    return !!a(this, Ye) && (a(this, Ye)[2] !== this.width || a(this, Ye)[3] !== this.height);
  }
  getBaseTranslation() {
    const [e, t] = this.parentDimensions, {
      _borderLineWidth: s
    } = ot, i = s / e, n = s / t;
    switch (this.rotation) {
      case 90:
        return [-i, n];
      case 180:
        return [i, n];
      case 270:
        return [i, -n];
      default:
        return [-i, -n];
    }
  }
  get _mustFixPosition() {
    return !0;
  }
  fixAndSetPosition(e = this.rotation) {
    const {
      div: {
        style: t
      },
      pageDimensions: [s, i]
    } = this;
    let {
      x: n,
      y: r,
      width: o,
      height: l
    } = this;
    if (o *= s, l *= i, n *= s, r *= i, this._mustFixPosition)
      switch (e) {
        case 0:
          n = Math.max(0, Math.min(s - o, n)), r = Math.max(0, Math.min(i - l, r));
          break;
        case 90:
          n = Math.max(0, Math.min(s - l, n)), r = Math.min(i, Math.max(o, r));
          break;
        case 180:
          n = Math.min(s, Math.max(o, n)), r = Math.min(i, Math.max(l, r));
          break;
        case 270:
          n = Math.min(s, Math.max(l, n)), r = Math.max(0, Math.min(i - o, r));
          break;
      }
    this.x = n /= s, this.y = r /= i;
    const [c, d] = this.getBaseTranslation();
    n += c, r += d, t.left = `${(100 * n).toFixed(2)}%`, t.top = `${(100 * r).toFixed(2)}%`, this.moveInDOM();
  }
  screenToPageTranslation(e, t) {
    var s;
    return v(s = ot, Gh, Zf).call(s, e, t, this.parentRotation);
  }
  pageTranslationToScreen(e, t) {
    var s;
    return v(s = ot, Gh, Zf).call(s, e, t, 360 - this.parentRotation);
  }
  get parentScale() {
    return this._uiManager.viewParameters.realScale;
  }
  get parentRotation() {
    return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
  }
  get parentDimensions() {
    const {
      parentScale: e,
      pageDimensions: [t, s]
    } = this;
    return [t * e, s * e];
  }
  setDims(e, t) {
    const [s, i] = this.parentDimensions, {
      style: n
    } = this.div;
    n.width = `${(100 * e / s).toFixed(2)}%`, a(this, Dr) || (n.height = `${(100 * t / i).toFixed(2)}%`);
  }
  fixDims() {
    const {
      style: e
    } = this.div, {
      height: t,
      width: s
    } = e, i = s.endsWith("%"), n = !a(this, Dr) && t.endsWith("%");
    if (i && n)
      return;
    const [r, o] = this.parentDimensions;
    i || (e.width = `${(100 * parseFloat(s) / r).toFixed(2)}%`), !a(this, Dr) && !n && (e.height = `${(100 * parseFloat(t) / o).toFixed(2)}%`);
  }
  getInitialTranslation() {
    return [0, 0];
  }
  _onResized() {
  }
  static _round(e) {
    return Math.round(e * 1e4) / 1e4;
  }
  _onResizing() {
  }
  altTextFinish() {
    var e;
    (e = a(this, Rt)) == null || e.finish();
  }
  async addEditToolbar() {
    return this._editToolbar || a(this, Br) ? this._editToolbar : (this._editToolbar = new jf(this), this.div.append(this._editToolbar.render()), a(this, Rt) && await this._editToolbar.addAltText(a(this, Rt)), this._editToolbar);
  }
  removeEditToolbar() {
    var e;
    this._editToolbar && (this._editToolbar.remove(), this._editToolbar = null, (e = a(this, Rt)) == null || e.destroy());
  }
  addContainer(e) {
    var s;
    const t = (s = this._editToolbar) == null ? void 0 : s.div;
    t ? t.before(e) : this.div.append(e);
  }
  getClientDimensions() {
    return this.div.getBoundingClientRect();
  }
  async addAltTextButton() {
    a(this, Rt) || (Cu.initialize(ot._l10n), p(this, Rt, new Cu(this)), a(this, Nr) && (a(this, Rt).data = a(this, Nr), p(this, Nr, null)), await this.addEditToolbar());
  }
  get altTextData() {
    var e;
    return (e = a(this, Rt)) == null ? void 0 : e.data;
  }
  set altTextData(e) {
    a(this, Rt) && (a(this, Rt).data = e);
  }
  get guessedAltText() {
    var e;
    return (e = a(this, Rt)) == null ? void 0 : e.guessedText;
  }
  async setGuessedAltText(e) {
    var t;
    await ((t = a(this, Rt)) == null ? void 0 : t.setGuessedText(e));
  }
  serializeAltText(e) {
    var t;
    return (t = a(this, Rt)) == null ? void 0 : t.serialize(e);
  }
  hasAltText() {
    return !!a(this, Rt) && !a(this, Rt).isEmpty();
  }
  hasAltTextData() {
    var e;
    return ((e = a(this, Rt)) == null ? void 0 : e.hasData()) ?? !1;
  }
  render() {
    var n;
    this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.tabIndex = a(this, yo) ? -1 : 0, this._isVisible || this.div.classList.add("hidden"), this.setInForeground(), v(this, Q, ep).call(this);
    const [e, t] = this.parentDimensions;
    this.parentRotation % 180 !== 0 && (this.div.style.maxWidth = `${(100 * t / e).toFixed(2)}%`, this.div.style.maxHeight = `${(100 * e / t).toFixed(2)}%`);
    const [s, i] = this.getInitialTranslation();
    return this.translate(s, i), Pu(this, this.div, ["pointerdown"]), this.isResizable && this._uiManager._supportsPinchToZoom && (a(this, jr) || p(this, jr, new wv({
      container: this.div,
      isPinchingDisabled: () => !this.isSelected,
      onPinchStart: v(this, Q, Pv).bind(this),
      onPinching: v(this, Q, Cv).bind(this),
      onPinchEnd: v(this, Q, Rv).bind(this),
      signal: this._uiManager._signal
    }))), (n = this._uiManager._editorUndoBar) == null || n.hide(), this.div;
  }
  pointerdown(e) {
    const {
      isMac: t
    } = Oe.platform;
    if (e.button !== 0 || e.ctrlKey && t) {
      e.preventDefault();
      return;
    }
    if (p(this, Fr, !0), this._isDraggable) {
      v(this, Q, Iv).call(this, e);
      return;
    }
    v(this, Q, tp).call(this, e);
  }
  get isSelected() {
    return this._uiManager.isSelected(this);
  }
  _onStartDragging() {
  }
  _onStopDragging() {
  }
  moveInDOM() {
    a(this, si) && clearTimeout(a(this, si)), p(this, si, setTimeout(() => {
      var e;
      p(this, si, null), (e = this.parent) == null || e.moveEditorInDOM(this);
    }, 0));
  }
  _setParentAndPosition(e, t, s) {
    e.changeParent(this), this.x = t, this.y = s, this.fixAndSetPosition(), this._onTranslated();
  }
  getRect(e, t, s = this.rotation) {
    const i = this.parentScale, [n, r] = this.pageDimensions, [o, l] = this.pageTranslation, c = e / i, d = t / i, u = this.x * n, f = this.y * r, g = this.width * n, m = this.height * r;
    switch (s) {
      case 0:
        return [u + c + o, r - f - d - m + l, u + c + g + o, r - f - d + l];
      case 90:
        return [u + d + o, r - f + c + l, u + d + m + o, r - f + c + g + l];
      case 180:
        return [u - c - g + o, r - f + d + l, u - c + o, r - f + d + m + l];
      case 270:
        return [u - d - m + o, r - f - c - g + l, u - d + o, r - f - c + l];
      default:
        throw new Error("Invalid rotation");
    }
  }
  getRectInCurrentCoords(e, t) {
    const [s, i, n, r] = e, o = n - s, l = r - i;
    switch (this.rotation) {
      case 0:
        return [s, t - r, o, l];
      case 90:
        return [s, t - i, l, o];
      case 180:
        return [n, t - i, o, l];
      case 270:
        return [n, t - r, l, o];
      default:
        throw new Error("Invalid rotation");
    }
  }
  onceAdded(e) {
  }
  isEmpty() {
    return !1;
  }
  enableEditMode() {
    p(this, Br, !0);
  }
  disableEditMode() {
    p(this, Br, !1);
  }
  isInEditMode() {
    return a(this, Br);
  }
  shouldGetKeyboardEvents() {
    return a(this, Oi);
  }
  needsToBeRebuilt() {
    return this.div && !this.isAttachedToDOM;
  }
  get isOnScreen() {
    const {
      top: e,
      left: t,
      bottom: s,
      right: i
    } = this.getClientDimensions(), {
      innerHeight: n,
      innerWidth: r
    } = window;
    return t < r && i > 0 && e < n && s > 0;
  }
  rebuild() {
    v(this, Q, ep).call(this);
  }
  rotate(e) {
  }
  resize() {
  }
  serializeDeleted() {
    var e;
    return {
      id: this.annotationElementId,
      deleted: !0,
      pageIndex: this.pageIndex,
      popupRef: ((e = this._initialData) == null ? void 0 : e.popupRef) || ""
    };
  }
  serialize(e = !1, t = null) {
    Pt("An editor must be serializable");
  }
  static async deserialize(e, t, s) {
    const i = new this.prototype.constructor({
      parent: t,
      id: t.getNextId(),
      uiManager: s
    });
    i.rotation = e.rotation, p(i, Nr, e.accessibilityData);
    const [n, r] = i.pageDimensions, [o, l, c, d] = i.getRectInCurrentCoords(e.rect, r);
    return i.x = o / n, i.y = l / r, i.width = c / n, i.height = d / r, i;
  }
  get hasBeenModified() {
    return !!this.annotationElementId && (this.deleted || this.serialize() !== null);
  }
  remove() {
    var e, t;
    if ((e = a(this, Cn)) == null || e.abort(), p(this, Cn, null), this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), a(this, si) && (clearTimeout(a(this, si)), p(this, si, null)), v(this, Q, Gl).call(this), this.removeEditToolbar(), a(this, fs)) {
      for (const s of a(this, fs).values())
        clearTimeout(s);
      p(this, fs, null);
    }
    this.parent = null, (t = a(this, jr)) == null || t.destroy(), p(this, jr, null);
  }
  get isResizable() {
    return !1;
  }
  makeResizable() {
    this.isResizable && (v(this, Q, xv).call(this), a(this, ce).classList.remove("hidden"), Pu(this, this.div, ["keydown"]));
  }
  get toolbarPosition() {
    return null;
  }
  keydown(e) {
    if (!this.isResizable || e.target !== this.div || e.key !== "Enter")
      return;
    this._uiManager.setSelected(this), p(this, Mi, {
      savedX: this.x,
      savedY: this.y,
      savedWidth: this.width,
      savedHeight: this.height
    });
    const t = a(this, ce).children;
    if (!a(this, Rs)) {
      p(this, Rs, Array.from(t));
      const r = v(this, Q, _v).bind(this), o = v(this, Q, Lv).bind(this), l = this._uiManager._signal;
      for (const c of a(this, Rs)) {
        const d = c.getAttribute("data-resizer-name");
        c.setAttribute("role", "spinbutton"), c.addEventListener("keydown", r, {
          signal: l
        }), c.addEventListener("blur", o, {
          signal: l
        }), c.addEventListener("focus", v(this, Q, Mv).bind(this, d), {
          signal: l
        }), c.setAttribute("data-l10n-id", ot._l10nResizer[d]);
      }
    }
    const s = a(this, Rs)[0];
    let i = 0;
    for (const r of t) {
      if (r === s)
        break;
      i++;
    }
    const n = (360 - this.rotation + this.parentRotation) % 360 / 90 * (a(this, Rs).length / 4);
    if (n !== i) {
      if (n < i)
        for (let o = 0; o < i - n; o++)
          a(this, ce).append(a(this, ce).firstChild);
      else if (n > i)
        for (let o = 0; o < n - i; o++)
          a(this, ce).firstChild.before(a(this, ce).lastChild);
      let r = 0;
      for (const o of t) {
        const c = a(this, Rs)[r++].getAttribute("data-resizer-name");
        o.setAttribute("data-l10n-id", ot._l10nResizer[c]);
      }
    }
    v(this, Q, sp).call(this, 0), p(this, Oi, !0), a(this, ce).firstChild.focus({
      focusVisible: !0
    }), e.preventDefault(), e.stopImmediatePropagation();
  }
  _resizeWithKeyboard(e, t) {
    a(this, Oi) && v(this, Q, qf).call(this, a(this, Uh), {
      deltaX: e,
      deltaY: t,
      fromKeyboard: !0
    });
  }
  _stopResizingWithKeyboard() {
    v(this, Q, Gl).call(this), this.div.focus();
  }
  select() {
    var e, t, s;
    if (this.makeResizable(), (e = this.div) == null || e.classList.add("selectedEditor"), !this._editToolbar) {
      this.addEditToolbar().then(() => {
        var i, n;
        (i = this.div) != null && i.classList.contains("selectedEditor") && ((n = this._editToolbar) == null || n.show());
      });
      return;
    }
    (t = this._editToolbar) == null || t.show(), (s = a(this, Rt)) == null || s.toggleAltTextBadge(!1);
  }
  unselect() {
    var e, t, s, i, n;
    (e = a(this, ce)) == null || e.classList.add("hidden"), (t = this.div) == null || t.classList.remove("selectedEditor"), (s = this.div) != null && s.contains(document.activeElement) && this._uiManager.currentLayer.div.focus({
      preventScroll: !0
    }), (i = this._editToolbar) == null || i.hide(), (n = a(this, Rt)) == null || n.toggleAltTextBadge(!0);
  }
  updateParams(e, t) {
  }
  disableEditing() {
  }
  enableEditing() {
  }
  enterInEditMode() {
  }
  getImageForAltText() {
    return null;
  }
  get contentDiv() {
    return this.div;
  }
  get isEditing() {
    return a(this, zh);
  }
  set isEditing(e) {
    p(this, zh, e), this.parent && (e ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
  }
  setAspectRatio(e, t) {
    p(this, Dr, !0);
    const s = e / t, {
      style: i
    } = this.div;
    i.aspectRatio = s, i.height = "auto";
  }
  static get MIN_SIZE() {
    return 16;
  }
  static canCreateNewEmptyEditor() {
    return !0;
  }
  get telemetryInitialData() {
    return {
      action: "added"
    };
  }
  get telemetryFinalData() {
    return null;
  }
  _reportTelemetry(e, t = !1) {
    if (t) {
      a(this, fs) || p(this, fs, /* @__PURE__ */ new Map());
      const {
        action: s
      } = e;
      let i = a(this, fs).get(s);
      i && clearTimeout(i), i = setTimeout(() => {
        this._reportTelemetry(e), a(this, fs).delete(s), a(this, fs).size === 0 && p(this, fs, null);
      }, ot._telemetryTimeout), a(this, fs).set(s, i);
      return;
    }
    e.type || (e.type = this.editorType), this._uiManager._eventBus.dispatch("reporttelemetry", {
      source: this,
      details: {
        type: "editing",
        data: e
      }
    });
  }
  show(e = this._isVisible) {
    this.div.classList.toggle("hidden", !e), this._isVisible = e;
  }
  enable() {
    this.div && (this.div.tabIndex = 0), p(this, yo, !1);
  }
  disable() {
    this.div && (this.div.tabIndex = -1), p(this, yo, !0);
  }
  renderAnnotationElement(e) {
    let t = e.container.querySelector(".annotationContent");
    if (!t)
      t = document.createElement("div"), t.classList.add("annotationContent", this.editorType), e.container.prepend(t);
    else if (t.nodeName === "CANVAS") {
      const s = t;
      t = document.createElement("div"), t.classList.add("annotationContent", this.editorType), s.before(t);
    }
    return t;
  }
  resetAnnotationElement(e) {
    const {
      firstChild: t
    } = e.container;
    (t == null ? void 0 : t.nodeName) === "DIV" && t.classList.contains("annotationContent") && t.remove();
  }
};
Nr = new WeakMap(), Rs = new WeakMap(), Rt = new WeakMap(), yo = new WeakMap(), Pn = new WeakMap(), Vh = new WeakMap(), Dr = new WeakMap(), ce = new WeakMap(), kr = new WeakMap(), Mi = new WeakMap(), Cn = new WeakMap(), Uh = new WeakMap(), Fr = new WeakMap(), Ye = new WeakMap(), zh = new WeakMap(), Br = new WeakMap(), Oi = new WeakMap(), si = new WeakMap(), Ao = new WeakMap(), wo = new WeakMap(), fs = new WeakMap(), jr = new WeakMap(), Wh = new WeakMap(), Hu = new WeakMap(), Q = new WeakSet(), Qf = function([e, t], s, i) {
  [s, i] = this.screenToPageTranslation(s, i), this.x += s / e, this.y += i / t, this._onTranslating(this.x, this.y), this.fixAndSetPosition();
}, Gh = new WeakSet(), Zf = function(e, t, s) {
  switch (s) {
    case 90:
      return [t, -e];
    case 180:
      return [-e, -t];
    case 270:
      return [-t, e];
    default:
      return [e, t];
  }
}, zd = function(e) {
  switch (e) {
    case 90: {
      const [t, s] = this.pageDimensions;
      return [0, -t / s, s / t, 0];
    }
    case 180:
      return [-1, 0, 0, -1];
    case 270: {
      const [t, s] = this.pageDimensions;
      return [0, t / s, -s / t, 0];
    }
    default:
      return [1, 0, 0, 1];
  }
}, xv = function() {
  if (a(this, ce))
    return;
  p(this, ce, document.createElement("div")), a(this, ce).classList.add("resizers");
  const e = this._willKeepAspectRatio ? ["topLeft", "topRight", "bottomRight", "bottomLeft"] : ["topLeft", "topMiddle", "topRight", "middleRight", "bottomRight", "bottomMiddle", "bottomLeft", "middleLeft"], t = this._uiManager._signal;
  for (const s of e) {
    const i = document.createElement("div");
    a(this, ce).append(i), i.classList.add("resizer", s), i.setAttribute("data-resizer-name", s), i.addEventListener("pointerdown", v(this, Q, Tv).bind(this, s), {
      signal: t
    }), i.addEventListener("contextmenu", js, {
      signal: t
    }), i.tabIndex = -1;
  }
  this.div.prepend(a(this, ce));
}, Tv = function(e, t) {
  var d;
  t.preventDefault();
  const {
    isMac: s
  } = Oe.platform;
  if (t.button !== 0 || t.ctrlKey && s)
    return;
  (d = a(this, Rt)) == null || d.toggle(!1);
  const i = this._isDraggable;
  this._isDraggable = !1, p(this, kr, [t.screenX, t.screenY]);
  const n = new AbortController(), r = this._uiManager.combinedSignal(n);
  this.parent.togglePointerEvents(!1), window.addEventListener("pointermove", v(this, Q, qf).bind(this, e), {
    passive: !0,
    capture: !0,
    signal: r
  }), window.addEventListener("touchmove", os, {
    passive: !1,
    signal: r
  }), window.addEventListener("contextmenu", js, {
    signal: r
  }), p(this, Mi, {
    savedX: this.x,
    savedY: this.y,
    savedWidth: this.width,
    savedHeight: this.height
  });
  const o = this.parent.div.style.cursor, l = this.div.style.cursor;
  this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(t.target).cursor;
  const c = () => {
    var u;
    n.abort(), this.parent.togglePointerEvents(!0), (u = a(this, Rt)) == null || u.toggle(!0), this._isDraggable = i, this.parent.div.style.cursor = o, this.div.style.cursor = l, v(this, Q, Wd).call(this);
  };
  window.addEventListener("pointerup", c, {
    signal: r
  }), window.addEventListener("blur", c, {
    signal: r
  });
}, Jf = function(e, t, s, i) {
  this.width = s, this.height = i, this.x = e, this.y = t;
  const [n, r] = this.parentDimensions;
  this.setDims(n * s, r * i), this.fixAndSetPosition(), this._onResized();
}, Wd = function() {
  if (!a(this, Mi))
    return;
  const {
    savedX: e,
    savedY: t,
    savedWidth: s,
    savedHeight: i
  } = a(this, Mi);
  p(this, Mi, null);
  const n = this.x, r = this.y, o = this.width, l = this.height;
  n === e && r === t && o === s && l === i || this.addCommands({
    cmd: v(this, Q, Jf).bind(this, n, r, o, l),
    undo: v(this, Q, Jf).bind(this, e, t, s, i),
    mustExec: !0
  });
}, qf = function(e, t) {
  const [s, i] = this.parentDimensions, n = this.x, r = this.y, o = this.width, l = this.height, c = ot.MIN_SIZE / s, d = ot.MIN_SIZE / i, u = v(this, Q, zd).call(this, this.rotation), f = (N, D) => [u[0] * N + u[2] * D, u[1] * N + u[3] * D], g = v(this, Q, zd).call(this, 360 - this.rotation), m = (N, D) => [g[0] * N + g[2] * D, g[1] * N + g[3] * D];
  let y, w, A = !1, E = !1;
  switch (e) {
    case "topLeft":
      A = !0, y = (N, D) => [0, 0], w = (N, D) => [N, D];
      break;
    case "topMiddle":
      y = (N, D) => [N / 2, 0], w = (N, D) => [N / 2, D];
      break;
    case "topRight":
      A = !0, y = (N, D) => [N, 0], w = (N, D) => [0, D];
      break;
    case "middleRight":
      E = !0, y = (N, D) => [N, D / 2], w = (N, D) => [0, D / 2];
      break;
    case "bottomRight":
      A = !0, y = (N, D) => [N, D], w = (N, D) => [0, 0];
      break;
    case "bottomMiddle":
      y = (N, D) => [N / 2, D], w = (N, D) => [N / 2, 0];
      break;
    case "bottomLeft":
      A = !0, y = (N, D) => [0, D], w = (N, D) => [N, 0];
      break;
    case "middleLeft":
      E = !0, y = (N, D) => [0, D / 2], w = (N, D) => [N, D / 2];
      break;
  }
  const S = y(o, l), T = w(o, l);
  let P = f(...T);
  const C = ot._round(n + P[0]), R = ot._round(r + P[1]);
  let _ = 1, x = 1, I, L;
  if (t.fromKeyboard)
    ({
      deltaX: I,
      deltaY: L
    } = t);
  else {
    const {
      screenX: N,
      screenY: D
    } = t, [et, ft] = a(this, kr);
    [I, L] = this.screenToPageTranslation(N - et, D - ft), a(this, kr)[0] = N, a(this, kr)[1] = D;
  }
  if ([I, L] = m(I / s, L / i), A) {
    const N = Math.hypot(o, l);
    _ = x = Math.max(Math.min(Math.hypot(T[0] - S[0] - I, T[1] - S[1] - L) / N, 1 / o, 1 / l), c / o, d / l);
  } else E ? _ = Math.max(c, Math.min(1, Math.abs(T[0] - S[0] - I))) / o : x = Math.max(d, Math.min(1, Math.abs(T[1] - S[1] - L))) / l;
  const j = ot._round(o * _), k = ot._round(l * x);
  P = f(...w(j, k));
  const F = C - P[0], Y = R - P[1];
  a(this, Ye) || p(this, Ye, [this.x, this.y, this.width, this.height]), this.width = j, this.height = k, this.x = F, this.y = Y, this.setDims(s * j, i * k), this.fixAndSetPosition(), this._onResizing();
}, Pv = function() {
  var e;
  p(this, Mi, {
    savedX: this.x,
    savedY: this.y,
    savedWidth: this.width,
    savedHeight: this.height
  }), (e = a(this, Rt)) == null || e.toggle(!1), this.parent.togglePointerEvents(!1);
}, Cv = function(e, t, s) {
  let n = 0.7 * (s / t) + 1 - 0.7;
  if (n === 1)
    return;
  const r = v(this, Q, zd).call(this, this.rotation), o = (C, R) => [r[0] * C + r[2] * R, r[1] * C + r[3] * R], [l, c] = this.parentDimensions, d = this.x, u = this.y, f = this.width, g = this.height, m = ot.MIN_SIZE / l, y = ot.MIN_SIZE / c;
  n = Math.max(Math.min(n, 1 / f, 1 / g), m / f, y / g);
  const w = ot._round(f * n), A = ot._round(g * n);
  if (w === f && A === g)
    return;
  a(this, Ye) || p(this, Ye, [d, u, f, g]);
  const E = o(f / 2, g / 2), S = ot._round(d + E[0]), T = ot._round(u + E[1]), P = o(w / 2, A / 2);
  this.x = S - P[0], this.y = T - P[1], this.width = w, this.height = A, this.setDims(l * w, c * A), this.fixAndSetPosition(), this._onResizing();
}, Rv = function() {
  var e;
  (e = a(this, Rt)) == null || e.toggle(!0), this.parent.togglePointerEvents(!0), v(this, Q, Wd).call(this);
}, tp = function(e) {
  const {
    isMac: t
  } = Oe.platform;
  e.ctrlKey && !t || e.shiftKey || e.metaKey && t ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
}, Iv = function(e) {
  const {
    isSelected: t
  } = this;
  this._uiManager.setUpDragSession();
  let s = !1;
  const i = new AbortController(), n = this._uiManager.combinedSignal(i), r = {
    capture: !0,
    passive: !1,
    signal: n
  }, o = (c) => {
    i.abort(), p(this, Pn, null), p(this, Fr, !1), this._uiManager.endDragSession() || v(this, Q, tp).call(this, c), s && this._onStopDragging();
  };
  t && (p(this, Ao, e.clientX), p(this, wo, e.clientY), p(this, Pn, e.pointerId), p(this, Vh, e.pointerType), window.addEventListener("pointermove", (c) => {
    s || (s = !0, this._onStartDragging());
    const {
      clientX: d,
      clientY: u,
      pointerId: f
    } = c;
    if (f !== a(this, Pn)) {
      os(c);
      return;
    }
    const [g, m] = this.screenToPageTranslation(d - a(this, Ao), u - a(this, wo));
    p(this, Ao, d), p(this, wo, u), this._uiManager.dragSelectedEditors(g, m);
  }, r), window.addEventListener("touchmove", os, r), window.addEventListener("pointerdown", (c) => {
    c.pointerType === a(this, Vh) && (a(this, jr) || c.isPrimary) && o(c), os(c);
  }, r));
  const l = (c) => {
    if (!a(this, Pn) || a(this, Pn) === c.pointerId) {
      o(c);
      return;
    }
    os(c);
  };
  window.addEventListener("pointerup", l, {
    signal: n
  }), window.addEventListener("blur", l, {
    signal: n
  });
}, ep = function() {
  if (a(this, Cn) || !this.div)
    return;
  p(this, Cn, new AbortController());
  const e = this._uiManager.combinedSignal(a(this, Cn));
  this.div.addEventListener("focusin", this.focusin.bind(this), {
    signal: e
  }), this.div.addEventListener("focusout", this.focusout.bind(this), {
    signal: e
  });
}, _v = function(e) {
  ot._resizerKeyboardManager.exec(this, e);
}, Lv = function(e) {
  var t;
  a(this, Oi) && ((t = e.relatedTarget) == null ? void 0 : t.parentNode) !== a(this, ce) && v(this, Q, Gl).call(this);
}, Mv = function(e) {
  p(this, Uh, a(this, Oi) ? e : "");
}, sp = function(e) {
  if (a(this, Rs))
    for (const t of a(this, Rs))
      t.tabIndex = e;
}, Gl = function() {
  p(this, Oi, !1), v(this, Q, sp).call(this, -1), v(this, Q, Wd).call(this);
}, b(ot, Gh), K(ot, "_l10n", null), K(ot, "_l10nResizer", null), K(ot, "_borderLineWidth", -1), K(ot, "_colorManager", new Vf()), K(ot, "_zIndex", 1), K(ot, "_telemetryTimeout", 1e3);
let Ot = ot;
class RA extends Ot {
  constructor(e) {
    super(e), this.annotationElementId = e.annotationElementId, this.deleted = !0;
  }
  serialize() {
    return this.serializeDeleted();
  }
}
const qg = 3285377520, cs = 4294901760, Ws = 65535;
class Ov {
  constructor(e) {
    this.h1 = e ? e & 4294967295 : qg, this.h2 = e ? e & 4294967295 : qg;
  }
  update(e) {
    let t, s;
    if (typeof e == "string") {
      t = new Uint8Array(e.length * 2), s = 0;
      for (let y = 0, w = e.length; y < w; y++) {
        const A = e.charCodeAt(y);
        A <= 255 ? t[s++] = A : (t[s++] = A >>> 8, t[s++] = A & 255);
      }
    } else if (ArrayBuffer.isView(e))
      t = e.slice(), s = t.byteLength;
    else
      throw new Error("Invalid data format, must be a string or TypedArray.");
    const i = s >> 2, n = s - i * 4, r = new Uint32Array(t.buffer, 0, i);
    let o = 0, l = 0, c = this.h1, d = this.h2;
    const u = 3432918353, f = 461845907, g = u & Ws, m = f & Ws;
    for (let y = 0; y < i; y++)
      y & 1 ? (o = r[y], o = o * u & cs | o * g & Ws, o = o << 15 | o >>> 17, o = o * f & cs | o * m & Ws, c ^= o, c = c << 13 | c >>> 19, c = c * 5 + 3864292196) : (l = r[y], l = l * u & cs | l * g & Ws, l = l << 15 | l >>> 17, l = l * f & cs | l * m & Ws, d ^= l, d = d << 13 | d >>> 19, d = d * 5 + 3864292196);
    switch (o = 0, n) {
      case 3:
        o ^= t[i * 4 + 2] << 16;
      case 2:
        o ^= t[i * 4 + 1] << 8;
      case 1:
        o ^= t[i * 4], o = o * u & cs | o * g & Ws, o = o << 15 | o >>> 17, o = o * f & cs | o * m & Ws, i & 1 ? c ^= o : d ^= o;
    }
    this.h1 = c, this.h2 = d;
  }
  hexdigest() {
    let e = this.h1, t = this.h2;
    return e ^= t >>> 1, e = e * 3981806797 & cs | e * 36045 & Ws, t = t * 4283543511 & cs | ((t << 16 | e >>> 16) * 2950163797 & cs) >>> 16, e ^= t >>> 1, e = e * 444984403 & cs | e * 60499 & Ws, t = t * 3301882366 & cs | ((t << 16 | e >>> 16) * 3120437893 & cs) >>> 16, e ^= t >>> 1, (e >>> 0).toString(16).padStart(8, "0") + (t >>> 0).toString(16).padStart(8, "0");
  }
}
const ip = Object.freeze({
  map: null,
  hash: "",
  transfer: void 0
});
var Hr, $r, ie, $u, Nv;
class Dg {
  constructor() {
    b(this, $u);
    b(this, Hr, !1);
    b(this, $r, null);
    b(this, ie, /* @__PURE__ */ new Map());
    this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
  }
  getValue(e, t) {
    const s = a(this, ie).get(e);
    return s === void 0 ? t : Object.assign(t, s);
  }
  getRawValue(e) {
    return a(this, ie).get(e);
  }
  remove(e) {
    if (a(this, ie).delete(e), a(this, ie).size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") {
      for (const t of a(this, ie).values())
        if (t instanceof Ot)
          return;
      this.onAnnotationEditor(null);
    }
  }
  setValue(e, t) {
    const s = a(this, ie).get(e);
    let i = !1;
    if (s !== void 0)
      for (const [n, r] of Object.entries(t))
        s[n] !== r && (i = !0, s[n] = r);
    else
      i = !0, a(this, ie).set(e, t);
    i && v(this, $u, Nv).call(this), t instanceof Ot && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(t.constructor._type);
  }
  has(e) {
    return a(this, ie).has(e);
  }
  getAll() {
    return a(this, ie).size > 0 ? _g(a(this, ie)) : null;
  }
  setAll(e) {
    for (const [t, s] of Object.entries(e))
      this.setValue(t, s);
  }
  get size() {
    return a(this, ie).size;
  }
  resetModified() {
    a(this, Hr) && (p(this, Hr, !1), typeof this.onResetModified == "function" && this.onResetModified());
  }
  get print() {
    return new Dv(this);
  }
  get serializable() {
    if (a(this, ie).size === 0)
      return ip;
    const e = /* @__PURE__ */ new Map(), t = new Ov(), s = [], i = /* @__PURE__ */ Object.create(null);
    let n = !1;
    for (const [r, o] of a(this, ie)) {
      const l = o instanceof Ot ? o.serialize(!1, i) : o;
      l && (e.set(r, l), t.update(`${r}:${JSON.stringify(l)}`), n || (n = !!l.bitmap));
    }
    if (n)
      for (const r of e.values())
        r.bitmap && s.push(r.bitmap);
    return e.size > 0 ? {
      map: e,
      hash: t.hexdigest(),
      transfer: s
    } : ip;
  }
  get editorStats() {
    let e = null;
    const t = /* @__PURE__ */ new Map();
    for (const s of a(this, ie).values()) {
      if (!(s instanceof Ot))
        continue;
      const i = s.telemetryFinalData;
      if (!i)
        continue;
      const {
        type: n
      } = i;
      t.has(n) || t.set(n, Object.getPrototypeOf(s).constructor), e || (e = /* @__PURE__ */ Object.create(null));
      const r = e[n] || (e[n] = /* @__PURE__ */ new Map());
      for (const [o, l] of Object.entries(i)) {
        if (o === "type")
          continue;
        let c = r.get(o);
        c || (c = /* @__PURE__ */ new Map(), r.set(o, c));
        const d = c.get(l) ?? 0;
        c.set(l, d + 1);
      }
    }
    for (const [s, i] of t)
      e[s] = i.computeTelemetryFinalData(e[s]);
    return e;
  }
  resetModifiedIds() {
    p(this, $r, null);
  }
  get modifiedIds() {
    if (a(this, $r))
      return a(this, $r);
    const e = [];
    for (const t of a(this, ie).values())
      !(t instanceof Ot) || !t.annotationElementId || !t.serialize() || e.push(t.annotationElementId);
    return p(this, $r, {
      ids: new Set(e),
      hash: e.join(",")
    });
  }
}
Hr = new WeakMap(), $r = new WeakMap(), ie = new WeakMap(), $u = new WeakSet(), Nv = function() {
  a(this, Hr) || (p(this, Hr, !0), typeof this.onSetModified == "function" && this.onSetModified());
};
var Xh;
class Dv extends Dg {
  constructor(t) {
    super();
    b(this, Xh);
    const {
      map: s,
      hash: i,
      transfer: n
    } = t.serializable, r = structuredClone(s, n ? {
      transfer: n
    } : null);
    p(this, Xh, {
      map: r,
      hash: i,
      transfer: n
    });
  }
  get print() {
    Pt("Should not call PrintAnnotationStorage.print");
  }
  get serializable() {
    return a(this, Xh);
  }
  get modifiedIds() {
    return ht(this, "modifiedIds", {
      ids: /* @__PURE__ */ new Set(),
      hash: ""
    });
  }
}
Xh = new WeakMap();
var Eo;
class IA {
  constructor({
    ownerDocument: e = globalThis.document,
    styleElement: t = null
  }) {
    b(this, Eo, /* @__PURE__ */ new Set());
    this._document = e, this.nativeFontFaces = /* @__PURE__ */ new Set(), this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
  }
  addNativeFontFace(e) {
    this.nativeFontFaces.add(e), this._document.fonts.add(e);
  }
  removeNativeFontFace(e) {
    this.nativeFontFaces.delete(e), this._document.fonts.delete(e);
  }
  insertRule(e) {
    this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement));
    const t = this.styleElement.sheet;
    t.insertRule(e, t.cssRules.length);
  }
  clear() {
    for (const e of this.nativeFontFaces)
      this._document.fonts.delete(e);
    this.nativeFontFaces.clear(), a(this, Eo).clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
  }
  async loadSystemFont({
    systemFontInfo: e,
    _inspectFont: t
  }) {
    if (!(!e || a(this, Eo).has(e.loadedName))) {
      if (Wt(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
        const {
          loadedName: s,
          src: i,
          style: n
        } = e, r = new FontFace(s, i, n);
        this.addNativeFontFace(r);
        try {
          await r.load(), a(this, Eo).add(s), t == null || t(e);
        } catch {
          tt(`Cannot load system font: ${e.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(r);
        }
        return;
      }
      Pt("Not implemented: loadSystemFont without the Font Loading API.");
    }
  }
  async bind(e) {
    if (e.attached || e.missingFile && !e.systemFontInfo)
      return;
    if (e.attached = !0, e.systemFontInfo) {
      await this.loadSystemFont(e);
      return;
    }
    if (this.isFontLoadingAPISupported) {
      const s = e.createNativeFontFace();
      if (s) {
        this.addNativeFontFace(s);
        try {
          await s.loaded;
        } catch (i) {
          throw tt(`Failed to load font '${s.family}': '${i}'.`), e.disableFontFace = !0, i;
        }
      }
      return;
    }
    const t = e.createFontFaceRule();
    if (t) {
      if (this.insertRule(t), this.isSyncFontLoadingSupported)
        return;
      await new Promise((s) => {
        const i = this._queueLoadingCallback(s);
        this._prepareFontLoadEvent(e, i);
      });
    }
  }
  get isFontLoadingAPISupported() {
    var t;
    const e = !!((t = this._document) != null && t.fonts);
    return ht(this, "isFontLoadingAPISupported", e);
  }
  get isSyncFontLoadingSupported() {
    let e = !1;
    return (Te || typeof navigator < "u" && typeof (navigator == null ? void 0 : navigator.userAgent) == "string" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (e = !0), ht(this, "isSyncFontLoadingSupported", e);
  }
  _queueLoadingCallback(e) {
    function t() {
      for (Wt(!i.done, "completeRequest() cannot be called twice."), i.done = !0; s.length > 0 && s[0].done; ) {
        const n = s.shift();
        setTimeout(n.callback, 0);
      }
    }
    const {
      loadingRequests: s
    } = this, i = {
      done: !1,
      complete: t,
      callback: e
    };
    return s.push(i), i;
  }
  get _loadTestFont() {
    const e = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
    return ht(this, "_loadTestFont", e);
  }
  _prepareFontLoadEvent(e, t) {
    function s(T, P) {
      return T.charCodeAt(P) << 24 | T.charCodeAt(P + 1) << 16 | T.charCodeAt(P + 2) << 8 | T.charCodeAt(P + 3) & 255;
    }
    function i(T, P, C, R) {
      const _ = T.substring(0, P), x = T.substring(P + C);
      return _ + R + x;
    }
    let n, r;
    const o = this._document.createElement("canvas");
    o.width = 1, o.height = 1;
    const l = o.getContext("2d");
    let c = 0;
    function d(T, P) {
      if (++c > 30) {
        tt("Load test font never loaded."), P();
        return;
      }
      if (l.font = "30px " + T, l.fillText(".", 0, 20), l.getImageData(0, 0, 1, 1).data[3] > 0) {
        P();
        return;
      }
      setTimeout(d.bind(null, T, P));
    }
    const u = `lt${Date.now()}${this.loadTestFontId++}`;
    let f = this._loadTestFont;
    f = i(f, 976, u.length, u);
    const m = 16, y = 1482184792;
    let w = s(f, m);
    for (n = 0, r = u.length - 3; n < r; n += 4)
      w = w - y + s(u, n) | 0;
    n < u.length && (w = w - y + s(u + "XXX", n) | 0), f = i(f, m, 4, pA(w));
    const A = `url(data:font/opentype;base64,${btoa(f)});`, E = `@font-face {font-family:"${u}";src:${A}}`;
    this.insertRule(E);
    const S = this._document.createElement("div");
    S.style.visibility = "hidden", S.style.width = S.style.height = "10px", S.style.position = "absolute", S.style.top = S.style.left = "0px";
    for (const T of [e.loadedName, u]) {
      const P = this._document.createElement("span");
      P.textContent = "Hi", P.style.fontFamily = T, S.append(P);
    }
    this._document.body.append(S), d(u, () => {
      S.remove(), t.complete();
    });
  }
}
Eo = new WeakMap();
class _A {
  constructor(e, {
    disableFontFace: t = !1,
    fontExtraProperties: s = !1,
    inspectFont: i = null
  }) {
    this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
    for (const n in e)
      this[n] = e[n];
    this.disableFontFace = t === !0, this.fontExtraProperties = s === !0, this._inspectFont = i;
  }
  createNativeFontFace() {
    var t;
    if (!this.data || this.disableFontFace)
      return null;
    let e;
    if (!this.cssFontInfo)
      e = new FontFace(this.loadedName, this.data, {});
    else {
      const s = {
        weight: this.cssFontInfo.fontWeight
      };
      this.cssFontInfo.italicAngle && (s.style = `oblique ${this.cssFontInfo.italicAngle}deg`), e = new FontFace(this.cssFontInfo.fontFamily, this.data, s);
    }
    return (t = this._inspectFont) == null || t.call(this, this), e;
  }
  createFontFaceRule() {
    var s;
    if (!this.data || this.disableFontFace)
      return null;
    const e = `url(data:${this.mimetype};base64,${AA(this.data)});`;
    let t;
    if (!this.cssFontInfo)
      t = `@font-face {font-family:"${this.loadedName}";src:${e}}`;
    else {
      let i = `font-weight: ${this.cssFontInfo.fontWeight};`;
      this.cssFontInfo.italicAngle && (i += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), t = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${i}src:${e}}`;
    }
    return (s = this._inspectFont) == null || s.call(this, this, e), t;
  }
  getPathGenerator(e, t) {
    if (this.compiledGlyphs[t] !== void 0)
      return this.compiledGlyphs[t];
    const s = this.loadedName + "_path_" + t;
    let i;
    try {
      i = e.get(s);
    } catch (r) {
      tt(`getPathGenerator - ignoring character: "${r}".`);
    }
    const n = new Path2D(i || "");
    return this.fontExtraProperties || e.delete(s), this.compiledGlyphs[t] = n;
  }
}
const Pd = {
  DATA: 1,
  ERROR: 2
}, zt = {
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};
function tm() {
}
function Fe(h) {
  if (h instanceof dr || h instanceof kf || h instanceof mh || h instanceof Qg || h instanceof Tu || h instanceof vf)
    return h;
  switch (h instanceof Error || typeof h == "object" && h !== null || Pt('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), h.name) {
    case "AbortException":
      return new dr(h.message);
    case "InvalidPDFException":
      return new kf(h.message);
    case "MissingPDFException":
      return new mh(h.message);
    case "PasswordException":
      return new Qg(h.message, h.code);
    case "UnexpectedResponseException":
      return new Tu(h.message, h.status);
    case "UnknownErrorException":
      return new vf(h.message, h.details);
  }
  return new vf(h.message, h.toString());
}
var So, Es, kv, Fv, Bv, Gd;
class Xl {
  constructor(e, t, s) {
    b(this, Es);
    b(this, So, new AbortController());
    this.sourceName = e, this.targetName = t, this.comObj = s, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), s.addEventListener("message", v(this, Es, kv).bind(this), {
      signal: a(this, So).signal
    });
  }
  on(e, t) {
    const s = this.actionHandler;
    if (s[e])
      throw new Error(`There is already an actionName called "${e}"`);
    s[e] = t;
  }
  send(e, t, s) {
    this.comObj.postMessage({
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: e,
      data: t
    }, s);
  }
  sendWithPromise(e, t, s) {
    const i = this.callbackId++, n = Promise.withResolvers();
    this.callbackCapabilities[i] = n;
    try {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: e,
        callbackId: i,
        data: t
      }, s);
    } catch (r) {
      n.reject(r);
    }
    return n.promise;
  }
  sendWithStream(e, t, s, i) {
    const n = this.streamId++, r = this.sourceName, o = this.targetName, l = this.comObj;
    return new ReadableStream({
      start: (c) => {
        const d = Promise.withResolvers();
        return this.streamControllers[n] = {
          controller: c,
          startCall: d,
          pullCall: null,
          cancelCall: null,
          isClosed: !1
        }, l.postMessage({
          sourceName: r,
          targetName: o,
          action: e,
          streamId: n,
          data: t,
          desiredSize: c.desiredSize
        }, i), d.promise;
      },
      pull: (c) => {
        const d = Promise.withResolvers();
        return this.streamControllers[n].pullCall = d, l.postMessage({
          sourceName: r,
          targetName: o,
          stream: zt.PULL,
          streamId: n,
          desiredSize: c.desiredSize
        }), d.promise;
      },
      cancel: (c) => {
        Wt(c instanceof Error, "cancel must have a valid reason");
        const d = Promise.withResolvers();
        return this.streamControllers[n].cancelCall = d, this.streamControllers[n].isClosed = !0, l.postMessage({
          sourceName: r,
          targetName: o,
          stream: zt.CANCEL,
          streamId: n,
          reason: Fe(c)
        }), d.promise;
      }
    }, s);
  }
  destroy() {
    var e;
    (e = a(this, So)) == null || e.abort(), p(this, So, null);
  }
}
So = new WeakMap(), Es = new WeakSet(), kv = function({
  data: e
}) {
  if (e.targetName !== this.sourceName)
    return;
  if (e.stream) {
    v(this, Es, Bv).call(this, e);
    return;
  }
  if (e.callback) {
    const s = e.callbackId, i = this.callbackCapabilities[s];
    if (!i)
      throw new Error(`Cannot resolve callback ${s}`);
    if (delete this.callbackCapabilities[s], e.callback === Pd.DATA)
      i.resolve(e.data);
    else if (e.callback === Pd.ERROR)
      i.reject(Fe(e.reason));
    else
      throw new Error("Unexpected callback case");
    return;
  }
  const t = this.actionHandler[e.action];
  if (!t)
    throw new Error(`Unknown action from worker: ${e.action}`);
  if (e.callbackId) {
    const s = this.sourceName, i = e.sourceName, n = this.comObj;
    Promise.try(t, e.data).then(function(r) {
      n.postMessage({
        sourceName: s,
        targetName: i,
        callback: Pd.DATA,
        callbackId: e.callbackId,
        data: r
      });
    }, function(r) {
      n.postMessage({
        sourceName: s,
        targetName: i,
        callback: Pd.ERROR,
        callbackId: e.callbackId,
        reason: Fe(r)
      });
    });
    return;
  }
  if (e.streamId) {
    v(this, Es, Fv).call(this, e);
    return;
  }
  t(e.data);
}, Fv = function(e) {
  const t = e.streamId, s = this.sourceName, i = e.sourceName, n = this.comObj, r = this, o = this.actionHandler[e.action], l = {
    enqueue(c, d = 1, u) {
      if (this.isCancelled)
        return;
      const f = this.desiredSize;
      this.desiredSize -= d, f > 0 && this.desiredSize <= 0 && (this.sinkCapability = Promise.withResolvers(), this.ready = this.sinkCapability.promise), n.postMessage({
        sourceName: s,
        targetName: i,
        stream: zt.ENQUEUE,
        streamId: t,
        chunk: c
      }, u);
    },
    close() {
      this.isCancelled || (this.isCancelled = !0, n.postMessage({
        sourceName: s,
        targetName: i,
        stream: zt.CLOSE,
        streamId: t
      }), delete r.streamSinks[t]);
    },
    error(c) {
      Wt(c instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, n.postMessage({
        sourceName: s,
        targetName: i,
        stream: zt.ERROR,
        streamId: t,
        reason: Fe(c)
      }));
    },
    sinkCapability: Promise.withResolvers(),
    onPull: null,
    onCancel: null,
    isCancelled: !1,
    desiredSize: e.desiredSize,
    ready: null
  };
  l.sinkCapability.resolve(), l.ready = l.sinkCapability.promise, this.streamSinks[t] = l, Promise.try(o, e.data, l).then(function() {
    n.postMessage({
      sourceName: s,
      targetName: i,
      stream: zt.START_COMPLETE,
      streamId: t,
      success: !0
    });
  }, function(c) {
    n.postMessage({
      sourceName: s,
      targetName: i,
      stream: zt.START_COMPLETE,
      streamId: t,
      reason: Fe(c)
    });
  });
}, Bv = function(e) {
  const t = e.streamId, s = this.sourceName, i = e.sourceName, n = this.comObj, r = this.streamControllers[t], o = this.streamSinks[t];
  switch (e.stream) {
    case zt.START_COMPLETE:
      e.success ? r.startCall.resolve() : r.startCall.reject(Fe(e.reason));
      break;
    case zt.PULL_COMPLETE:
      e.success ? r.pullCall.resolve() : r.pullCall.reject(Fe(e.reason));
      break;
    case zt.PULL:
      if (!o) {
        n.postMessage({
          sourceName: s,
          targetName: i,
          stream: zt.PULL_COMPLETE,
          streamId: t,
          success: !0
        });
        break;
      }
      o.desiredSize <= 0 && e.desiredSize > 0 && o.sinkCapability.resolve(), o.desiredSize = e.desiredSize, Promise.try(o.onPull || tm).then(function() {
        n.postMessage({
          sourceName: s,
          targetName: i,
          stream: zt.PULL_COMPLETE,
          streamId: t,
          success: !0
        });
      }, function(c) {
        n.postMessage({
          sourceName: s,
          targetName: i,
          stream: zt.PULL_COMPLETE,
          streamId: t,
          reason: Fe(c)
        });
      });
      break;
    case zt.ENQUEUE:
      if (Wt(r, "enqueue should have stream controller"), r.isClosed)
        break;
      r.controller.enqueue(e.chunk);
      break;
    case zt.CLOSE:
      if (Wt(r, "close should have stream controller"), r.isClosed)
        break;
      r.isClosed = !0, r.controller.close(), v(this, Es, Gd).call(this, r, t);
      break;
    case zt.ERROR:
      Wt(r, "error should have stream controller"), r.controller.error(Fe(e.reason)), v(this, Es, Gd).call(this, r, t);
      break;
    case zt.CANCEL_COMPLETE:
      e.success ? r.cancelCall.resolve() : r.cancelCall.reject(Fe(e.reason)), v(this, Es, Gd).call(this, r, t);
      break;
    case zt.CANCEL:
      if (!o)
        break;
      const l = Fe(e.reason);
      Promise.try(o.onCancel || tm, l).then(function() {
        n.postMessage({
          sourceName: s,
          targetName: i,
          stream: zt.CANCEL_COMPLETE,
          streamId: t,
          success: !0
        });
      }, function(c) {
        n.postMessage({
          sourceName: s,
          targetName: i,
          stream: zt.CANCEL_COMPLETE,
          streamId: t,
          reason: Fe(c)
        });
      }), o.sinkCapability.reject(l), o.isCancelled = !0, delete this.streamSinks[t];
      break;
    default:
      throw new Error("Unexpected stream case");
  }
}, Gd = async function(e, t) {
  var s, i, n;
  await Promise.allSettled([(s = e.startCall) == null ? void 0 : s.promise, (i = e.pullCall) == null ? void 0 : i.promise, (n = e.cancelCall) == null ? void 0 : n.promise]), delete this.streamControllers[t];
};
var Yh;
class jv {
  constructor({
    enableHWA: e = !1
  }) {
    b(this, Yh, !1);
    p(this, Yh, e);
  }
  create(e, t) {
    if (e <= 0 || t <= 0)
      throw new Error("Invalid canvas size");
    const s = this._createCanvas(e, t);
    return {
      canvas: s,
      context: s.getContext("2d", {
        willReadFrequently: !a(this, Yh)
      })
    };
  }
  reset(e, t, s) {
    if (!e.canvas)
      throw new Error("Canvas is not specified");
    if (t <= 0 || s <= 0)
      throw new Error("Invalid canvas size");
    e.canvas.width = t, e.canvas.height = s;
  }
  destroy(e) {
    if (!e.canvas)
      throw new Error("Canvas is not specified");
    e.canvas.width = 0, e.canvas.height = 0, e.canvas = null, e.context = null;
  }
  _createCanvas(e, t) {
    Pt("Abstract method `_createCanvas` called.");
  }
}
Yh = new WeakMap();
class LA extends jv {
  constructor({
    ownerDocument: e = globalThis.document,
    enableHWA: t = !1
  }) {
    super({
      enableHWA: t
    }), this._document = e;
  }
  _createCanvas(e, t) {
    const s = this._document.createElement("canvas");
    return s.width = e, s.height = t, s;
  }
}
class Hv {
  constructor({
    baseUrl: e = null,
    isCompressed: t = !0
  }) {
    this.baseUrl = e, this.isCompressed = t;
  }
  async fetch({
    name: e
  }) {
    if (!this.baseUrl)
      throw new Error("Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.");
    if (!e)
      throw new Error("CMap name must be specified.");
    const t = this.baseUrl + e + (this.isCompressed ? ".bcmap" : "");
    return this._fetch(t).then((s) => ({
      cMapData: s,
      isCompressed: this.isCompressed
    })).catch((s) => {
      throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${t}`);
    });
  }
  async _fetch(e) {
    Pt("Abstract method `_fetch` called.");
  }
}
class $v extends Hv {
  async _fetch(e) {
    const t = await lf(e, this.isCompressed ? "arraybuffer" : "text");
    return t instanceof ArrayBuffer ? new Uint8Array(t) : of(t);
  }
}
ut(4520);
class Vv {
  addFilter(e) {
    return "none";
  }
  addHCMFilter(e, t) {
    return "none";
  }
  addAlphaFilter(e) {
    return "none";
  }
  addLuminosityFilter(e) {
    return "none";
  }
  addHighlightHCMFilter(e, t, s, i, n) {
    return "none";
  }
  destroy(e = !1) {
  }
}
var Vr, xo, Ni, Di, Ae, Ur, zr, V, be, Yl, Xa, Xd, Ya, Uv, np, Ka, Kl, Ql, rp, Zl;
class MA extends Vv {
  constructor({
    docId: t,
    ownerDocument: s = globalThis.document
  }) {
    super();
    b(this, V);
    b(this, Vr);
    b(this, xo);
    b(this, Ni);
    b(this, Di);
    b(this, Ae);
    b(this, Ur);
    b(this, zr, 0);
    p(this, Di, t), p(this, Ae, s);
  }
  addFilter(t) {
    if (!t)
      return "none";
    let s = a(this, V, be).get(t);
    if (s)
      return s;
    const [i, n, r] = v(this, V, Xd).call(this, t), o = t.length === 1 ? i : `${i}${n}${r}`;
    if (s = a(this, V, be).get(o), s)
      return a(this, V, be).set(t, s), s;
    const l = `g_${a(this, Di)}_transfer_map_${me(this, zr)._++}`, c = v(this, V, Ya).call(this, l);
    a(this, V, be).set(t, c), a(this, V, be).set(o, c);
    const d = v(this, V, Ka).call(this, l);
    return v(this, V, Ql).call(this, i, n, r, d), c;
  }
  addHCMFilter(t, s) {
    var m;
    const i = `${t}-${s}`, n = "base";
    let r = a(this, V, Yl).get(n);
    if ((r == null ? void 0 : r.key) === i || (r ? ((m = r.filter) == null || m.remove(), r.key = i, r.url = "none", r.filter = null) : (r = {
      key: i,
      url: "none",
      filter: null
    }, a(this, V, Yl).set(n, r)), !t || !s))
      return r.url;
    const o = v(this, V, Zl).call(this, t);
    t = X.makeHexColor(...o);
    const l = v(this, V, Zl).call(this, s);
    if (s = X.makeHexColor(...l), a(this, V, Xa).style.color = "", t === "#000000" && s === "#ffffff" || t === s)
      return r.url;
    const c = new Array(256);
    for (let y = 0; y <= 255; y++) {
      const w = y / 255;
      c[y] = w <= 0.03928 ? w / 12.92 : ((w + 0.055) / 1.055) ** 2.4;
    }
    const d = c.join(","), u = `g_${a(this, Di)}_hcm_filter`, f = r.filter = v(this, V, Ka).call(this, u);
    v(this, V, Ql).call(this, d, d, d, f), v(this, V, np).call(this, f);
    const g = (y, w) => {
      const A = o[y] / 255, E = l[y] / 255, S = new Array(w + 1);
      for (let T = 0; T <= w; T++)
        S[T] = A + T / w * (E - A);
      return S.join(",");
    };
    return v(this, V, Ql).call(this, g(0, 5), g(1, 5), g(2, 5), f), r.url = v(this, V, Ya).call(this, u), r.url;
  }
  addAlphaFilter(t) {
    let s = a(this, V, be).get(t);
    if (s)
      return s;
    const [i] = v(this, V, Xd).call(this, [t]), n = `alpha_${i}`;
    if (s = a(this, V, be).get(n), s)
      return a(this, V, be).set(t, s), s;
    const r = `g_${a(this, Di)}_alpha_map_${me(this, zr)._++}`, o = v(this, V, Ya).call(this, r);
    a(this, V, be).set(t, o), a(this, V, be).set(n, o);
    const l = v(this, V, Ka).call(this, r);
    return v(this, V, rp).call(this, i, l), o;
  }
  addLuminosityFilter(t) {
    let s = a(this, V, be).get(t || "luminosity");
    if (s)
      return s;
    let i, n;
    if (t ? ([i] = v(this, V, Xd).call(this, [t]), n = `luminosity_${i}`) : n = "luminosity", s = a(this, V, be).get(n), s)
      return a(this, V, be).set(t, s), s;
    const r = `g_${a(this, Di)}_luminosity_map_${me(this, zr)._++}`, o = v(this, V, Ya).call(this, r);
    a(this, V, be).set(t, o), a(this, V, be).set(n, o);
    const l = v(this, V, Ka).call(this, r);
    return v(this, V, Uv).call(this, l), t && v(this, V, rp).call(this, i, l), o;
  }
  addHighlightHCMFilter(t, s, i, n, r) {
    var E;
    const o = `${s}-${i}-${n}-${r}`;
    let l = a(this, V, Yl).get(t);
    if ((l == null ? void 0 : l.key) === o || (l ? ((E = l.filter) == null || E.remove(), l.key = o, l.url = "none", l.filter = null) : (l = {
      key: o,
      url: "none",
      filter: null
    }, a(this, V, Yl).set(t, l)), !s || !i))
      return l.url;
    const [c, d] = [s, i].map(v(this, V, Zl).bind(this));
    let u = Math.round(0.2126 * c[0] + 0.7152 * c[1] + 0.0722 * c[2]), f = Math.round(0.2126 * d[0] + 0.7152 * d[1] + 0.0722 * d[2]), [g, m] = [n, r].map(v(this, V, Zl).bind(this));
    f < u && ([u, f, g, m] = [f, u, m, g]), a(this, V, Xa).style.color = "";
    const y = (S, T, P) => {
      const C = new Array(256), R = (f - u) / P, _ = S / 255, x = (T - S) / (255 * P);
      let I = 0;
      for (let L = 0; L <= P; L++) {
        const j = Math.round(u + L * R), k = _ + L * x;
        for (let F = I; F <= j; F++)
          C[F] = k;
        I = j + 1;
      }
      for (let L = I; L < 256; L++)
        C[L] = C[I - 1];
      return C.join(",");
    }, w = `g_${a(this, Di)}_hcm_${t}_filter`, A = l.filter = v(this, V, Ka).call(this, w);
    return v(this, V, np).call(this, A), v(this, V, Ql).call(this, y(g[0], m[0], 5), y(g[1], m[1], 5), y(g[2], m[2], 5), A), l.url = v(this, V, Ya).call(this, w), l.url;
  }
  destroy(t = !1) {
    var s, i, n, r;
    t && ((s = a(this, Ur)) != null && s.size) || ((i = a(this, Ni)) == null || i.parentNode.parentNode.remove(), p(this, Ni, null), (n = a(this, xo)) == null || n.clear(), p(this, xo, null), (r = a(this, Ur)) == null || r.clear(), p(this, Ur, null), p(this, zr, 0));
  }
}
Vr = new WeakMap(), xo = new WeakMap(), Ni = new WeakMap(), Di = new WeakMap(), Ae = new WeakMap(), Ur = new WeakMap(), zr = new WeakMap(), V = new WeakSet(), be = function() {
  return a(this, xo) || p(this, xo, /* @__PURE__ */ new Map());
}, Yl = function() {
  return a(this, Ur) || p(this, Ur, /* @__PURE__ */ new Map());
}, Xa = function() {
  if (!a(this, Ni)) {
    const t = a(this, Ae).createElement("div"), {
      style: s
    } = t;
    s.visibility = "hidden", s.contain = "strict", s.width = s.height = 0, s.position = "absolute", s.top = s.left = 0, s.zIndex = -1;
    const i = a(this, Ae).createElementNS(Ai, "svg");
    i.setAttribute("width", 0), i.setAttribute("height", 0), p(this, Ni, a(this, Ae).createElementNS(Ai, "defs")), t.append(i), i.append(a(this, Ni)), a(this, Ae).body.append(t);
  }
  return a(this, Ni);
}, Xd = function(t) {
  if (t.length === 1) {
    const c = t[0], d = new Array(256);
    for (let f = 0; f < 256; f++)
      d[f] = c[f] / 255;
    const u = d.join(",");
    return [u, u, u];
  }
  const [s, i, n] = t, r = new Array(256), o = new Array(256), l = new Array(256);
  for (let c = 0; c < 256; c++)
    r[c] = s[c] / 255, o[c] = i[c] / 255, l[c] = n[c] / 255;
  return [r.join(","), o.join(","), l.join(",")];
}, Ya = function(t) {
  if (a(this, Vr) === void 0) {
    p(this, Vr, "");
    const s = a(this, Ae).URL;
    s !== a(this, Ae).baseURI && (hf(s) ? tt('#createUrl: ignore "data:"-URL for performance reasons.') : p(this, Vr, s.split("#", 1)[0]));
  }
  return `url(${a(this, Vr)}#${t})`;
}, Uv = function(t) {
  const s = a(this, Ae).createElementNS(Ai, "feColorMatrix");
  s.setAttribute("type", "matrix"), s.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0"), t.append(s);
}, np = function(t) {
  const s = a(this, Ae).createElementNS(Ai, "feColorMatrix");
  s.setAttribute("type", "matrix"), s.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), t.append(s);
}, Ka = function(t) {
  const s = a(this, Ae).createElementNS(Ai, "filter");
  return s.setAttribute("color-interpolation-filters", "sRGB"), s.setAttribute("id", t), a(this, V, Xa).append(s), s;
}, Kl = function(t, s, i) {
  const n = a(this, Ae).createElementNS(Ai, s);
  n.setAttribute("type", "discrete"), n.setAttribute("tableValues", i), t.append(n);
}, Ql = function(t, s, i, n) {
  const r = a(this, Ae).createElementNS(Ai, "feComponentTransfer");
  n.append(r), v(this, V, Kl).call(this, r, "feFuncR", t), v(this, V, Kl).call(this, r, "feFuncG", s), v(this, V, Kl).call(this, r, "feFuncB", i);
}, rp = function(t, s) {
  const i = a(this, Ae).createElementNS(Ai, "feComponentTransfer");
  s.append(i), v(this, V, Kl).call(this, i, "feFuncA", t);
}, Zl = function(t) {
  return a(this, V, Xa).style.color = t, Ng(getComputedStyle(a(this, V, Xa)).getPropertyValue("color"));
};
class zv {
  constructor({
    baseUrl: e = null
  }) {
    this.baseUrl = e;
  }
  async fetch({
    filename: e
  }) {
    if (!this.baseUrl)
      throw new Error("Ensure that the `standardFontDataUrl` API parameter is provided.");
    if (!e)
      throw new Error("Font filename must be specified.");
    const t = `${this.baseUrl}${e}`;
    return this._fetch(t).catch((s) => {
      throw new Error(`Unable to load font data at: ${t}`);
    });
  }
  async _fetch(e) {
    Pt("Abstract method `_fetch` called.");
  }
}
class Wv extends zv {
  async _fetch(e) {
    const t = await lf(e, "arraybuffer");
    return new Uint8Array(t);
  }
}
if (Te) {
  let h;
  try {
    const e = process.getBuiltinModule("module").createRequire(import.meta.url);
    try {
      h = e("@napi-rs/canvas");
    } catch (t) {
      tt(`Cannot load "@napi-rs/canvas" package: "${t}".`);
    }
  } catch (e) {
    tt(`Cannot access the \`require\` function: "${e}".`);
  }
  globalThis.DOMMatrix || (h != null && h.DOMMatrix ? globalThis.DOMMatrix = h.DOMMatrix : tt("Cannot polyfill `DOMMatrix`, rendering may be broken.")), globalThis.ImageData || (h != null && h.ImageData ? globalThis.ImageData = h.ImageData : tt("Cannot polyfill `ImageData`, rendering may be broken.")), globalThis.Path2D || (h != null && h.Path2D ? globalThis.Path2D = h.Path2D : tt("Cannot polyfill `Path2D`, rendering may be broken."));
}
async function Gv(h) {
  const t = await process.getBuiltinModule("fs").promises.readFile(h);
  return new Uint8Array(t);
}
class OA extends Vv {
}
class NA extends jv {
  _createCanvas(e, t) {
    return process.getBuiltinModule("module").createRequire(import.meta.url)("@napi-rs/canvas").createCanvas(e, t);
  }
}
class DA extends Hv {
  async _fetch(e) {
    return Gv(e);
  }
}
class kA extends zv {
  async _fetch(e) {
    return Gv(e);
  }
}
const xe = {
  FILL: "Fill",
  STROKE: "Stroke",
  SHADING: "Shading"
};
function ap(h, e) {
  if (!e)
    return;
  const t = e[2] - e[0], s = e[3] - e[1], i = new Path2D();
  i.rect(e[0], e[1], t, s), h.clip(i);
}
class kg {
  getPattern() {
    Pt("Abstract method `getPattern` called.");
  }
}
class FA extends kg {
  constructor(e) {
    super(), this._type = e[1], this._bbox = e[2], this._colorStops = e[3], this._p0 = e[4], this._p1 = e[5], this._r0 = e[6], this._r1 = e[7], this.matrix = null;
  }
  _createGradient(e) {
    let t;
    this._type === "axial" ? t = e.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (t = e.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
    for (const s of this._colorStops)
      t.addColorStop(s[0], s[1]);
    return t;
  }
  getPattern(e, t, s, i) {
    let n;
    if (i === xe.STROKE || i === xe.FILL) {
      const r = t.current.getClippedPathBoundingBox(i, It(e)) || [0, 0, 0, 0], o = Math.ceil(r[2] - r[0]) || 1, l = Math.ceil(r[3] - r[1]) || 1, c = t.cachedCanvases.getCanvas("pattern", o, l), d = c.context;
      d.clearRect(0, 0, d.canvas.width, d.canvas.height), d.beginPath(), d.rect(0, 0, d.canvas.width, d.canvas.height), d.translate(-r[0], -r[1]), s = X.transform(s, [1, 0, 0, 1, r[0], r[1]]), d.transform(...t.baseTransform), this.matrix && d.transform(...this.matrix), ap(d, this._bbox), d.fillStyle = this._createGradient(d), d.fill(), n = e.createPattern(c.canvas, "no-repeat");
      const u = new DOMMatrix(s);
      n.setTransform(u);
    } else
      ap(e, this._bbox), n = this._createGradient(e);
    return n;
  }
}
function Af(h, e, t, s, i, n, r, o) {
  const l = e.coords, c = e.colors, d = h.data, u = h.width * 4;
  let f;
  l[t + 1] > l[s + 1] && (f = t, t = s, s = f, f = n, n = r, r = f), l[s + 1] > l[i + 1] && (f = s, s = i, i = f, f = r, r = o, o = f), l[t + 1] > l[s + 1] && (f = t, t = s, s = f, f = n, n = r, r = f);
  const g = (l[t] + e.offsetX) * e.scaleX, m = (l[t + 1] + e.offsetY) * e.scaleY, y = (l[s] + e.offsetX) * e.scaleX, w = (l[s + 1] + e.offsetY) * e.scaleY, A = (l[i] + e.offsetX) * e.scaleX, E = (l[i + 1] + e.offsetY) * e.scaleY;
  if (m >= E)
    return;
  const S = c[n], T = c[n + 1], P = c[n + 2], C = c[r], R = c[r + 1], _ = c[r + 2], x = c[o], I = c[o + 1], L = c[o + 2], j = Math.round(m), k = Math.round(E);
  let F, Y, N, D, et, ft, Et, Dt;
  for (let yt = j; yt <= k; yt++) {
    if (yt < w) {
      const O = yt < m ? 0 : (m - yt) / (m - w);
      F = g - (g - y) * O, Y = S - (S - C) * O, N = T - (T - R) * O, D = P - (P - _) * O;
    } else {
      let O;
      yt > E ? O = 1 : w === E ? O = 0 : O = (w - yt) / (w - E), F = y - (y - A) * O, Y = C - (C - x) * O, N = R - (R - I) * O, D = _ - (_ - L) * O;
    }
    let St;
    yt < m ? St = 0 : yt > E ? St = 1 : St = (m - yt) / (m - E), et = g - (g - A) * St, ft = S - (S - x) * St, Et = T - (T - I) * St, Dt = P - (P - L) * St;
    const $s = Math.round(Math.min(F, et)), Vs = Math.round(Math.max(F, et));
    let $ = u * yt + $s * 4;
    for (let O = $s; O <= Vs; O++)
      St = (F - O) / (F - et), St < 0 ? St = 0 : St > 1 && (St = 1), d[$++] = Y - (Y - ft) * St | 0, d[$++] = N - (N - Et) * St | 0, d[$++] = D - (D - Dt) * St | 0, d[$++] = 255;
  }
}
function BA(h, e, t) {
  const s = e.coords, i = e.colors;
  let n, r;
  switch (e.type) {
    case "lattice":
      const o = e.verticesPerRow, l = Math.floor(s.length / o) - 1, c = o - 1;
      for (n = 0; n < l; n++) {
        let d = n * o;
        for (let u = 0; u < c; u++, d++)
          Af(h, t, s[d], s[d + 1], s[d + o], i[d], i[d + 1], i[d + o]), Af(h, t, s[d + o + 1], s[d + 1], s[d + o], i[d + o + 1], i[d + 1], i[d + o]);
      }
      break;
    case "triangles":
      for (n = 0, r = s.length; n < r; n += 3)
        Af(h, t, s[n], s[n + 1], s[n + 2], i[n], i[n + 1], i[n + 2]);
      break;
    default:
      throw new Error("illegal figure");
  }
}
class jA extends kg {
  constructor(e) {
    super(), this._coords = e[2], this._colors = e[3], this._figures = e[4], this._bounds = e[5], this._bbox = e[7], this._background = e[8], this.matrix = null;
  }
  _createMeshCanvas(e, t, s) {
    const o = Math.floor(this._bounds[0]), l = Math.floor(this._bounds[1]), c = Math.ceil(this._bounds[2]) - o, d = Math.ceil(this._bounds[3]) - l, u = Math.min(Math.ceil(Math.abs(c * e[0] * 1.1)), 3e3), f = Math.min(Math.ceil(Math.abs(d * e[1] * 1.1)), 3e3), g = c / u, m = d / f, y = {
      coords: this._coords,
      colors: this._colors,
      offsetX: -o,
      offsetY: -l,
      scaleX: 1 / g,
      scaleY: 1 / m
    }, w = u + 2 * 2, A = f + 2 * 2, E = s.getCanvas("mesh", w, A), S = E.context, T = S.createImageData(u, f);
    if (t) {
      const C = T.data;
      for (let R = 0, _ = C.length; R < _; R += 4)
        C[R] = t[0], C[R + 1] = t[1], C[R + 2] = t[2], C[R + 3] = 255;
    }
    for (const C of this._figures)
      BA(T, C, y);
    return S.putImageData(T, 2, 2), {
      canvas: E.canvas,
      offsetX: o - 2 * g,
      offsetY: l - 2 * m,
      scaleX: g,
      scaleY: m
    };
  }
  getPattern(e, t, s, i) {
    ap(e, this._bbox);
    let n;
    if (i === xe.SHADING)
      n = X.singularValueDecompose2dScale(It(e));
    else if (n = X.singularValueDecompose2dScale(t.baseTransform), this.matrix) {
      const o = X.singularValueDecompose2dScale(this.matrix);
      n = [n[0] * o[0], n[1] * o[1]];
    }
    const r = this._createMeshCanvas(n, i === xe.SHADING ? null : this._background, t.cachedCanvases);
    return i !== xe.SHADING && (e.setTransform(...t.baseTransform), this.matrix && e.transform(...this.matrix)), e.translate(r.offsetX, r.offsetY), e.scale(r.scaleX, r.scaleY), e.createPattern(r.canvas, "no-repeat");
  }
}
class HA extends kg {
  getPattern() {
    return "hotpink";
  }
}
function $A(h) {
  switch (h[0]) {
    case "RadialAxial":
      return new FA(h);
    case "Mesh":
      return new jA(h);
    case "Dummy":
      return new HA();
  }
  throw new Error(`Unknown IR type: ${h[0]}`);
}
const em = {
  COLORED: 1,
  UNCOLORED: 2
}, Vu = class Vu {
  constructor(e, t, s, i, n) {
    this.operatorList = e[2], this.matrix = e[3], this.bbox = e[4], this.xstep = e[5], this.ystep = e[6], this.paintType = e[7], this.tilingType = e[8], this.color = t, this.ctx = s, this.canvasGraphicsFactory = i, this.baseTransform = n;
  }
  createPatternCanvas(e) {
    const {
      bbox: t,
      operatorList: s,
      paintType: i,
      tilingType: n,
      color: r,
      canvasGraphicsFactory: o
    } = this;
    let {
      xstep: l,
      ystep: c
    } = this;
    l = Math.abs(l), c = Math.abs(c), af("TilingType: " + n);
    const d = t[0], u = t[1], f = t[2], g = t[3], m = f - d, y = g - u, w = X.singularValueDecompose2dScale(this.matrix), A = X.singularValueDecompose2dScale(this.baseTransform), E = w[0] * A[0], S = w[1] * A[1];
    let T = m, P = y, C = !1, R = !1;
    const _ = Math.ceil(l * E), x = Math.ceil(c * S), I = Math.ceil(m * E), L = Math.ceil(y * S);
    _ >= I ? T = l : C = !0, x >= L ? P = c : R = !0;
    const j = this.getSizeAndScale(T, this.ctx.canvas.width, E), k = this.getSizeAndScale(P, this.ctx.canvas.height, S), F = e.cachedCanvases.getCanvas("pattern", j.size, k.size), Y = F.context, N = o.createCanvasGraphics(Y);
    if (N.groupLevel = e.groupLevel, this.setFillAndStrokeStyleToContext(N, i, r), Y.translate(-j.scale * d, -k.scale * u), N.transform(j.scale, 0, 0, k.scale, 0, 0), Y.save(), this.clipBbox(N, d, u, f, g), N.baseTransform = It(N.ctx), N.executeOperatorList(s), N.endDrawing(), Y.restore(), C || R) {
      const D = F.canvas;
      C && (T = l), R && (P = c);
      const et = this.getSizeAndScale(T, this.ctx.canvas.width, E), ft = this.getSizeAndScale(P, this.ctx.canvas.height, S), Et = et.size, Dt = ft.size, yt = e.cachedCanvases.getCanvas("pattern-workaround", Et, Dt), St = yt.context, $s = C ? Math.floor(m / l) : 0, Vs = R ? Math.floor(y / c) : 0;
      for (let $ = 0; $ <= $s; $++)
        for (let O = 0; O <= Vs; O++)
          St.drawImage(D, Et * $, Dt * O, Et, Dt, 0, 0, Et, Dt);
      return {
        canvas: yt.canvas,
        scaleX: et.scale,
        scaleY: ft.scale,
        offsetX: d,
        offsetY: u
      };
    }
    return {
      canvas: F.canvas,
      scaleX: j.scale,
      scaleY: k.scale,
      offsetX: d,
      offsetY: u
    };
  }
  getSizeAndScale(e, t, s) {
    const i = Math.max(Vu.MAX_PATTERN_SIZE, t);
    let n = Math.ceil(e * s);
    return n >= i ? n = i : s = n / e, {
      scale: s,
      size: n
    };
  }
  clipBbox(e, t, s, i, n) {
    const r = i - t, o = n - s;
    e.ctx.rect(t, s, r, o), e.current.updateRectMinMax(It(e.ctx), [t, s, i, n]), e.clip(), e.endPath();
  }
  setFillAndStrokeStyleToContext(e, t, s) {
    const i = e.ctx, n = e.current;
    switch (t) {
      case em.COLORED:
        const r = this.ctx;
        i.fillStyle = r.fillStyle, i.strokeStyle = r.strokeStyle, n.fillColor = r.fillStyle, n.strokeColor = r.strokeStyle;
        break;
      case em.UNCOLORED:
        const o = X.makeHexColor(s[0], s[1], s[2]);
        i.fillStyle = o, i.strokeStyle = o, n.fillColor = o, n.strokeColor = o;
        break;
      default:
        throw new fA(`Unsupported paint type: ${t}`);
    }
  }
  getPattern(e, t, s, i) {
    let n = s;
    i !== xe.SHADING && (n = X.transform(n, t.baseTransform), this.matrix && (n = X.transform(n, this.matrix)));
    const r = this.createPatternCanvas(t);
    let o = new DOMMatrix(n);
    o = o.translate(r.offsetX, r.offsetY), o = o.scale(1 / r.scaleX, 1 / r.scaleY);
    const l = e.createPattern(r.canvas, "repeat");
    return l.setTransform(o), l;
  }
};
K(Vu, "MAX_PATTERN_SIZE", 3e3);
let op = Vu;
function VA({
  src: h,
  srcPos: e = 0,
  dest: t,
  width: s,
  height: i,
  nonBlackColor: n = 4294967295,
  inverseDecode: r = !1
}) {
  const o = Oe.isLittleEndian ? 4278190080 : 255, [l, c] = r ? [n, o] : [o, n], d = s >> 3, u = s & 7, f = h.length;
  t = new Uint32Array(t.buffer);
  let g = 0;
  for (let m = 0; m < i; m++) {
    for (const w = e + d; e < w; e++) {
      const A = e < f ? h[e] : 255;
      t[g++] = A & 128 ? c : l, t[g++] = A & 64 ? c : l, t[g++] = A & 32 ? c : l, t[g++] = A & 16 ? c : l, t[g++] = A & 8 ? c : l, t[g++] = A & 4 ? c : l, t[g++] = A & 2 ? c : l, t[g++] = A & 1 ? c : l;
    }
    if (u === 0)
      continue;
    const y = e < f ? h[e++] : 255;
    for (let w = 0; w < u; w++)
      t[g++] = y & 1 << 7 - w ? c : l;
  }
  return {
    srcPos: e,
    destPos: g
  };
}
const sm = 16, im = 100, UA = 15, nm = 10, rm = 1e3, Ue = 16;
function zA(h, e) {
  if (h._removeMirroring)
    throw new Error("Context is already forwarding operations.");
  h.__originalSave = h.save, h.__originalRestore = h.restore, h.__originalRotate = h.rotate, h.__originalScale = h.scale, h.__originalTranslate = h.translate, h.__originalTransform = h.transform, h.__originalSetTransform = h.setTransform, h.__originalResetTransform = h.resetTransform, h.__originalClip = h.clip, h.__originalMoveTo = h.moveTo, h.__originalLineTo = h.lineTo, h.__originalBezierCurveTo = h.bezierCurveTo, h.__originalRect = h.rect, h.__originalClosePath = h.closePath, h.__originalBeginPath = h.beginPath, h._removeMirroring = () => {
    h.save = h.__originalSave, h.restore = h.__originalRestore, h.rotate = h.__originalRotate, h.scale = h.__originalScale, h.translate = h.__originalTranslate, h.transform = h.__originalTransform, h.setTransform = h.__originalSetTransform, h.resetTransform = h.__originalResetTransform, h.clip = h.__originalClip, h.moveTo = h.__originalMoveTo, h.lineTo = h.__originalLineTo, h.bezierCurveTo = h.__originalBezierCurveTo, h.rect = h.__originalRect, h.closePath = h.__originalClosePath, h.beginPath = h.__originalBeginPath, delete h._removeMirroring;
  }, h.save = function() {
    e.save(), this.__originalSave();
  }, h.restore = function() {
    e.restore(), this.__originalRestore();
  }, h.translate = function(s, i) {
    e.translate(s, i), this.__originalTranslate(s, i);
  }, h.scale = function(s, i) {
    e.scale(s, i), this.__originalScale(s, i);
  }, h.transform = function(s, i, n, r, o, l) {
    e.transform(s, i, n, r, o, l), this.__originalTransform(s, i, n, r, o, l);
  }, h.setTransform = function(s, i, n, r, o, l) {
    e.setTransform(s, i, n, r, o, l), this.__originalSetTransform(s, i, n, r, o, l);
  }, h.resetTransform = function() {
    e.resetTransform(), this.__originalResetTransform();
  }, h.rotate = function(s) {
    e.rotate(s), this.__originalRotate(s);
  }, h.clip = function(s) {
    e.clip(s), this.__originalClip(s);
  }, h.moveTo = function(t, s) {
    e.moveTo(t, s), this.__originalMoveTo(t, s);
  }, h.lineTo = function(t, s) {
    e.lineTo(t, s), this.__originalLineTo(t, s);
  }, h.bezierCurveTo = function(t, s, i, n, r, o) {
    e.bezierCurveTo(t, s, i, n, r, o), this.__originalBezierCurveTo(t, s, i, n, r, o);
  }, h.rect = function(t, s, i, n) {
    e.rect(t, s, i, n), this.__originalRect(t, s, i, n);
  }, h.closePath = function() {
    e.closePath(), this.__originalClosePath();
  }, h.beginPath = function() {
    e.beginPath(), this.__originalBeginPath();
  };
}
class WA {
  constructor(e) {
    this.canvasFactory = e, this.cache = /* @__PURE__ */ Object.create(null);
  }
  getCanvas(e, t, s) {
    let i;
    return this.cache[e] !== void 0 ? (i = this.cache[e], this.canvasFactory.reset(i, t, s)) : (i = this.canvasFactory.create(t, s), this.cache[e] = i), i;
  }
  delete(e) {
    delete this.cache[e];
  }
  clear() {
    for (const e in this.cache) {
      const t = this.cache[e];
      this.canvasFactory.destroy(t), delete this.cache[e];
    }
  }
}
function Cd(h, e, t, s, i, n, r, o, l, c) {
  const [d, u, f, g, m, y] = It(h);
  if (u === 0 && f === 0) {
    const E = r * d + m, S = Math.round(E), T = o * g + y, P = Math.round(T), C = (r + l) * d + m, R = Math.abs(Math.round(C) - S) || 1, _ = (o + c) * g + y, x = Math.abs(Math.round(_) - P) || 1;
    return h.setTransform(Math.sign(d), 0, 0, Math.sign(g), S, P), h.drawImage(e, t, s, i, n, 0, 0, R, x), h.setTransform(d, u, f, g, m, y), [R, x];
  }
  if (d === 0 && g === 0) {
    const E = o * f + m, S = Math.round(E), T = r * u + y, P = Math.round(T), C = (o + c) * f + m, R = Math.abs(Math.round(C) - S) || 1, _ = (r + l) * u + y, x = Math.abs(Math.round(_) - P) || 1;
    return h.setTransform(0, Math.sign(u), Math.sign(f), 0, S, P), h.drawImage(e, t, s, i, n, 0, 0, x, R), h.setTransform(d, u, f, g, m, y), [x, R];
  }
  h.drawImage(e, t, s, i, n, r, o, l, c);
  const w = Math.hypot(d, u), A = Math.hypot(f, g);
  return [w * l, A * c];
}
function GA(h) {
  const {
    width: e,
    height: t
  } = h;
  if (e > rm || t > rm)
    return null;
  const s = 1e3, i = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), n = e + 1;
  let r = new Uint8Array(n * (t + 1)), o, l, c;
  const d = e + 7 & -8;
  let u = new Uint8Array(d * t), f = 0;
  for (const A of h.data) {
    let E = 128;
    for (; E > 0; )
      u[f++] = A & E ? 0 : 255, E >>= 1;
  }
  let g = 0;
  for (f = 0, u[f] !== 0 && (r[0] = 1, ++g), l = 1; l < e; l++)
    u[f] !== u[f + 1] && (r[l] = u[f] ? 2 : 1, ++g), f++;
  for (u[f] !== 0 && (r[l] = 2, ++g), o = 1; o < t; o++) {
    f = o * d, c = o * n, u[f - d] !== u[f] && (r[c] = u[f] ? 1 : 8, ++g);
    let A = (u[f] ? 4 : 0) + (u[f - d] ? 8 : 0);
    for (l = 1; l < e; l++)
      A = (A >> 2) + (u[f + 1] ? 4 : 0) + (u[f - d + 1] ? 8 : 0), i[A] && (r[c + l] = i[A], ++g), f++;
    if (u[f - d] !== u[f] && (r[c + l] = u[f] ? 2 : 4, ++g), g > s)
      return null;
  }
  for (f = d * (t - 1), c = o * n, u[f] !== 0 && (r[c] = 8, ++g), l = 1; l < e; l++)
    u[f] !== u[f + 1] && (r[c + l] = u[f] ? 4 : 8, ++g), f++;
  if (u[f] !== 0 && (r[c + l] = 4, ++g), g > s)
    return null;
  const m = new Int32Array([0, n, -1, 0, -n, 0, 0, 0, 1]), y = new Path2D();
  for (o = 0; g && o <= t; o++) {
    let A = o * n;
    const E = A + e;
    for (; A < E && !r[A]; )
      A++;
    if (A === E)
      continue;
    y.moveTo(A % n, o);
    const S = A;
    let T = r[A];
    do {
      const P = m[T];
      do
        A += P;
      while (!r[A]);
      const C = r[A];
      C !== 5 && C !== 10 ? (T = C, r[A] = 0) : (T = C & 51 * T >> 4, r[A] &= T >> 2 | T << 2), y.lineTo(A % n, A / n | 0), r[A] || --g;
    } while (S !== A);
    --o;
  }
  return u = null, r = null, function(A) {
    A.save(), A.scale(1 / e, -1 / t), A.translate(0, -t), A.fill(y), A.beginPath(), A.restore();
  };
}
class am {
  constructor(e, t) {
    this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = tv, this.textMatrixScale = 1, this.fontMatrix = Df, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = ve.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.patternStroke = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = "none", this.startNewPathAndClipBox([0, 0, e, t]);
  }
  clone() {
    const e = Object.create(this);
    return e.clipBox = this.clipBox.slice(), e;
  }
  setCurrentPoint(e, t) {
    this.x = e, this.y = t;
  }
  updatePathMinMax(e, t, s) {
    [t, s] = X.applyTransform([t, s], e), this.minX = Math.min(this.minX, t), this.minY = Math.min(this.minY, s), this.maxX = Math.max(this.maxX, t), this.maxY = Math.max(this.maxY, s);
  }
  updateRectMinMax(e, t) {
    const s = X.applyTransform(t, e), i = X.applyTransform(t.slice(2), e), n = X.applyTransform([t[0], t[3]], e), r = X.applyTransform([t[2], t[1]], e);
    this.minX = Math.min(this.minX, s[0], i[0], n[0], r[0]), this.minY = Math.min(this.minY, s[1], i[1], n[1], r[1]), this.maxX = Math.max(this.maxX, s[0], i[0], n[0], r[0]), this.maxY = Math.max(this.maxY, s[1], i[1], n[1], r[1]);
  }
  updateScalingPathMinMax(e, t) {
    X.scaleMinMax(e, t), this.minX = Math.min(this.minX, t[0]), this.minY = Math.min(this.minY, t[1]), this.maxX = Math.max(this.maxX, t[2]), this.maxY = Math.max(this.maxY, t[3]);
  }
  updateCurvePathMinMax(e, t, s, i, n, r, o, l, c, d) {
    const u = X.bezierBoundingBox(t, s, i, n, r, o, l, c, d);
    d || this.updateRectMinMax(e, u);
  }
  getPathBoundingBox(e = xe.FILL, t = null) {
    const s = [this.minX, this.minY, this.maxX, this.maxY];
    if (e === xe.STROKE) {
      t || Pt("Stroke bounding box must include transform.");
      const i = X.singularValueDecompose2dScale(t), n = i[0] * this.lineWidth / 2, r = i[1] * this.lineWidth / 2;
      s[0] -= n, s[1] -= r, s[2] += n, s[3] += r;
    }
    return s;
  }
  updateClipFromPath() {
    const e = X.intersect(this.clipBox, this.getPathBoundingBox());
    this.startNewPathAndClipBox(e || [0, 0, 0, 0]);
  }
  isEmptyClip() {
    return this.minX === 1 / 0;
  }
  startNewPathAndClipBox(e) {
    this.clipBox = e, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
  }
  getClippedPathBoundingBox(e = xe.FILL, t = null) {
    return X.intersect(this.clipBox, this.getPathBoundingBox(e, t));
  }
}
function om(h, e) {
  if (e instanceof ImageData) {
    h.putImageData(e, 0, 0);
    return;
  }
  const t = e.height, s = e.width, i = t % Ue, n = (t - i) / Ue, r = i === 0 ? n : n + 1, o = h.createImageData(s, Ue);
  let l = 0, c;
  const d = e.data, u = o.data;
  let f, g, m, y;
  if (e.kind === Fd.GRAYSCALE_1BPP) {
    const w = d.byteLength, A = new Uint32Array(u.buffer, 0, u.byteLength >> 2), E = A.length, S = s + 7 >> 3, T = 4294967295, P = Oe.isLittleEndian ? 4278190080 : 255;
    for (f = 0; f < r; f++) {
      for (m = f < n ? Ue : i, c = 0, g = 0; g < m; g++) {
        const C = w - l;
        let R = 0;
        const _ = C > S ? s : C * 8 - 7, x = _ & -8;
        let I = 0, L = 0;
        for (; R < x; R += 8)
          L = d[l++], A[c++] = L & 128 ? T : P, A[c++] = L & 64 ? T : P, A[c++] = L & 32 ? T : P, A[c++] = L & 16 ? T : P, A[c++] = L & 8 ? T : P, A[c++] = L & 4 ? T : P, A[c++] = L & 2 ? T : P, A[c++] = L & 1 ? T : P;
        for (; R < _; R++)
          I === 0 && (L = d[l++], I = 128), A[c++] = L & I ? T : P, I >>= 1;
      }
      for (; c < E; )
        A[c++] = 0;
      h.putImageData(o, 0, f * Ue);
    }
  } else if (e.kind === Fd.RGBA_32BPP) {
    for (g = 0, y = s * Ue * 4, f = 0; f < n; f++)
      u.set(d.subarray(l, l + y)), l += y, h.putImageData(o, 0, g), g += Ue;
    f < r && (y = s * i * 4, u.set(d.subarray(l, l + y)), h.putImageData(o, 0, g));
  } else if (e.kind === Fd.RGB_24BPP)
    for (m = Ue, y = s * m, f = 0; f < r; f++) {
      for (f >= n && (m = i, y = s * m), c = 0, g = y; g--; )
        u[c++] = d[l++], u[c++] = d[l++], u[c++] = d[l++], u[c++] = 255;
      h.putImageData(o, 0, f * Ue);
    }
  else
    throw new Error(`bad image kind: ${e.kind}`);
}
function lm(h, e) {
  if (e.bitmap) {
    h.drawImage(e.bitmap, 0, 0);
    return;
  }
  const t = e.height, s = e.width, i = t % Ue, n = (t - i) / Ue, r = i === 0 ? n : n + 1, o = h.createImageData(s, Ue);
  let l = 0;
  const c = e.data, d = o.data;
  for (let u = 0; u < r; u++) {
    const f = u < n ? Ue : i;
    ({
      srcPos: l
    } = VA({
      src: c,
      srcPos: l,
      dest: d,
      width: s,
      height: f,
      nonBlackColor: 0
    })), h.putImageData(o, 0, u * Ue);
  }
}
function jl(h, e) {
  const t = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
  for (const s of t)
    h[s] !== void 0 && (e[s] = h[s]);
  h.setLineDash !== void 0 && (e.setLineDash(h.getLineDash()), e.lineDashOffset = h.lineDashOffset);
}
function Rd(h) {
  if (h.strokeStyle = h.fillStyle = "#000000", h.fillRule = "nonzero", h.globalAlpha = 1, h.lineWidth = 1, h.lineCap = "butt", h.lineJoin = "miter", h.miterLimit = 10, h.globalCompositeOperation = "source-over", h.font = "10px sans-serif", h.setLineDash !== void 0 && (h.setLineDash([]), h.lineDashOffset = 0), !Te) {
    const {
      filter: e
    } = h;
    e !== "none" && e !== "" && (h.filter = "none");
  }
}
function hm(h, e) {
  if (e)
    return !0;
  const t = X.singularValueDecompose2dScale(h);
  t[0] = Math.fround(t[0]), t[1] = Math.fround(t[1]);
  const s = Math.fround((globalThis.devicePixelRatio || 1) * Ll.PDF_TO_CSS_UNITS);
  return t[0] <= s && t[1] <= s;
}
const XA = ["butt", "round", "square"], YA = ["miter", "round", "bevel"], KA = {}, cm = {};
var Hs, lp, hp, cp;
const $g = class $g {
  constructor(e, t, s, i, n, {
    optionalContentConfig: r,
    markedContentStack: o = null
  }, l, c) {
    b(this, Hs);
    this.ctx = e, this.current = new am(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = t, this.objs = s, this.canvasFactory = i, this.filterFactory = n, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = o || [], this.optionalContentConfig = r, this.cachedCanvases = new WA(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = l, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = c, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
  }
  getObject(e, t = null) {
    return typeof e == "string" ? e.startsWith("g_") ? this.commonObjs.get(e) : this.objs.get(e) : t;
  }
  beginDrawing({
    transform: e,
    viewport: t,
    transparency: s = !1,
    background: i = null
  }) {
    const n = this.ctx.canvas.width, r = this.ctx.canvas.height, o = this.ctx.fillStyle;
    if (this.ctx.fillStyle = i || "#ffffff", this.ctx.fillRect(0, 0, n, r), this.ctx.fillStyle = o, s) {
      const l = this.cachedCanvases.getCanvas("transparent", n, r);
      this.compositeCtx = this.ctx, this.transparentCanvas = l.canvas, this.ctx = l.context, this.ctx.save(), this.ctx.transform(...It(this.compositeCtx));
    }
    this.ctx.save(), Rd(this.ctx), e && (this.ctx.transform(...e), this.outputScaleX = e[0], this.outputScaleY = e[0]), this.ctx.transform(...t.transform), this.viewportScale = t.scale, this.baseTransform = It(this.ctx);
  }
  executeOperatorList(e, t, s, i) {
    const n = e.argsArray, r = e.fnArray;
    let o = t || 0;
    const l = n.length;
    if (l === o)
      return o;
    const c = l - o > nm && typeof s == "function", d = c ? Date.now() + UA : 0;
    let u = 0;
    const f = this.commonObjs, g = this.objs;
    let m;
    for (; ; ) {
      if (i !== void 0 && o === i.nextBreakPoint)
        return i.breakIt(o, s), o;
      if (m = r[o], m !== xs.dependency)
        this[m].apply(this, n[o]);
      else
        for (const y of n[o]) {
          const w = y.startsWith("g_") ? f : g;
          if (!w.has(y))
            return w.get(y, s), o;
        }
      if (o++, o === l)
        return o;
      if (c && ++u > nm) {
        if (Date.now() > d)
          return s(), o;
        u = 0;
      }
    }
  }
  endDrawing() {
    v(this, Hs, lp).call(this), this.cachedCanvases.clear(), this.cachedPatterns.clear();
    for (const e of this._cachedBitmapsMap.values()) {
      for (const t of e.values())
        typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement && (t.width = t.height = 0);
      e.clear();
    }
    this._cachedBitmapsMap.clear(), v(this, Hs, hp).call(this);
  }
  _scaleImage(e, t) {
    const s = e.width ?? e.displayWidth, i = e.height ?? e.displayHeight;
    let n = Math.max(Math.hypot(t[0], t[1]), 1), r = Math.max(Math.hypot(t[2], t[3]), 1), o = s, l = i, c = "prescale1", d, u;
    for (; n > 2 && o > 1 || r > 2 && l > 1; ) {
      let f = o, g = l;
      n > 2 && o > 1 && (f = o >= 16384 ? Math.floor(o / 2) - 1 || 1 : Math.ceil(o / 2), n /= o / f), r > 2 && l > 1 && (g = l >= 16384 ? Math.floor(l / 2) - 1 || 1 : Math.ceil(l) / 2, r /= l / g), d = this.cachedCanvases.getCanvas(c, f, g), u = d.context, u.clearRect(0, 0, f, g), u.drawImage(e, 0, 0, o, l, 0, 0, f, g), e = d.canvas, o = f, l = g, c = c === "prescale1" ? "prescale2" : "prescale1";
    }
    return {
      img: e,
      paintWidth: o,
      paintHeight: l
    };
  }
  _createMaskCanvas(e) {
    const t = this.ctx, {
      width: s,
      height: i
    } = e, n = this.current.fillColor, r = this.current.patternFill, o = It(t);
    let l, c, d, u;
    if ((e.bitmap || e.data) && e.count > 1) {
      const _ = e.bitmap || e.data.buffer;
      c = JSON.stringify(r ? o : [o.slice(0, 4), n]), l = this._cachedBitmapsMap.get(_), l || (l = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(_, l));
      const x = l.get(c);
      if (x && !r) {
        const I = Math.round(Math.min(o[0], o[2]) + o[4]), L = Math.round(Math.min(o[1], o[3]) + o[5]);
        return {
          canvas: x,
          offsetX: I,
          offsetY: L
        };
      }
      d = x;
    }
    d || (u = this.cachedCanvases.getCanvas("maskCanvas", s, i), lm(u.context, e));
    let f = X.transform(o, [1 / s, 0, 0, -1 / i, 0, 0]);
    f = X.transform(f, [1, 0, 0, 1, 0, -i]);
    const [g, m, y, w] = X.getAxialAlignedBoundingBox([0, 0, s, i], f), A = Math.round(y - g) || 1, E = Math.round(w - m) || 1, S = this.cachedCanvases.getCanvas("fillCanvas", A, E), T = S.context, P = g, C = m;
    T.translate(-P, -C), T.transform(...f), d || (d = this._scaleImage(u.canvas, zs(T)), d = d.img, l && r && l.set(c, d)), T.imageSmoothingEnabled = hm(It(T), e.interpolate), Cd(T, d, 0, 0, d.width, d.height, 0, 0, s, i), T.globalCompositeOperation = "source-in";
    const R = X.transform(zs(T), [1, 0, 0, 1, -P, -C]);
    return T.fillStyle = r ? n.getPattern(t, this, R, xe.FILL) : n, T.fillRect(0, 0, s, i), l && !r && (this.cachedCanvases.delete("fillCanvas"), l.set(c, S.canvas)), {
      canvas: S.canvas,
      offsetX: Math.round(P),
      offsetY: Math.round(C)
    };
  }
  setLineWidth(e) {
    e !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = e, this.ctx.lineWidth = e;
  }
  setLineCap(e) {
    this.ctx.lineCap = XA[e];
  }
  setLineJoin(e) {
    this.ctx.lineJoin = YA[e];
  }
  setMiterLimit(e) {
    this.ctx.miterLimit = e;
  }
  setDash(e, t) {
    const s = this.ctx;
    s.setLineDash !== void 0 && (s.setLineDash(e), s.lineDashOffset = t);
  }
  setRenderingIntent(e) {
  }
  setFlatness(e) {
  }
  setGState(e) {
    for (const [t, s] of e)
      switch (t) {
        case "LW":
          this.setLineWidth(s);
          break;
        case "LC":
          this.setLineCap(s);
          break;
        case "LJ":
          this.setLineJoin(s);
          break;
        case "ML":
          this.setMiterLimit(s);
          break;
        case "D":
          this.setDash(s[0], s[1]);
          break;
        case "RI":
          this.setRenderingIntent(s);
          break;
        case "FL":
          this.setFlatness(s);
          break;
        case "Font":
          this.setFont(s[0], s[1]);
          break;
        case "CA":
          this.current.strokeAlpha = s;
          break;
        case "ca":
          this.current.fillAlpha = s, this.ctx.globalAlpha = s;
          break;
        case "BM":
          this.ctx.globalCompositeOperation = s;
          break;
        case "SMask":
          this.current.activeSMask = s ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
          break;
        case "TR":
          this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(s);
          break;
      }
  }
  get inSMaskMode() {
    return !!this.suspendedCtx;
  }
  checkSMaskState() {
    const e = this.inSMaskMode;
    this.current.activeSMask && !e ? this.beginSMaskMode() : !this.current.activeSMask && e && this.endSMaskMode();
  }
  beginSMaskMode() {
    if (this.inSMaskMode)
      throw new Error("beginSMaskMode called while already in smask mode");
    const e = this.ctx.canvas.width, t = this.ctx.canvas.height, s = "smaskGroupAt" + this.groupLevel, i = this.cachedCanvases.getCanvas(s, e, t);
    this.suspendedCtx = this.ctx, this.ctx = i.context;
    const n = this.ctx;
    n.setTransform(...It(this.suspendedCtx)), jl(this.suspendedCtx, n), zA(n, this.suspendedCtx), this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
  }
  endSMaskMode() {
    if (!this.inSMaskMode)
      throw new Error("endSMaskMode called while not in smask mode");
    this.ctx._removeMirroring(), jl(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
  }
  compose(e) {
    if (!this.current.activeSMask)
      return;
    e ? (e[0] = Math.floor(e[0]), e[1] = Math.floor(e[1]), e[2] = Math.ceil(e[2]), e[3] = Math.ceil(e[3])) : e = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
    const t = this.current.activeSMask, s = this.suspendedCtx;
    this.composeSMask(s, t, this.ctx, e), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
  }
  composeSMask(e, t, s, i) {
    const n = i[0], r = i[1], o = i[2] - n, l = i[3] - r;
    o === 0 || l === 0 || (this.genericComposeSMask(t.context, s, o, l, t.subtype, t.backdrop, t.transferMap, n, r, t.offsetX, t.offsetY), e.save(), e.globalAlpha = 1, e.globalCompositeOperation = "source-over", e.setTransform(1, 0, 0, 1, 0, 0), e.drawImage(s.canvas, 0, 0), e.restore());
  }
  genericComposeSMask(e, t, s, i, n, r, o, l, c, d, u) {
    let f = e.canvas, g = l - d, m = c - u;
    if (r) {
      const w = X.makeHexColor(...r);
      if (g < 0 || m < 0 || g + s > f.width || m + i > f.height) {
        const A = this.cachedCanvases.getCanvas("maskExtension", s, i), E = A.context;
        E.drawImage(f, -g, -m), E.globalCompositeOperation = "destination-atop", E.fillStyle = w, E.fillRect(0, 0, s, i), E.globalCompositeOperation = "source-over", f = A.canvas, g = m = 0;
      } else {
        e.save(), e.globalAlpha = 1, e.setTransform(1, 0, 0, 1, 0, 0);
        const A = new Path2D();
        A.rect(g, m, s, i), e.clip(A), e.globalCompositeOperation = "destination-atop", e.fillStyle = w, e.fillRect(g, m, s, i), e.restore();
      }
    }
    t.save(), t.globalAlpha = 1, t.setTransform(1, 0, 0, 1, 0, 0), n === "Alpha" && o ? t.filter = this.filterFactory.addAlphaFilter(o) : n === "Luminosity" && (t.filter = this.filterFactory.addLuminosityFilter(o));
    const y = new Path2D();
    y.rect(l, c, s, i), t.clip(y), t.globalCompositeOperation = "destination-in", t.drawImage(f, g, m, s, i, l, c, s, i), t.restore();
  }
  save() {
    this.inSMaskMode ? (jl(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
    const e = this.current;
    this.stateStack.push(e), this.current = e.clone();
  }
  restore() {
    this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), jl(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null);
  }
  transform(e, t, s, i, n, r) {
    this.ctx.transform(e, t, s, i, n, r), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
  }
  constructPath(e, t, s) {
    const i = this.ctx, n = this.current;
    let r = n.x, o = n.y, l, c;
    const d = It(i), u = d[0] === 0 && d[3] === 0 || d[1] === 0 && d[2] === 0, f = u ? s.slice(0) : null;
    for (let g = 0, m = 0, y = e.length; g < y; g++)
      switch (e[g] | 0) {
        case xs.rectangle:
          r = t[m++], o = t[m++];
          const w = t[m++], A = t[m++], E = r + w, S = o + A;
          i.moveTo(r, o), w === 0 || A === 0 ? i.lineTo(E, S) : (i.lineTo(E, o), i.lineTo(E, S), i.lineTo(r, S)), u || n.updateRectMinMax(d, [r, o, E, S]), i.closePath();
          break;
        case xs.moveTo:
          r = t[m++], o = t[m++], i.moveTo(r, o), u || n.updatePathMinMax(d, r, o);
          break;
        case xs.lineTo:
          r = t[m++], o = t[m++], i.lineTo(r, o), u || n.updatePathMinMax(d, r, o);
          break;
        case xs.curveTo:
          l = r, c = o, r = t[m + 4], o = t[m + 5], i.bezierCurveTo(t[m], t[m + 1], t[m + 2], t[m + 3], r, o), n.updateCurvePathMinMax(d, l, c, t[m], t[m + 1], t[m + 2], t[m + 3], r, o, f), m += 6;
          break;
        case xs.curveTo2:
          l = r, c = o, i.bezierCurveTo(r, o, t[m], t[m + 1], t[m + 2], t[m + 3]), n.updateCurvePathMinMax(d, l, c, r, o, t[m], t[m + 1], t[m + 2], t[m + 3], f), r = t[m + 2], o = t[m + 3], m += 4;
          break;
        case xs.curveTo3:
          l = r, c = o, r = t[m + 2], o = t[m + 3], i.bezierCurveTo(t[m], t[m + 1], r, o, r, o), n.updateCurvePathMinMax(d, l, c, t[m], t[m + 1], r, o, r, o, f), m += 4;
          break;
        case xs.closePath:
          i.closePath();
          break;
      }
    u && n.updateScalingPathMinMax(d, f), n.setCurrentPoint(r, o);
  }
  closePath() {
    this.ctx.closePath();
  }
  stroke(e = !0) {
    const t = this.ctx, s = this.current.strokeColor;
    t.globalAlpha = this.current.strokeAlpha, this.contentVisible && (typeof s == "object" && (s != null && s.getPattern) ? (t.save(), t.strokeStyle = s.getPattern(t, this, zs(t), xe.STROKE), this.rescaleAndStroke(!1), t.restore()) : this.rescaleAndStroke(!0)), e && this.consumePath(this.current.getClippedPathBoundingBox()), t.globalAlpha = this.current.fillAlpha;
  }
  closeStroke() {
    this.closePath(), this.stroke();
  }
  fill(e = !0) {
    const t = this.ctx, s = this.current.fillColor, i = this.current.patternFill;
    let n = !1;
    i && (t.save(), t.fillStyle = s.getPattern(t, this, zs(t), xe.FILL), n = !0);
    const r = this.current.getClippedPathBoundingBox();
    this.contentVisible && r !== null && (this.pendingEOFill ? (t.fill("evenodd"), this.pendingEOFill = !1) : t.fill()), n && t.restore(), e && this.consumePath(r);
  }
  eoFill() {
    this.pendingEOFill = !0, this.fill();
  }
  fillStroke() {
    this.fill(!1), this.stroke(!1), this.consumePath();
  }
  eoFillStroke() {
    this.pendingEOFill = !0, this.fillStroke();
  }
  closeFillStroke() {
    this.closePath(), this.fillStroke();
  }
  closeEOFillStroke() {
    this.pendingEOFill = !0, this.closePath(), this.fillStroke();
  }
  endPath() {
    this.consumePath();
  }
  clip() {
    this.pendingClip = KA;
  }
  eoClip() {
    this.pendingClip = cm;
  }
  beginText() {
    this.current.textMatrix = tv, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
  }
  endText() {
    const e = this.pendingTextPaths, t = this.ctx;
    if (e === void 0) {
      t.beginPath();
      return;
    }
    const s = new Path2D(), i = t.getTransform().invertSelf();
    for (const {
      transform: n,
      x: r,
      y: o,
      fontSize: l,
      path: c
    } of e)
      s.addPath(c, new DOMMatrix(n).preMultiplySelf(i).translate(r, o).scale(l, -l));
    t.clip(s), t.beginPath(), delete this.pendingTextPaths;
  }
  setCharSpacing(e) {
    this.current.charSpacing = e;
  }
  setWordSpacing(e) {
    this.current.wordSpacing = e;
  }
  setHScale(e) {
    this.current.textHScale = e / 100;
  }
  setLeading(e) {
    this.current.leading = -e;
  }
  setFont(e, t) {
    var d;
    const s = this.commonObjs.get(e), i = this.current;
    if (!s)
      throw new Error(`Can't find font for ${e}`);
    if (i.fontMatrix = s.fontMatrix || Df, (i.fontMatrix[0] === 0 || i.fontMatrix[3] === 0) && tt("Invalid font matrix for font " + e), t < 0 ? (t = -t, i.fontDirection = -1) : i.fontDirection = 1, this.current.font = s, this.current.fontSize = t, s.isType3Font)
      return;
    const n = s.loadedName || "sans-serif", r = ((d = s.systemFontInfo) == null ? void 0 : d.css) || `"${n}", ${s.fallbackName}`;
    let o = "normal";
    s.black ? o = "900" : s.bold && (o = "bold");
    const l = s.italic ? "italic" : "normal";
    let c = t;
    t < sm ? c = sm : t > im && (c = im), this.current.fontSizeScale = t / c, this.ctx.font = `${l} ${o} ${c}px ${r}`;
  }
  setTextRenderingMode(e) {
    this.current.textRenderingMode = e;
  }
  setTextRise(e) {
    this.current.textRise = e;
  }
  moveText(e, t) {
    this.current.x = this.current.lineX += e, this.current.y = this.current.lineY += t;
  }
  setLeadingMoveText(e, t) {
    this.setLeading(-t), this.moveText(e, t);
  }
  setTextMatrix(e, t, s, i, n, r) {
    this.current.textMatrix = [e, t, s, i, n, r], this.current.textMatrixScale = Math.hypot(e, t), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
  }
  nextLine() {
    this.moveText(0, this.current.leading);
  }
  paintChar(e, t, s, i, n) {
    const r = this.ctx, o = this.current, l = o.font, c = o.textRenderingMode, d = o.fontSize / o.fontSizeScale, u = c & ve.FILL_STROKE_MASK, f = !!(c & ve.ADD_TO_PATH_FLAG), g = o.patternFill && !l.missingFile, m = o.patternStroke && !l.missingFile;
    let y;
    if ((l.disableFontFace || f || g || m) && (y = l.getPathGenerator(this.commonObjs, e)), l.disableFontFace || g || m) {
      if (r.save(), r.translate(t, s), r.scale(d, -d), u === ve.FILL || u === ve.FILL_STROKE)
        if (i) {
          const w = r.getTransform();
          r.setTransform(...i), r.fill(v(this, Hs, cp).call(this, y, w, i));
        } else
          r.fill(y);
      if (u === ve.STROKE || u === ve.FILL_STROKE)
        if (n) {
          const w = r.getTransform();
          r.setTransform(...n), r.stroke(v(this, Hs, cp).call(this, y, w, n));
        } else
          r.lineWidth /= d, r.stroke(y);
      r.restore();
    } else
      (u === ve.FILL || u === ve.FILL_STROKE) && r.fillText(e, t, s), (u === ve.STROKE || u === ve.FILL_STROKE) && r.strokeText(e, t, s);
    f && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({
      transform: It(r),
      x: t,
      y: s,
      fontSize: d,
      path: y
    });
  }
  get isFontSubpixelAAEnabled() {
    const {
      context: e
    } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
    e.scale(1.5, 1), e.fillText("I", 0, 10);
    const t = e.getImageData(0, 0, 10, 10).data;
    let s = !1;
    for (let i = 3; i < t.length; i += 4)
      if (t[i] > 0 && t[i] < 255) {
        s = !0;
        break;
      }
    return ht(this, "isFontSubpixelAAEnabled", s);
  }
  showText(e) {
    const t = this.current, s = t.font;
    if (s.isType3Font)
      return this.showType3Text(e);
    const i = t.fontSize;
    if (i === 0)
      return;
    const n = this.ctx, r = t.fontSizeScale, o = t.charSpacing, l = t.wordSpacing, c = t.fontDirection, d = t.textHScale * c, u = e.length, f = s.vertical, g = f ? 1 : -1, m = s.defaultVMetrics, y = i * t.fontMatrix[0], w = t.textRenderingMode === ve.FILL && !s.disableFontFace && !t.patternFill;
    n.save(), n.transform(...t.textMatrix), n.translate(t.x, t.y + t.textRise), c > 0 ? n.scale(d, -1) : n.scale(d, 1);
    let A, E;
    if (t.patternFill) {
      n.save();
      const R = t.fillColor.getPattern(n, this, zs(n), xe.FILL);
      A = It(n), n.restore(), n.fillStyle = R;
    }
    if (t.patternStroke) {
      n.save();
      const R = t.strokeColor.getPattern(n, this, zs(n), xe.STROKE);
      E = It(n), n.restore(), n.strokeStyle = R;
    }
    let S = t.lineWidth;
    const T = t.textMatrixScale;
    if (T === 0 || S === 0) {
      const R = t.textRenderingMode & ve.FILL_STROKE_MASK;
      (R === ve.STROKE || R === ve.FILL_STROKE) && (S = this.getSinglePixelWidth());
    } else
      S /= T;
    if (r !== 1 && (n.scale(r, r), S /= r), n.lineWidth = S, s.isInvalidPDFjsFont) {
      const R = [];
      let _ = 0;
      for (const x of e)
        R.push(x.unicode), _ += x.width;
      n.fillText(R.join(""), 0, 0), t.x += _ * y * d, n.restore(), this.compose();
      return;
    }
    let P = 0, C;
    for (C = 0; C < u; ++C) {
      const R = e[C];
      if (typeof R == "number") {
        P += g * R * i / 1e3;
        continue;
      }
      let _ = !1;
      const x = (R.isSpace ? l : 0) + o, I = R.fontChar, L = R.accent;
      let j, k, F = R.width;
      if (f) {
        const N = R.vmetric || m, D = -(R.vmetric ? N[1] : F * 0.5) * y, et = N[2] * y;
        F = N ? -N[0] : F, j = D / r, k = (P + et) / r;
      } else
        j = P / r, k = 0;
      if (s.remeasure && F > 0) {
        const N = n.measureText(I).width * 1e3 / i * r;
        if (F < N && this.isFontSubpixelAAEnabled) {
          const D = F / N;
          _ = !0, n.save(), n.scale(D, 1), j /= D;
        } else F !== N && (j += (F - N) / 2e3 * i / r);
      }
      if (this.contentVisible && (R.isInFont || s.missingFile)) {
        if (w && !L)
          n.fillText(I, j, k);
        else if (this.paintChar(I, j, k, A, E), L) {
          const N = j + i * L.offset.x / r, D = k - i * L.offset.y / r;
          this.paintChar(L.fontChar, N, D, A, E);
        }
      }
      const Y = f ? F * y - x * c : F * y + x * c;
      P += Y, _ && n.restore();
    }
    f ? t.y -= P : t.x += P * d, n.restore(), this.compose();
  }
  showType3Text(e) {
    const t = this.ctx, s = this.current, i = s.font, n = s.fontSize, r = s.fontDirection, o = i.vertical ? 1 : -1, l = s.charSpacing, c = s.wordSpacing, d = s.textHScale * r, u = s.fontMatrix || Df, f = e.length, g = s.textRenderingMode === ve.INVISIBLE;
    let m, y, w, A;
    if (!(g || n === 0)) {
      for (this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, t.save(), t.transform(...s.textMatrix), t.translate(s.x, s.y), t.scale(d, r), m = 0; m < f; ++m) {
        if (y = e[m], typeof y == "number") {
          A = o * y * n / 1e3, this.ctx.translate(A, 0), s.x += A * d;
          continue;
        }
        const E = (y.isSpace ? c : 0) + l, S = i.charProcOperatorList[y.operatorListId];
        if (!S) {
          tt(`Type3 character "${y.operatorListId}" is not available.`);
          continue;
        }
        this.contentVisible && (this.processingType3 = y, this.save(), t.scale(n, n), t.transform(...u), this.executeOperatorList(S), this.restore()), w = X.applyTransform([y.width, 0], u)[0] * n + E, t.translate(w, 0), s.x += w * d;
      }
      t.restore(), this.processingType3 = null;
    }
  }
  setCharWidth(e, t) {
  }
  setCharWidthAndBounds(e, t, s, i, n, r) {
    this.ctx.rect(s, i, n - s, r - i), this.ctx.clip(), this.endPath();
  }
  getColorN_Pattern(e) {
    let t;
    if (e[0] === "TilingPattern") {
      const s = e[1], i = this.baseTransform || It(this.ctx), n = {
        createCanvasGraphics: (r) => new $g(r, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
          optionalContentConfig: this.optionalContentConfig,
          markedContentStack: this.markedContentStack
        })
      };
      t = new op(e, s, this.ctx, n, i);
    } else
      t = this._getPattern(e[1], e[2]);
    return t;
  }
  setStrokeColorN() {
    this.current.strokeColor = this.getColorN_Pattern(arguments), this.current.patternStroke = !0;
  }
  setFillColorN() {
    this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0;
  }
  setStrokeRGBColor(e, t, s) {
    this.ctx.strokeStyle = this.current.strokeColor = X.makeHexColor(e, t, s), this.current.patternStroke = !1;
  }
  setStrokeTransparent() {
    this.ctx.strokeStyle = this.current.strokeColor = "transparent", this.current.patternStroke = !1;
  }
  setFillRGBColor(e, t, s) {
    this.ctx.fillStyle = this.current.fillColor = X.makeHexColor(e, t, s), this.current.patternFill = !1;
  }
  setFillTransparent() {
    this.ctx.fillStyle = this.current.fillColor = "transparent", this.current.patternFill = !1;
  }
  _getPattern(e, t = null) {
    let s;
    return this.cachedPatterns.has(e) ? s = this.cachedPatterns.get(e) : (s = $A(this.getObject(e)), this.cachedPatterns.set(e, s)), t && (s.matrix = t), s;
  }
  shadingFill(e) {
    if (!this.contentVisible)
      return;
    const t = this.ctx;
    this.save();
    const s = this._getPattern(e);
    t.fillStyle = s.getPattern(t, this, zs(t), xe.SHADING);
    const i = zs(t);
    if (i) {
      const {
        width: n,
        height: r
      } = t.canvas, [o, l, c, d] = X.getAxialAlignedBoundingBox([0, 0, n, r], i);
      this.ctx.fillRect(o, l, c - o, d - l);
    } else
      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
    this.compose(this.current.getClippedPathBoundingBox()), this.restore();
  }
  beginInlineImage() {
    Pt("Should not call beginInlineImage");
  }
  beginImageData() {
    Pt("Should not call beginImageData");
  }
  paintFormXObjectBegin(e, t) {
    if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), e && this.transform(...e), this.baseTransform = It(this.ctx), t)) {
      const s = t[2] - t[0], i = t[3] - t[1];
      this.ctx.rect(t[0], t[1], s, i), this.current.updateRectMinMax(It(this.ctx), t), this.clip(), this.endPath();
    }
  }
  paintFormXObjectEnd() {
    this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop());
  }
  beginGroup(e) {
    if (!this.contentVisible)
      return;
    this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
    const t = this.ctx;
    e.isolated || af("TODO: Support non-isolated groups."), e.knockout && tt("Knockout groups not supported.");
    const s = It(t);
    if (e.matrix && t.transform(...e.matrix), !e.bbox)
      throw new Error("Bounding box is required.");
    let i = X.getAxialAlignedBoundingBox(e.bbox, It(t));
    const n = [0, 0, t.canvas.width, t.canvas.height];
    i = X.intersect(i, n) || [0, 0, 0, 0];
    const r = Math.floor(i[0]), o = Math.floor(i[1]), l = Math.max(Math.ceil(i[2]) - r, 1), c = Math.max(Math.ceil(i[3]) - o, 1);
    this.current.startNewPathAndClipBox([0, 0, l, c]);
    let d = "groupAt" + this.groupLevel;
    e.smask && (d += "_smask_" + this.smaskCounter++ % 2);
    const u = this.cachedCanvases.getCanvas(d, l, c), f = u.context;
    f.translate(-r, -o), f.transform(...s), e.smask ? this.smaskStack.push({
      canvas: u.canvas,
      context: f,
      offsetX: r,
      offsetY: o,
      subtype: e.smask.subtype,
      backdrop: e.smask.backdrop,
      transferMap: e.smask.transferMap || null,
      startTransformInverse: null
    }) : (t.setTransform(1, 0, 0, 1, 0, 0), t.translate(r, o), t.save()), jl(t, f), this.ctx = f, this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(t), this.groupLevel++;
  }
  endGroup(e) {
    if (!this.contentVisible)
      return;
    this.groupLevel--;
    const t = this.ctx, s = this.groupStack.pop();
    if (this.ctx = s, this.ctx.imageSmoothingEnabled = !1, e.smask)
      this.tempSMask = this.smaskStack.pop(), this.restore();
    else {
      this.ctx.restore();
      const i = It(this.ctx);
      this.restore(), this.ctx.save(), this.ctx.setTransform(...i);
      const n = X.getAxialAlignedBoundingBox([0, 0, t.canvas.width, t.canvas.height], i);
      this.ctx.drawImage(t.canvas, 0, 0), this.ctx.restore(), this.compose(n);
    }
  }
  beginAnnotation(e, t, s, i, n) {
    if (v(this, Hs, lp).call(this), Rd(this.ctx), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), t) {
      const r = t[2] - t[0], o = t[3] - t[1];
      if (n && this.annotationCanvasMap) {
        s = s.slice(), s[4] -= t[0], s[5] -= t[1], t = t.slice(), t[0] = t[1] = 0, t[2] = r, t[3] = o;
        const [l, c] = X.singularValueDecompose2dScale(It(this.ctx)), {
          viewportScale: d
        } = this, u = Math.ceil(r * this.outputScaleX * d), f = Math.ceil(o * this.outputScaleY * d);
        this.annotationCanvas = this.canvasFactory.create(u, f);
        const {
          canvas: g,
          context: m
        } = this.annotationCanvas;
        this.annotationCanvasMap.set(e, g), this.annotationCanvas.savedCtx = this.ctx, this.ctx = m, this.ctx.save(), this.ctx.setTransform(l, 0, 0, -c, 0, o * c), Rd(this.ctx);
      } else
        Rd(this.ctx), this.endPath(), this.ctx.rect(t[0], t[1], r, o), this.ctx.clip(), this.ctx.beginPath();
    }
    this.current = new am(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...s), this.transform(...i);
  }
  endAnnotation() {
    this.annotationCanvas && (this.ctx.restore(), v(this, Hs, hp).call(this), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
  }
  paintImageMaskXObject(e) {
    if (!this.contentVisible)
      return;
    const t = e.count;
    e = this.getObject(e.data, e), e.count = t;
    const s = this.ctx, i = this.processingType3;
    if (i && (i.compiled === void 0 && (i.compiled = GA(e)), i.compiled)) {
      i.compiled(s);
      return;
    }
    const n = this._createMaskCanvas(e), r = n.canvas;
    s.save(), s.setTransform(1, 0, 0, 1, 0, 0), s.drawImage(r, n.offsetX, n.offsetY), s.restore(), this.compose();
  }
  paintImageMaskXObjectRepeat(e, t, s = 0, i = 0, n, r) {
    if (!this.contentVisible)
      return;
    e = this.getObject(e.data, e);
    const o = this.ctx;
    o.save();
    const l = It(o);
    o.transform(t, s, i, n, 0, 0);
    const c = this._createMaskCanvas(e);
    o.setTransform(1, 0, 0, 1, c.offsetX - l[4], c.offsetY - l[5]);
    for (let d = 0, u = r.length; d < u; d += 2) {
      const f = X.transform(l, [t, s, i, n, r[d], r[d + 1]]), [g, m] = X.applyTransform([0, 0], f);
      o.drawImage(c.canvas, g, m);
    }
    o.restore(), this.compose();
  }
  paintImageMaskXObjectGroup(e) {
    if (!this.contentVisible)
      return;
    const t = this.ctx, s = this.current.fillColor, i = this.current.patternFill;
    for (const n of e) {
      const {
        data: r,
        width: o,
        height: l,
        transform: c
      } = n, d = this.cachedCanvases.getCanvas("maskCanvas", o, l), u = d.context;
      u.save();
      const f = this.getObject(r, n);
      lm(u, f), u.globalCompositeOperation = "source-in", u.fillStyle = i ? s.getPattern(u, this, zs(t), xe.FILL) : s, u.fillRect(0, 0, o, l), u.restore(), t.save(), t.transform(...c), t.scale(1, -1), Cd(t, d.canvas, 0, 0, o, l, 0, -1, 1, 1), t.restore();
    }
    this.compose();
  }
  paintImageXObject(e) {
    if (!this.contentVisible)
      return;
    const t = this.getObject(e);
    if (!t) {
      tt("Dependent image isn't ready yet");
      return;
    }
    this.paintInlineImageXObject(t);
  }
  paintImageXObjectRepeat(e, t, s, i) {
    if (!this.contentVisible)
      return;
    const n = this.getObject(e);
    if (!n) {
      tt("Dependent image isn't ready yet");
      return;
    }
    const r = n.width, o = n.height, l = [];
    for (let c = 0, d = i.length; c < d; c += 2)
      l.push({
        transform: [t, 0, 0, s, i[c], i[c + 1]],
        x: 0,
        y: 0,
        w: r,
        h: o
      });
    this.paintInlineImageXObjectGroup(n, l);
  }
  applyTransferMapsToCanvas(e) {
    return this.current.transferMaps !== "none" && (e.filter = this.current.transferMaps, e.drawImage(e.canvas, 0, 0), e.filter = "none"), e.canvas;
  }
  applyTransferMapsToBitmap(e) {
    if (this.current.transferMaps === "none")
      return e.bitmap;
    const {
      bitmap: t,
      width: s,
      height: i
    } = e, n = this.cachedCanvases.getCanvas("inlineImage", s, i), r = n.context;
    return r.filter = this.current.transferMaps, r.drawImage(t, 0, 0), r.filter = "none", n.canvas;
  }
  paintInlineImageXObject(e) {
    if (!this.contentVisible)
      return;
    const t = e.width, s = e.height, i = this.ctx;
    if (this.save(), !Te) {
      const {
        filter: o
      } = i;
      o !== "none" && o !== "" && (i.filter = "none");
    }
    i.scale(1 / t, -1 / s);
    let n;
    if (e.bitmap)
      n = this.applyTransferMapsToBitmap(e);
    else if (typeof HTMLElement == "function" && e instanceof HTMLElement || !e.data)
      n = e;
    else {
      const l = this.cachedCanvases.getCanvas("inlineImage", t, s).context;
      om(l, e), n = this.applyTransferMapsToCanvas(l);
    }
    const r = this._scaleImage(n, zs(i));
    i.imageSmoothingEnabled = hm(It(i), e.interpolate), Cd(i, r.img, 0, 0, r.paintWidth, r.paintHeight, 0, -s, t, s), this.compose(), this.restore();
  }
  paintInlineImageXObjectGroup(e, t) {
    if (!this.contentVisible)
      return;
    const s = this.ctx;
    let i;
    if (e.bitmap)
      i = e.bitmap;
    else {
      const n = e.width, r = e.height, l = this.cachedCanvases.getCanvas("inlineImage", n, r).context;
      om(l, e), i = this.applyTransferMapsToCanvas(l);
    }
    for (const n of t)
      s.save(), s.transform(...n.transform), s.scale(1, -1), Cd(s, i, n.x, n.y, n.w, n.h, 0, -1, 1, 1), s.restore();
    this.compose();
  }
  paintSolidColorImageMask() {
    this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose());
  }
  markPoint(e) {
  }
  markPointProps(e, t) {
  }
  beginMarkedContent(e) {
    this.markedContentStack.push({
      visible: !0
    });
  }
  beginMarkedContentProps(e, t) {
    e === "OC" ? this.markedContentStack.push({
      visible: this.optionalContentConfig.isVisible(t)
    }) : this.markedContentStack.push({
      visible: !0
    }), this.contentVisible = this.isContentVisible();
  }
  endMarkedContent() {
    this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
  }
  beginCompat() {
  }
  endCompat() {
  }
  consumePath(e) {
    const t = this.current.isEmptyClip();
    this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(e);
    const s = this.ctx;
    this.pendingClip && (t || (this.pendingClip === cm ? s.clip("evenodd") : s.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), s.beginPath();
  }
  getSinglePixelWidth() {
    if (!this._cachedGetSinglePixelWidth) {
      const e = It(this.ctx);
      if (e[1] === 0 && e[2] === 0)
        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(e[0]), Math.abs(e[3]));
      else {
        const t = Math.abs(e[0] * e[3] - e[2] * e[1]), s = Math.hypot(e[0], e[2]), i = Math.hypot(e[1], e[3]);
        this._cachedGetSinglePixelWidth = Math.max(s, i) / t;
      }
    }
    return this._cachedGetSinglePixelWidth;
  }
  getScaleForStroking() {
    if (this._cachedScaleForStroking[0] === -1) {
      const {
        lineWidth: e
      } = this.current, {
        a: t,
        b: s,
        c: i,
        d: n
      } = this.ctx.getTransform();
      let r, o;
      if (s === 0 && i === 0) {
        const l = Math.abs(t), c = Math.abs(n);
        if (l === c)
          if (e === 0)
            r = o = 1 / l;
          else {
            const d = l * e;
            r = o = d < 1 ? 1 / d : 1;
          }
        else if (e === 0)
          r = 1 / l, o = 1 / c;
        else {
          const d = l * e, u = c * e;
          r = d < 1 ? 1 / d : 1, o = u < 1 ? 1 / u : 1;
        }
      } else {
        const l = Math.abs(t * n - s * i), c = Math.hypot(t, s), d = Math.hypot(i, n);
        if (e === 0)
          r = d / l, o = c / l;
        else {
          const u = e * l;
          r = d > u ? d / u : 1, o = c > u ? c / u : 1;
        }
      }
      this._cachedScaleForStroking[0] = r, this._cachedScaleForStroking[1] = o;
    }
    return this._cachedScaleForStroking;
  }
  rescaleAndStroke(e) {
    const {
      ctx: t
    } = this, {
      lineWidth: s
    } = this.current, [i, n] = this.getScaleForStroking();
    if (t.lineWidth = s || 1, i === 1 && n === 1) {
      t.stroke();
      return;
    }
    const r = t.getLineDash();
    if (e && t.save(), t.scale(i, n), r.length > 0) {
      const o = Math.max(i, n);
      t.setLineDash(r.map((l) => l / o)), t.lineDashOffset /= o;
    }
    t.stroke(), e && t.restore();
  }
  isContentVisible() {
    for (let e = this.markedContentStack.length - 1; e >= 0; e--)
      if (!this.markedContentStack[e].visible)
        return !1;
    return !0;
  }
};
Hs = new WeakSet(), lp = function() {
  for (; this.stateStack.length || this.inSMaskMode; )
    this.restore();
  this.current.activeSMask = null, this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
}, hp = function() {
  if (this.pageColors) {
    const e = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
    if (e !== "none") {
      const t = this.ctx.filter;
      this.ctx.filter = e, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = t;
    }
  }
}, cp = function(e, t, s) {
  const i = new Path2D();
  return i.addPath(e, new DOMMatrix(s).invertSelf().multiplySelf(t)), i;
};
let no = $g;
for (const h in xs)
  no.prototype[h] !== void 0 && (no.prototype[xs[h]] = no.prototype[h]);
var kd, Kh, Qh;
let yr = (kd = class {
  static get workerPort() {
    return a(this, Kh);
  }
  static set workerPort(e) {
    if (!(typeof Worker < "u" && e instanceof Worker) && e !== null)
      throw new Error("Invalid `workerPort` type.");
    p(this, Kh, e);
  }
  static get workerSrc() {
    return a(this, Qh);
  }
  static set workerSrc(e) {
    if (typeof e != "string")
      throw new Error("Invalid `workerSrc` type.");
    p(this, Qh, e);
  }
}, Kh = new WeakMap(), Qh = new WeakMap(), b(kd, Kh, null), b(kd, Qh, ""), kd);
var Wr, Zh;
class QA {
  constructor({
    parsedData: e,
    rawData: t
  }) {
    b(this, Wr);
    b(this, Zh);
    p(this, Wr, e), p(this, Zh, t);
  }
  getRaw() {
    return a(this, Zh);
  }
  get(e) {
    return a(this, Wr).get(e) ?? null;
  }
  getAll() {
    return _g(a(this, Wr));
  }
  has(e) {
    return a(this, Wr).has(e);
  }
}
Wr = new WeakMap(), Zh = new WeakMap();
const Qa = Symbol("INTERNAL");
var Jh, qh, tc, To;
class ZA {
  constructor(e, {
    name: t,
    intent: s,
    usage: i,
    rbGroups: n
  }) {
    b(this, Jh, !1);
    b(this, qh, !1);
    b(this, tc, !1);
    b(this, To, !0);
    p(this, Jh, !!(e & rs.DISPLAY)), p(this, qh, !!(e & rs.PRINT)), this.name = t, this.intent = s, this.usage = i, this.rbGroups = n;
  }
  get visible() {
    if (a(this, tc))
      return a(this, To);
    if (!a(this, To))
      return !1;
    const {
      print: e,
      view: t
    } = this.usage;
    return a(this, Jh) ? (t == null ? void 0 : t.viewState) !== "OFF" : a(this, qh) ? (e == null ? void 0 : e.printState) !== "OFF" : !0;
  }
  _setVisible(e, t, s = !1) {
    e !== Qa && Pt("Internal method `_setVisible` called."), p(this, tc, s), p(this, To, t);
  }
}
Jh = new WeakMap(), qh = new WeakMap(), tc = new WeakMap(), To = new WeakMap();
var Rn, bt, Po, Co, ec, dp;
class JA {
  constructor(e, t = rs.DISPLAY) {
    b(this, ec);
    b(this, Rn, null);
    b(this, bt, /* @__PURE__ */ new Map());
    b(this, Po, null);
    b(this, Co, null);
    if (this.renderingIntent = t, this.name = null, this.creator = null, e !== null) {
      this.name = e.name, this.creator = e.creator, p(this, Co, e.order);
      for (const s of e.groups)
        a(this, bt).set(s.id, new ZA(t, s));
      if (e.baseState === "OFF")
        for (const s of a(this, bt).values())
          s._setVisible(Qa, !1);
      for (const s of e.on)
        a(this, bt).get(s)._setVisible(Qa, !0);
      for (const s of e.off)
        a(this, bt).get(s)._setVisible(Qa, !1);
      p(this, Po, this.getHash());
    }
  }
  isVisible(e) {
    if (a(this, bt).size === 0)
      return !0;
    if (!e)
      return af("Optional content group not defined."), !0;
    if (e.type === "OCG")
      return a(this, bt).has(e.id) ? a(this, bt).get(e.id).visible : (tt(`Optional content group not found: ${e.id}`), !0);
    if (e.type === "OCMD") {
      if (e.expression)
        return v(this, ec, dp).call(this, e.expression);
      if (!e.policy || e.policy === "AnyOn") {
        for (const t of e.ids) {
          if (!a(this, bt).has(t))
            return tt(`Optional content group not found: ${t}`), !0;
          if (a(this, bt).get(t).visible)
            return !0;
        }
        return !1;
      } else if (e.policy === "AllOn") {
        for (const t of e.ids) {
          if (!a(this, bt).has(t))
            return tt(`Optional content group not found: ${t}`), !0;
          if (!a(this, bt).get(t).visible)
            return !1;
        }
        return !0;
      } else if (e.policy === "AnyOff") {
        for (const t of e.ids) {
          if (!a(this, bt).has(t))
            return tt(`Optional content group not found: ${t}`), !0;
          if (!a(this, bt).get(t).visible)
            return !0;
        }
        return !1;
      } else if (e.policy === "AllOff") {
        for (const t of e.ids) {
          if (!a(this, bt).has(t))
            return tt(`Optional content group not found: ${t}`), !0;
          if (a(this, bt).get(t).visible)
            return !1;
        }
        return !0;
      }
      return tt(`Unknown optional content policy ${e.policy}.`), !0;
    }
    return tt(`Unknown group type ${e.type}.`), !0;
  }
  setVisibility(e, t = !0, s = !0) {
    var n;
    const i = a(this, bt).get(e);
    if (!i) {
      tt(`Optional content group not found: ${e}`);
      return;
    }
    if (s && t && i.rbGroups.length)
      for (const r of i.rbGroups)
        for (const o of r)
          o !== e && ((n = a(this, bt).get(o)) == null || n._setVisible(Qa, !1, !0));
    i._setVisible(Qa, !!t, !0), p(this, Rn, null);
  }
  setOCGState({
    state: e,
    preserveRB: t
  }) {
    let s;
    for (const i of e) {
      switch (i) {
        case "ON":
        case "OFF":
        case "Toggle":
          s = i;
          continue;
      }
      const n = a(this, bt).get(i);
      if (n)
        switch (s) {
          case "ON":
            this.setVisibility(i, !0, t);
            break;
          case "OFF":
            this.setVisibility(i, !1, t);
            break;
          case "Toggle":
            this.setVisibility(i, !n.visible, t);
            break;
        }
    }
    p(this, Rn, null);
  }
  get hasInitialVisibility() {
    return a(this, Po) === null || this.getHash() === a(this, Po);
  }
  getOrder() {
    return a(this, bt).size ? a(this, Co) ? a(this, Co).slice() : [...a(this, bt).keys()] : null;
  }
  getGroups() {
    return a(this, bt).size > 0 ? _g(a(this, bt)) : null;
  }
  getGroup(e) {
    return a(this, bt).get(e) || null;
  }
  getHash() {
    if (a(this, Rn) !== null)
      return a(this, Rn);
    const e = new Ov();
    for (const [t, s] of a(this, bt))
      e.update(`${t}:${s.visible}`);
    return p(this, Rn, e.hexdigest());
  }
}
Rn = new WeakMap(), bt = new WeakMap(), Po = new WeakMap(), Co = new WeakMap(), ec = new WeakSet(), dp = function(e) {
  const t = e.length;
  if (t < 2)
    return !0;
  const s = e[0];
  for (let i = 1; i < t; i++) {
    const n = e[i];
    let r;
    if (Array.isArray(n))
      r = v(this, ec, dp).call(this, n);
    else if (a(this, bt).has(n))
      r = a(this, bt).get(n).visible;
    else
      return tt(`Optional content group not found: ${n}`), !0;
    switch (s) {
      case "And":
        if (!r)
          return !1;
        break;
      case "Or":
        if (r)
          return !0;
        break;
      case "Not":
        return !r;
      default:
        return !0;
    }
  }
  return s === "And";
};
class qA {
  constructor(e, {
    disableRange: t = !1,
    disableStream: s = !1
  }) {
    Wt(e, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
    const {
      length: i,
      initialData: n,
      progressiveDone: r,
      contentDispositionFilename: o
    } = e;
    if (this._queuedChunks = [], this._progressiveDone = r, this._contentDispositionFilename = o, (n == null ? void 0 : n.length) > 0) {
      const l = n instanceof Uint8Array && n.byteLength === n.buffer.byteLength ? n.buffer : new Uint8Array(n).buffer;
      this._queuedChunks.push(l);
    }
    this._pdfDataRangeTransport = e, this._isStreamingSupported = !s, this._isRangeSupported = !t, this._contentLength = i, this._fullRequestReader = null, this._rangeReaders = [], e.addRangeListener((l, c) => {
      this._onReceiveData({
        begin: l,
        chunk: c
      });
    }), e.addProgressListener((l, c) => {
      this._onProgress({
        loaded: l,
        total: c
      });
    }), e.addProgressiveReadListener((l) => {
      this._onReceiveData({
        chunk: l
      });
    }), e.addProgressiveDoneListener(() => {
      this._onProgressiveDone();
    }), e.transportReady();
  }
  _onReceiveData({
    begin: e,
    chunk: t
  }) {
    const s = t instanceof Uint8Array && t.byteLength === t.buffer.byteLength ? t.buffer : new Uint8Array(t).buffer;
    if (e === void 0)
      this._fullRequestReader ? this._fullRequestReader._enqueue(s) : this._queuedChunks.push(s);
    else {
      const i = this._rangeReaders.some(function(n) {
        return n._begin !== e ? !1 : (n._enqueue(s), !0);
      });
      Wt(i, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
    }
  }
  get _progressiveDataLength() {
    var e;
    return ((e = this._fullRequestReader) == null ? void 0 : e._loaded) ?? 0;
  }
  _onProgress(e) {
    var t, s, i, n;
    e.total === void 0 ? (s = (t = this._rangeReaders[0]) == null ? void 0 : t.onProgress) == null || s.call(t, {
      loaded: e.loaded
    }) : (n = (i = this._fullRequestReader) == null ? void 0 : i.onProgress) == null || n.call(i, {
      loaded: e.loaded,
      total: e.total
    });
  }
  _onProgressiveDone() {
    var e;
    (e = this._fullRequestReader) == null || e.progressiveDone(), this._progressiveDone = !0;
  }
  _removeRangeReader(e) {
    const t = this._rangeReaders.indexOf(e);
    t >= 0 && this._rangeReaders.splice(t, 1);
  }
  getFullReader() {
    Wt(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
    const e = this._queuedChunks;
    return this._queuedChunks = null, new tw(this, e, this._progressiveDone, this._contentDispositionFilename);
  }
  getRangeReader(e, t) {
    if (t <= this._progressiveDataLength)
      return null;
    const s = new ew(this, e, t);
    return this._pdfDataRangeTransport.requestDataRange(e, t), this._rangeReaders.push(s), s;
  }
  cancelAllRequests(e) {
    var t;
    (t = this._fullRequestReader) == null || t.cancel(e);
    for (const s of this._rangeReaders.slice(0))
      s.cancel(e);
    this._pdfDataRangeTransport.abort();
  }
}
class tw {
  constructor(e, t, s = !1, i = null) {
    this._stream = e, this._done = s || !1, this._filename = Og(i) ? i : null, this._queuedChunks = t || [], this._loaded = 0;
    for (const n of this._queuedChunks)
      this._loaded += n.byteLength;
    this._requests = [], this._headersReady = Promise.resolve(), e._fullRequestReader = this, this.onProgress = null;
  }
  _enqueue(e) {
    this._done || (this._requests.length > 0 ? this._requests.shift().resolve({
      value: e,
      done: !1
    }) : this._queuedChunks.push(e), this._loaded += e.byteLength);
  }
  get headersReady() {
    return this._headersReady;
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._stream._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._stream._isStreamingSupported;
  }
  get contentLength() {
    return this._stream._contentLength;
  }
  async read() {
    if (this._queuedChunks.length > 0)
      return {
        value: this._queuedChunks.shift(),
        done: !1
      };
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const e = Promise.withResolvers();
    return this._requests.push(e), e.promise;
  }
  cancel(e) {
    this._done = !0;
    for (const t of this._requests)
      t.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0;
  }
  progressiveDone() {
    this._done || (this._done = !0);
  }
}
class ew {
  constructor(e, t, s) {
    this._stream = e, this._begin = t, this._end = s, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
  }
  _enqueue(e) {
    if (!this._done) {
      if (this._requests.length === 0)
        this._queuedChunk = e;
      else {
        this._requests.shift().resolve({
          value: e,
          done: !1
        });
        for (const s of this._requests)
          s.resolve({
            value: void 0,
            done: !0
          });
        this._requests.length = 0;
      }
      this._done = !0, this._stream._removeRangeReader(this);
    }
  }
  get isStreamingSupported() {
    return !1;
  }
  async read() {
    if (this._queuedChunk) {
      const t = this._queuedChunk;
      return this._queuedChunk = null, {
        value: t,
        done: !1
      };
    }
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const e = Promise.withResolvers();
    return this._requests.push(e), e.promise;
  }
  cancel(e) {
    this._done = !0;
    for (const t of this._requests)
      t.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._stream._removeRangeReader(this);
  }
}
function sw(h) {
  let e = !0, t = s("filename\\*", "i").exec(h);
  if (t) {
    t = t[1];
    let d = o(t);
    return d = unescape(d), d = l(d), d = c(d), n(d);
  }
  if (t = r(h), t) {
    const d = c(t);
    return n(d);
  }
  if (t = s("filename", "i").exec(h), t) {
    t = t[1];
    let d = o(t);
    return d = c(d), n(d);
  }
  function s(d, u) {
    return new RegExp("(?:^|;)\\s*" + d + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', u);
  }
  function i(d, u) {
    if (d) {
      if (!/^[\x00-\xFF]+$/.test(u))
        return u;
      try {
        const f = new TextDecoder(d, {
          fatal: !0
        }), g = of(u);
        u = f.decode(g), e = !1;
      } catch {
      }
    }
    return u;
  }
  function n(d) {
    return e && /[\x80-\xff]/.test(d) && (d = i("utf-8", d), e && (d = i("iso-8859-1", d))), d;
  }
  function r(d) {
    const u = [];
    let f;
    const g = s("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
    for (; (f = g.exec(d)) !== null; ) {
      let [, y, w, A] = f;
      if (y = parseInt(y, 10), y in u) {
        if (y === 0)
          break;
        continue;
      }
      u[y] = [w, A];
    }
    const m = [];
    for (let y = 0; y < u.length && y in u; ++y) {
      let [w, A] = u[y];
      A = o(A), w && (A = unescape(A), y === 0 && (A = l(A))), m.push(A);
    }
    return m.join("");
  }
  function o(d) {
    if (d.startsWith('"')) {
      const u = d.slice(1).split('\\"');
      for (let f = 0; f < u.length; ++f) {
        const g = u[f].indexOf('"');
        g !== -1 && (u[f] = u[f].slice(0, g), u.length = f + 1), u[f] = u[f].replaceAll(/\\(.)/g, "$1");
      }
      d = u.join('"');
    }
    return d;
  }
  function l(d) {
    const u = d.indexOf("'");
    if (u === -1)
      return d;
    const f = d.slice(0, u), m = d.slice(u + 1).replace(/^[^']*'/, "");
    return i(f, m);
  }
  function c(d) {
    return !d.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(d) ? d : d.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(u, f, g, m) {
      if (g === "q" || g === "Q")
        return m = m.replaceAll("_", " "), m = m.replaceAll(/=([0-9a-fA-F]{2})/g, function(y, w) {
          return String.fromCharCode(parseInt(w, 16));
        }), i(f, m);
      try {
        m = atob(m);
      } catch {
      }
      return i(f, m);
    });
  }
  return "";
}
function Xv(h, e) {
  const t = new Headers();
  if (!h || !e || typeof e != "object")
    return t;
  for (const s in e) {
    const i = e[s];
    i !== void 0 && t.append(s, i);
  }
  return t;
}
function cf(h) {
  try {
    return new URL(h).origin;
  } catch {
  }
  return null;
}
function Yv({
  responseHeaders: h,
  isHttp: e,
  rangeChunkSize: t,
  disableRange: s
}) {
  const i = {
    allowRangeRequests: !1,
    suggestedLength: void 0
  }, n = parseInt(h.get("Content-Length"), 10);
  return !Number.isInteger(n) || (i.suggestedLength = n, n <= 2 * t) || s || !e || h.get("Accept-Ranges") !== "bytes" || (h.get("Content-Encoding") || "identity") !== "identity" || (i.allowRangeRequests = !0), i;
}
function Kv(h) {
  const e = h.get("Content-Disposition");
  if (e) {
    let t = sw(e);
    if (t.includes("%"))
      try {
        t = decodeURIComponent(t);
      } catch {
      }
    if (Og(t))
      return t;
  }
  return null;
}
function df(h, e) {
  return h === 404 || h === 0 && e.startsWith("file:") ? new mh('Missing PDF "' + e + '".') : new Tu(`Unexpected server response (${h}) while retrieving PDF "${e}".`, h);
}
function Qv(h) {
  return h === 200 || h === 206;
}
function Zv(h, e, t) {
  return {
    method: "GET",
    headers: h,
    signal: t.signal,
    mode: "cors",
    credentials: e ? "include" : "same-origin",
    redirect: "follow"
  };
}
function Jv(h) {
  return h instanceof Uint8Array ? h.buffer : h instanceof ArrayBuffer ? h : (tt(`getArrayBuffer - unexpected data format: ${h}`), new Uint8Array(h).buffer);
}
class dm {
  constructor(e) {
    K(this, "_responseOrigin", null);
    this.source = e, this.isHttp = /^https?:/i.test(e.url), this.headers = Xv(this.isHttp, e.httpHeaders), this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    var e;
    return ((e = this._fullRequestReader) == null ? void 0 : e._loaded) ?? 0;
  }
  getFullReader() {
    return Wt(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new iw(this), this._fullRequestReader;
  }
  getRangeReader(e, t) {
    if (t <= this._progressiveDataLength)
      return null;
    const s = new nw(this, e, t);
    return this._rangeRequestReaders.push(s), s;
  }
  cancelAllRequests(e) {
    var t;
    (t = this._fullRequestReader) == null || t.cancel(e);
    for (const s of this._rangeRequestReaders.slice(0))
      s.cancel(e);
  }
}
class iw {
  constructor(e) {
    this._stream = e, this._reader = null, this._loaded = 0, this._filename = null;
    const t = e.source;
    this._withCredentials = t.withCredentials || !1, this._contentLength = t.length, this._headersCapability = Promise.withResolvers(), this._disableRange = t.disableRange || !1, this._rangeChunkSize = t.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !t.disableStream, this._isRangeSupported = !t.disableRange;
    const s = new Headers(e.headers), i = t.url;
    fetch(i, Zv(s, this._withCredentials, this._abortController)).then((n) => {
      if (e._responseOrigin = cf(n.url), !Qv(n.status))
        throw df(n.status, i);
      this._reader = n.body.getReader(), this._headersCapability.resolve();
      const r = n.headers, {
        allowRangeRequests: o,
        suggestedLength: l
      } = Yv({
        responseHeaders: r,
        isHttp: e.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = o, this._contentLength = l || this._contentLength, this._filename = Kv(r), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new dr("Streaming is disabled."));
    }).catch(this._headersCapability.reject), this.onProgress = null;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var s;
    await this._headersCapability.promise;
    const {
      value: e,
      done: t
    } = await this._reader.read();
    return t ? {
      value: e,
      done: t
    } : (this._loaded += e.byteLength, (s = this.onProgress) == null || s.call(this, {
      loaded: this._loaded,
      total: this._contentLength
    }), {
      value: Jv(e),
      done: !1
    });
  }
  cancel(e) {
    var t;
    (t = this._reader) == null || t.cancel(e), this._abortController.abort();
  }
}
class nw {
  constructor(e, t, s) {
    this._stream = e, this._reader = null, this._loaded = 0;
    const i = e.source;
    this._withCredentials = i.withCredentials || !1, this._readCapability = Promise.withResolvers(), this._isStreamingSupported = !i.disableStream, this._abortController = new AbortController();
    const n = new Headers(e.headers);
    n.append("Range", `bytes=${t}-${s - 1}`);
    const r = i.url;
    fetch(r, Zv(n, this._withCredentials, this._abortController)).then((o) => {
      const l = cf(o.url);
      if (l !== e._responseOrigin)
        throw new Error(`Expected range response-origin "${l}" to match "${e._responseOrigin}".`);
      if (!Qv(o.status))
        throw df(o.status, r);
      this._readCapability.resolve(), this._reader = o.body.getReader();
    }).catch(this._readCapability.reject), this.onProgress = null;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var s;
    await this._readCapability.promise;
    const {
      value: e,
      done: t
    } = await this._reader.read();
    return t ? {
      value: e,
      done: t
    } : (this._loaded += e.byteLength, (s = this.onProgress) == null || s.call(this, {
      loaded: this._loaded
    }), {
      value: Jv(e),
      done: !1
    });
  }
  cancel(e) {
    var t;
    (t = this._reader) == null || t.cancel(e), this._abortController.abort();
  }
}
const wf = 200, Ef = 206;
function rw(h) {
  const e = h.response;
  return typeof e != "string" ? e : of(e).buffer;
}
class aw {
  constructor({
    url: e,
    httpHeaders: t,
    withCredentials: s
  }) {
    K(this, "_responseOrigin", null);
    this.url = e, this.isHttp = /^https?:/i.test(e), this.headers = Xv(this.isHttp, t), this.withCredentials = s || !1, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
  }
  request(e) {
    const t = new XMLHttpRequest(), s = this.currXhrId++, i = this.pendingRequests[s] = {
      xhr: t
    };
    t.open("GET", this.url), t.withCredentials = this.withCredentials;
    for (const [n, r] of this.headers)
      t.setRequestHeader(n, r);
    return this.isHttp && "begin" in e && "end" in e ? (t.setRequestHeader("Range", `bytes=${e.begin}-${e.end - 1}`), i.expectedStatus = Ef) : i.expectedStatus = wf, t.responseType = "arraybuffer", Wt(e.onError, "Expected `onError` callback to be provided."), t.onerror = () => {
      e.onError(t.status);
    }, t.onreadystatechange = this.onStateChange.bind(this, s), t.onprogress = this.onProgress.bind(this, s), i.onHeadersReceived = e.onHeadersReceived, i.onDone = e.onDone, i.onError = e.onError, i.onProgress = e.onProgress, t.send(null), s;
  }
  onProgress(e, t) {
    var i;
    const s = this.pendingRequests[e];
    s && ((i = s.onProgress) == null || i.call(s, t));
  }
  onStateChange(e, t) {
    const s = this.pendingRequests[e];
    if (!s)
      return;
    const i = s.xhr;
    if (i.readyState >= 2 && s.onHeadersReceived && (s.onHeadersReceived(), delete s.onHeadersReceived), i.readyState !== 4 || !(e in this.pendingRequests))
      return;
    if (delete this.pendingRequests[e], i.status === 0 && this.isHttp) {
      s.onError(i.status);
      return;
    }
    const n = i.status || wf;
    if (!(n === wf && s.expectedStatus === Ef) && n !== s.expectedStatus) {
      s.onError(i.status);
      return;
    }
    const o = rw(i);
    if (n === Ef) {
      const l = i.getResponseHeader("Content-Range"), c = /bytes (\d+)-(\d+)\/(\d+)/.exec(l);
      c ? s.onDone({
        begin: parseInt(c[1], 10),
        chunk: o
      }) : (tt('Missing or invalid "Content-Range" header.'), s.onError(0));
    } else o ? s.onDone({
      begin: 0,
      chunk: o
    }) : s.onError(i.status);
  }
  getRequestXhr(e) {
    return this.pendingRequests[e].xhr;
  }
  isPendingRequest(e) {
    return e in this.pendingRequests;
  }
  abortRequest(e) {
    const t = this.pendingRequests[e].xhr;
    delete this.pendingRequests[e], t.abort();
  }
}
class ow {
  constructor(e) {
    this._source = e, this._manager = new aw(e), this._rangeChunkSize = e.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  _onRangeRequestReaderClosed(e) {
    const t = this._rangeRequestReaders.indexOf(e);
    t >= 0 && this._rangeRequestReaders.splice(t, 1);
  }
  getFullReader() {
    return Wt(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new lw(this._manager, this._source), this._fullRequestReader;
  }
  getRangeReader(e, t) {
    const s = new hw(this._manager, e, t);
    return s.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(s), s;
  }
  cancelAllRequests(e) {
    var t;
    (t = this._fullRequestReader) == null || t.cancel(e);
    for (const s of this._rangeRequestReaders.slice(0))
      s.cancel(e);
  }
}
class lw {
  constructor(e, t) {
    this._manager = e, this._url = t.url, this._fullRequestId = e.request({
      onHeadersReceived: this._onHeadersReceived.bind(this),
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    }), this._headersCapability = Promise.withResolvers(), this._disableRange = t.disableRange || !1, this._contentLength = t.length, this._rangeChunkSize = t.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
  }
  _onHeadersReceived() {
    const e = this._fullRequestId, t = this._manager.getRequestXhr(e);
    this._manager._responseOrigin = cf(t.responseURL);
    const s = t.getAllResponseHeaders(), i = new Headers(s ? s.trimStart().replace(/[^\S ]+$/, "").split(/[\r\n]+/).map((o) => {
      const [l, ...c] = o.split(": ");
      return [l, c.join(": ")];
    }) : []), {
      allowRangeRequests: n,
      suggestedLength: r
    } = Yv({
      responseHeaders: i,
      isHttp: this._manager.isHttp,
      rangeChunkSize: this._rangeChunkSize,
      disableRange: this._disableRange
    });
    n && (this._isRangeSupported = !0), this._contentLength = r || this._contentLength, this._filename = Kv(i), this._isRangeSupported && this._manager.abortRequest(e), this._headersCapability.resolve();
  }
  _onDone(e) {
    if (e && (this._requests.length > 0 ? this._requests.shift().resolve({
      value: e.chunk,
      done: !1
    }) : this._cachedChunks.push(e.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) {
      for (const t of this._requests)
        t.resolve({
          value: void 0,
          done: !0
        });
      this._requests.length = 0;
    }
  }
  _onError(e) {
    this._storedError = df(e, this._url), this._headersCapability.reject(this._storedError);
    for (const t of this._requests)
      t.reject(this._storedError);
    this._requests.length = 0, this._cachedChunks.length = 0;
  }
  _onProgress(e) {
    var t;
    (t = this.onProgress) == null || t.call(this, {
      loaded: e.loaded,
      total: e.lengthComputable ? e.total : this._contentLength
    });
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get contentLength() {
    return this._contentLength;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  async read() {
    if (await this._headersCapability.promise, this._storedError)
      throw this._storedError;
    if (this._cachedChunks.length > 0)
      return {
        value: this._cachedChunks.shift(),
        done: !1
      };
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const e = Promise.withResolvers();
    return this._requests.push(e), e.promise;
  }
  cancel(e) {
    this._done = !0, this._headersCapability.reject(e);
    for (const t of this._requests)
      t.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
  }
}
class hw {
  constructor(e, t, s) {
    this._manager = e, this._url = e.url, this._requestId = e.request({
      begin: t,
      end: s,
      onHeadersReceived: this._onHeadersReceived.bind(this),
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    }), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
  }
  _onHeadersReceived() {
    var t;
    const e = cf((t = this._manager.getRequestXhr(this._requestId)) == null ? void 0 : t.responseURL);
    e !== this._manager._responseOrigin && (this._storedError = new Error(`Expected range response-origin "${e}" to match "${this._manager._responseOrigin}".`), this._onError(0));
  }
  _close() {
    var e;
    (e = this.onClosed) == null || e.call(this, this);
  }
  _onDone(e) {
    const t = e.chunk;
    this._requests.length > 0 ? this._requests.shift().resolve({
      value: t,
      done: !1
    }) : this._queuedChunk = t, this._done = !0;
    for (const s of this._requests)
      s.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._close();
  }
  _onError(e) {
    this._storedError ?? (this._storedError = df(e, this._url));
    for (const t of this._requests)
      t.reject(this._storedError);
    this._requests.length = 0, this._queuedChunk = null;
  }
  _onProgress(e) {
    var t;
    this.isStreamingSupported || (t = this.onProgress) == null || t.call(this, {
      loaded: e.loaded
    });
  }
  get isStreamingSupported() {
    return !1;
  }
  async read() {
    if (this._storedError)
      throw this._storedError;
    if (this._queuedChunk !== null) {
      const t = this._queuedChunk;
      return this._queuedChunk = null, {
        value: t,
        done: !1
      };
    }
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const e = Promise.withResolvers();
    return this._requests.push(e), e.promise;
  }
  cancel(e) {
    this._done = !0;
    for (const t of this._requests)
      t.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
  }
}
const cw = /^[a-z][a-z0-9\-+.]+:/i;
function dw(h) {
  if (cw.test(h))
    return new URL(h);
  const e = process.getBuiltinModule("url");
  return new URL(e.pathToFileURL(h));
}
class uw {
  constructor(e) {
    this.source = e, this.url = dw(e.url), Wt(this.url.protocol === "file:", "PDFNodeStream only supports file:// URLs."), this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    var e;
    return ((e = this._fullRequestReader) == null ? void 0 : e._loaded) ?? 0;
  }
  getFullReader() {
    return Wt(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = new fw(this), this._fullRequestReader;
  }
  getRangeReader(e, t) {
    if (t <= this._progressiveDataLength)
      return null;
    const s = new pw(this, e, t);
    return this._rangeRequestReaders.push(s), s;
  }
  cancelAllRequests(e) {
    var t;
    (t = this._fullRequestReader) == null || t.cancel(e);
    for (const s of this._rangeRequestReaders.slice(0))
      s.cancel(e);
  }
}
class fw {
  constructor(e) {
    this._url = e.url, this._done = !1, this._storedError = null, this.onProgress = null;
    const t = e.source;
    this._contentLength = t.length, this._loaded = 0, this._filename = null, this._disableRange = t.disableRange || !1, this._rangeChunkSize = t.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !t.disableStream, this._isRangeSupported = !t.disableRange, this._readableStream = null, this._readCapability = Promise.withResolvers(), this._headersCapability = Promise.withResolvers();
    const s = process.getBuiltinModule("fs");
    s.promises.lstat(this._url).then((i) => {
      this._contentLength = i.size, this._setReadableStream(s.createReadStream(this._url)), this._headersCapability.resolve();
    }, (i) => {
      i.code === "ENOENT" && (i = new mh(`Missing PDF "${this._url}".`)), this._storedError = i, this._headersCapability.reject(i);
    });
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var s;
    if (await this._readCapability.promise, this._done)
      return {
        value: void 0,
        done: !0
      };
    if (this._storedError)
      throw this._storedError;
    const e = this._readableStream.read();
    return e === null ? (this._readCapability = Promise.withResolvers(), this.read()) : (this._loaded += e.length, (s = this.onProgress) == null || s.call(this, {
      loaded: this._loaded,
      total: this._contentLength
    }), {
      value: new Uint8Array(e).buffer,
      done: !1
    });
  }
  cancel(e) {
    if (!this._readableStream) {
      this._error(e);
      return;
    }
    this._readableStream.destroy(e);
  }
  _error(e) {
    this._storedError = e, this._readCapability.resolve();
  }
  _setReadableStream(e) {
    this._readableStream = e, e.on("readable", () => {
      this._readCapability.resolve();
    }), e.on("end", () => {
      e.destroy(), this._done = !0, this._readCapability.resolve();
    }), e.on("error", (t) => {
      this._error(t);
    }), !this._isStreamingSupported && this._isRangeSupported && this._error(new dr("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
  }
}
class pw {
  constructor(e, t, s) {
    this._url = e.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = Promise.withResolvers();
    const i = e.source;
    this._isStreamingSupported = !i.disableStream;
    const n = process.getBuiltinModule("fs");
    this._setReadableStream(n.createReadStream(this._url, {
      start: t,
      end: s - 1
    }));
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var s;
    if (await this._readCapability.promise, this._done)
      return {
        value: void 0,
        done: !0
      };
    if (this._storedError)
      throw this._storedError;
    const e = this._readableStream.read();
    return e === null ? (this._readCapability = Promise.withResolvers(), this.read()) : (this._loaded += e.length, (s = this.onProgress) == null || s.call(this, {
      loaded: this._loaded
    }), {
      value: new Uint8Array(e).buffer,
      done: !1
    });
  }
  cancel(e) {
    if (!this._readableStream) {
      this._error(e);
      return;
    }
    this._readableStream.destroy(e);
  }
  _error(e) {
    this._storedError = e, this._readCapability.resolve();
  }
  _setReadableStream(e) {
    this._readableStream = e, e.on("readable", () => {
      this._readCapability.resolve();
    }), e.on("end", () => {
      e.destroy(), this._done = !0, this._readCapability.resolve();
    }), e.on("error", (t) => {
      this._error(t);
    }), this._storedError && this._readableStream.destroy(this._storedError);
  }
}
const gw = 1e5, ke = 30, mw = 0.8;
var Qm, In, je, sc, ic, Gr, ki, nc, rc, Xr, Ro, Io, _n, _o, ac, Lo, Yr, oc, lc, Ht, Kr, Qr, hc, Ln, Mo, cn, qv, tb, fp, ls, Yd, pp, eb, sb;
let up = (Ht = class {
  constructor({
    textContentSource: e,
    container: t,
    viewport: s
  }) {
    b(this, cn);
    b(this, In, Promise.withResolvers());
    b(this, je, null);
    b(this, sc, !1);
    b(this, ic, !!((Qm = globalThis.FontInspector) != null && Qm.enabled));
    b(this, Gr, null);
    b(this, ki, null);
    b(this, nc, 0);
    b(this, rc, 0);
    b(this, Xr, null);
    b(this, Ro, null);
    b(this, Io, 0);
    b(this, _n, 0);
    b(this, _o, /* @__PURE__ */ Object.create(null));
    b(this, ac, []);
    b(this, Lo, null);
    b(this, Yr, []);
    b(this, oc, /* @__PURE__ */ new WeakMap());
    b(this, lc, null);
    var l;
    if (e instanceof ReadableStream)
      p(this, Lo, e);
    else if (typeof e == "object")
      p(this, Lo, new ReadableStream({
        start(c) {
          c.enqueue(e), c.close();
        }
      }));
    else
      throw new Error('No "textContentSource" parameter specified.');
    p(this, je, p(this, Ro, t)), p(this, _n, s.scale * (globalThis.devicePixelRatio || 1)), p(this, Io, s.rotation), p(this, ki, {
      div: null,
      properties: null,
      ctx: null
    });
    const {
      pageWidth: i,
      pageHeight: n,
      pageX: r,
      pageY: o
    } = s.rawDims;
    p(this, lc, [1, 0, 0, -1, -r, o + n]), p(this, rc, i), p(this, nc, n), v(l = Ht, ls, eb).call(l), Va(t, s), a(this, In).promise.finally(() => {
      a(Ht, Mo).delete(this), p(this, ki, null), p(this, _o, null);
    }).catch(() => {
    });
  }
  static get fontFamilyMap() {
    const {
      isWindows: e,
      isFirefox: t
    } = Oe.platform;
    return ht(this, "fontFamilyMap", /* @__PURE__ */ new Map([["sans-serif", `${e && t ? "Calibri, " : ""}sans-serif`], ["monospace", `${e && t ? "Lucida Console, " : ""}monospace`]]));
  }
  render() {
    const e = () => {
      a(this, Xr).read().then(({
        value: t,
        done: s
      }) => {
        if (s) {
          a(this, In).resolve();
          return;
        }
        a(this, Gr) ?? p(this, Gr, t.lang), Object.assign(a(this, _o), t.styles), v(this, cn, qv).call(this, t.items), e();
      }, a(this, In).reject);
    };
    return p(this, Xr, a(this, Lo).getReader()), a(Ht, Mo).add(this), e(), a(this, In).promise;
  }
  update({
    viewport: e,
    onBefore: t = null
  }) {
    var n;
    const s = e.scale * (globalThis.devicePixelRatio || 1), i = e.rotation;
    if (i !== a(this, Io) && (t == null || t(), p(this, Io, i), Va(a(this, Ro), {
      rotation: i
    })), s !== a(this, _n)) {
      t == null || t(), p(this, _n, s);
      const r = {
        div: null,
        properties: null,
        ctx: v(n = Ht, ls, Yd).call(n, a(this, Gr))
      };
      for (const o of a(this, Yr))
        r.properties = a(this, oc).get(o), r.div = o, v(this, cn, fp).call(this, r);
    }
  }
  cancel() {
    var t;
    const e = new dr("TextLayer task cancelled.");
    (t = a(this, Xr)) == null || t.cancel(e).catch(() => {
    }), p(this, Xr, null), a(this, In).reject(e);
  }
  get textDivs() {
    return a(this, Yr);
  }
  get textContentItemsStr() {
    return a(this, ac);
  }
  static cleanup() {
    if (!(a(this, Mo).size > 0)) {
      a(this, Kr).clear();
      for (const {
        canvas: e
      } of a(this, Qr).values())
        e.remove();
      a(this, Qr).clear();
    }
  }
}, In = new WeakMap(), je = new WeakMap(), sc = new WeakMap(), ic = new WeakMap(), Gr = new WeakMap(), ki = new WeakMap(), nc = new WeakMap(), rc = new WeakMap(), Xr = new WeakMap(), Ro = new WeakMap(), Io = new WeakMap(), _n = new WeakMap(), _o = new WeakMap(), ac = new WeakMap(), Lo = new WeakMap(), Yr = new WeakMap(), oc = new WeakMap(), lc = new WeakMap(), Kr = new WeakMap(), Qr = new WeakMap(), hc = new WeakMap(), Ln = new WeakMap(), Mo = new WeakMap(), cn = new WeakSet(), qv = function(e) {
  var i, n;
  if (a(this, sc))
    return;
  (n = a(this, ki)).ctx ?? (n.ctx = v(i = Ht, ls, Yd).call(i, a(this, Gr)));
  const t = a(this, Yr), s = a(this, ac);
  for (const r of e) {
    if (t.length > gw) {
      tt("Ignoring additional textDivs for performance reasons."), p(this, sc, !0);
      return;
    }
    if (r.str === void 0) {
      if (r.type === "beginMarkedContentProps" || r.type === "beginMarkedContent") {
        const o = a(this, je);
        p(this, je, document.createElement("span")), a(this, je).classList.add("markedContent"), r.id !== null && a(this, je).setAttribute("id", `${r.id}`), o.append(a(this, je));
      } else r.type === "endMarkedContent" && p(this, je, a(this, je).parentNode);
      continue;
    }
    s.push(r.str), v(this, cn, tb).call(this, r);
  }
}, tb = function(e) {
  var y;
  const t = document.createElement("span"), s = {
    angle: 0,
    canvasWidth: 0,
    hasText: e.str !== "",
    hasEOL: e.hasEOL,
    fontSize: 0
  };
  a(this, Yr).push(t);
  const i = X.transform(a(this, lc), e.transform);
  let n = Math.atan2(i[1], i[0]);
  const r = a(this, _o)[e.fontName];
  r.vertical && (n += Math.PI / 2);
  let o = a(this, ic) && r.fontSubstitution || r.fontFamily;
  o = Ht.fontFamilyMap.get(o) || o;
  const l = Math.hypot(i[2], i[3]), c = l * v(y = Ht, ls, sb).call(y, o, a(this, Gr));
  let d, u;
  n === 0 ? (d = i[4], u = i[5] - c) : (d = i[4] + c * Math.sin(n), u = i[5] - c * Math.cos(n));
  const f = "calc(var(--scale-factor)*", g = t.style;
  a(this, je) === a(this, Ro) ? (g.left = `${(100 * d / a(this, rc)).toFixed(2)}%`, g.top = `${(100 * u / a(this, nc)).toFixed(2)}%`) : (g.left = `${f}${d.toFixed(2)}px)`, g.top = `${f}${u.toFixed(2)}px)`), g.fontSize = `${f}${(a(Ht, Ln) * l).toFixed(2)}px)`, g.fontFamily = o, s.fontSize = l, t.setAttribute("role", "presentation"), t.textContent = e.str, t.dir = e.dir, a(this, ic) && (t.dataset.fontName = r.fontSubstitutionLoadedName || e.fontName), n !== 0 && (s.angle = n * (180 / Math.PI));
  let m = !1;
  if (e.str.length > 1)
    m = !0;
  else if (e.str !== " " && e.transform[0] !== e.transform[3]) {
    const w = Math.abs(e.transform[0]), A = Math.abs(e.transform[3]);
    w !== A && Math.max(w, A) / Math.min(w, A) > 1.5 && (m = !0);
  }
  if (m && (s.canvasWidth = r.vertical ? e.height : e.width), a(this, oc).set(t, s), a(this, ki).div = t, a(this, ki).properties = s, v(this, cn, fp).call(this, a(this, ki)), s.hasText && a(this, je).append(t), s.hasEOL) {
    const w = document.createElement("br");
    w.setAttribute("role", "presentation"), a(this, je).append(w);
  }
}, fp = function(e) {
  var o;
  const {
    div: t,
    properties: s,
    ctx: i
  } = e, {
    style: n
  } = t;
  let r = "";
  if (a(Ht, Ln) > 1 && (r = `scale(${1 / a(Ht, Ln)})`), s.canvasWidth !== 0 && s.hasText) {
    const {
      fontFamily: l
    } = n, {
      canvasWidth: c,
      fontSize: d
    } = s;
    v(o = Ht, ls, pp).call(o, i, d * a(this, _n), l);
    const {
      width: u
    } = i.measureText(t.textContent);
    u > 0 && (r = `scaleX(${c * a(this, _n) / u}) ${r}`);
  }
  s.angle !== 0 && (r = `rotate(${s.angle}deg) ${r}`), r.length > 0 && (n.transform = r);
}, ls = new WeakSet(), Yd = function(e = null) {
  let t = a(this, Qr).get(e || (e = ""));
  if (!t) {
    const s = document.createElement("canvas");
    s.className = "hiddenCanvasElement", s.lang = e, document.body.append(s), t = s.getContext("2d", {
      alpha: !1,
      willReadFrequently: !0
    }), a(this, Qr).set(e, t), a(this, hc).set(t, {
      size: 0,
      family: ""
    });
  }
  return t;
}, pp = function(e, t, s) {
  const i = a(this, hc).get(e);
  t === i.size && s === i.family || (e.font = `${t}px ${s}`, i.size = t, i.family = s);
}, eb = function() {
  if (a(this, Ln) !== null)
    return;
  const e = document.createElement("div");
  e.style.opacity = 0, e.style.lineHeight = 1, e.style.fontSize = "1px", e.style.position = "absolute", e.textContent = "X", document.body.append(e), p(this, Ln, e.getBoundingClientRect().height), e.remove();
}, sb = function(e, t) {
  const s = a(this, Kr).get(e);
  if (s)
    return s;
  const i = v(this, ls, Yd).call(this, t);
  i.canvas.width = i.canvas.height = ke, v(this, ls, pp).call(this, i, ke, e);
  const n = i.measureText("");
  let r = n.fontBoundingBoxAscent, o = Math.abs(n.fontBoundingBoxDescent);
  if (r) {
    const d = r / (r + o);
    return a(this, Kr).set(e, d), i.canvas.width = i.canvas.height = 0, d;
  }
  i.strokeStyle = "red", i.clearRect(0, 0, ke, ke), i.strokeText("g", 0, 0);
  let l = i.getImageData(0, 0, ke, ke).data;
  o = 0;
  for (let d = l.length - 1 - 3; d >= 0; d -= 4)
    if (l[d] > 0) {
      o = Math.ceil(d / 4 / ke);
      break;
    }
  i.clearRect(0, 0, ke, ke), i.strokeText("A", 0, ke), l = i.getImageData(0, 0, ke, ke).data, r = 0;
  for (let d = 0, u = l.length; d < u; d += 4)
    if (l[d] > 0) {
      r = ke - Math.floor(d / 4 / ke);
      break;
    }
  i.canvas.width = i.canvas.height = 0;
  const c = r ? r / (r + o) : mw;
  return a(this, Kr).set(e, c), c;
}, b(Ht, ls), b(Ht, Kr, /* @__PURE__ */ new Map()), b(Ht, Qr, /* @__PURE__ */ new Map()), b(Ht, hc, /* @__PURE__ */ new WeakMap()), b(Ht, Ln, null), b(Ht, Mo, /* @__PURE__ */ new Set()), Ht);
class bh {
  static textContent(e) {
    const t = [], s = {
      items: t,
      styles: /* @__PURE__ */ Object.create(null)
    };
    function i(n) {
      var l;
      if (!n)
        return;
      let r = null;
      const o = n.name;
      if (o === "#text")
        r = n.value;
      else if (bh.shouldBuildText(o))
        (l = n == null ? void 0 : n.attributes) != null && l.textContent ? r = n.attributes.textContent : n.value && (r = n.value);
      else return;
      if (r !== null && t.push({
        str: r
      }), !!n.children)
        for (const c of n.children)
          i(c);
    }
    return i(e), s;
  }
  static shouldBuildText(e) {
    return !(e === "textarea" || e === "input" || e === "option" || e === "select");
  }
}
const vw = 65536, bw = 100, yw = 5e3, Aw = Te ? NA : LA, ww = Te ? DA : $v, Ew = Te ? OA : MA, Sw = Te ? kA : Wv;
function xw(h = {}) {
  typeof h == "string" || h instanceof URL ? h = {
    url: h
  } : (h instanceof ArrayBuffer || ArrayBuffer.isView(h)) && (h = {
    data: h
  });
  const e = new gp(), {
    docId: t
  } = e, s = h.url ? Tw(h.url) : null, i = h.data ? Pw(h.data) : null, n = h.httpHeaders || null, r = h.withCredentials === !0, o = h.password ?? null, l = h.range instanceof ib ? h.range : null, c = Number.isInteger(h.rangeChunkSize) && h.rangeChunkSize > 0 ? h.rangeChunkSize : vw;
  let d = h.worker instanceof Qd ? h.worker : null;
  const u = h.verbosity, f = typeof h.docBaseUrl == "string" && !hf(h.docBaseUrl) ? h.docBaseUrl : null, g = typeof h.cMapUrl == "string" ? h.cMapUrl : null, m = h.cMapPacked !== !1, y = h.CMapReaderFactory || ww, w = typeof h.standardFontDataUrl == "string" ? h.standardFontDataUrl : null, A = h.StandardFontDataFactory || Sw, E = h.stopAtErrors !== !0, S = Number.isInteger(h.maxImageSize) && h.maxImageSize > -1 ? h.maxImageSize : -1, T = h.isEvalSupported !== !1, P = typeof h.isOffscreenCanvasSupported == "boolean" ? h.isOffscreenCanvasSupported : !Te, C = typeof h.isImageDecoderSupported == "boolean" ? h.isImageDecoderSupported : !Te && (Oe.platform.isFirefox || !globalThis.chrome), R = Number.isInteger(h.canvasMaxAreaInBytes) ? h.canvasMaxAreaInBytes : -1, _ = typeof h.disableFontFace == "boolean" ? h.disableFontFace : Te, x = h.fontExtraProperties === !0, I = h.enableXfa === !0, L = h.ownerDocument || globalThis.document, j = h.disableRange === !0, k = h.disableStream === !0, F = h.disableAutoFetch === !0, Y = h.pdfBug === !0, N = h.CanvasFactory || Aw, D = h.FilterFactory || Ew, et = h.enableHWA === !0, ft = l ? l.length : h.length ?? NaN, Et = typeof h.useSystemFonts == "boolean" ? h.useSystemFonts : !Te && !_, Dt = typeof h.useWorkerFetch == "boolean" ? h.useWorkerFetch : y === $v && A === Wv && g && w && Ul(g, document.baseURI) && Ul(w, document.baseURI), yt = null;
  hA(u);
  const St = {
    canvasFactory: new N({
      ownerDocument: L,
      enableHWA: et
    }),
    filterFactory: new D({
      docId: t,
      ownerDocument: L
    }),
    cMapReaderFactory: Dt ? null : new y({
      baseUrl: g,
      isCompressed: m
    }),
    standardFontDataFactory: Dt ? null : new A({
      baseUrl: w
    })
  };
  if (!d) {
    const $ = {
      verbosity: u,
      port: yr.workerPort
    };
    d = $.port ? Qd.fromPort($) : new Qd($), e._worker = d;
  }
  const $s = {
    docId: t,
    apiVersion: "4.10.38",
    data: i,
    password: o,
    disableAutoFetch: F,
    rangeChunkSize: c,
    length: ft,
    docBaseUrl: f,
    enableXfa: I,
    evaluatorOptions: {
      maxImageSize: S,
      disableFontFace: _,
      ignoreErrors: E,
      isEvalSupported: T,
      isOffscreenCanvasSupported: P,
      isImageDecoderSupported: C,
      canvasMaxAreaInBytes: R,
      fontExtraProperties: x,
      useSystemFonts: Et,
      cMapUrl: Dt ? g : null,
      standardFontDataUrl: Dt ? w : null
    }
  }, Vs = {
    disableFontFace: _,
    fontExtraProperties: x,
    ownerDocument: L,
    pdfBug: Y,
    styleElement: yt,
    loadingParams: {
      disableAutoFetch: F,
      enableXfa: I
    }
  };
  return d.promise.then(function() {
    if (e.destroyed)
      throw new Error("Loading aborted");
    if (d.destroyed)
      throw new Error("Worker was destroyed");
    const $ = d.messageHandler.sendWithPromise("GetDocRequest", $s, i ? [i.buffer] : null);
    let O;
    if (l)
      O = new qA(l, {
        disableRange: j,
        disableStream: k
      });
    else if (!i) {
      if (!s)
        throw new Error("getDocument - no `url` parameter provided.");
      let H;
      if (Te)
        if (Ul(s)) {
          if (typeof fetch > "u" || typeof Response > "u" || !("body" in Response.prototype))
            throw new Error("getDocument - the Fetch API was disabled in Node.js, see `--no-experimental-fetch`.");
          H = dm;
        } else
          H = uw;
      else
        H = Ul(s) ? dm : ow;
      O = new H({
        url: s,
        length: ft,
        httpHeaders: n,
        withCredentials: r,
        rangeChunkSize: c,
        disableRange: j,
        disableStream: k
      });
    }
    return $.then((H) => {
      if (e.destroyed)
        throw new Error("Loading aborted");
      if (d.destroyed)
        throw new Error("Worker was destroyed");
      const st = new Xl(t, H, d.port), xt = new _w(st, e, O, Vs, St);
      e._transport = xt, st.send("Ready", null);
    });
  }).catch(e._capability.reject), e;
}
function Tw(h) {
  if (h instanceof URL)
    return h.href;
  try {
    return new URL(h, window.location).href;
  } catch {
    if (Te && typeof h == "string")
      return h;
  }
  throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
}
function Pw(h) {
  if (Te && typeof Buffer < "u" && h instanceof Buffer)
    throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
  if (h instanceof Uint8Array && h.byteLength === h.buffer.byteLength)
    return h;
  if (typeof h == "string")
    return of(h);
  if (h instanceof ArrayBuffer || ArrayBuffer.isView(h) || typeof h == "object" && !isNaN(h == null ? void 0 : h.length))
    return new Uint8Array(h);
  throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
}
function um(h) {
  return typeof h == "object" && Number.isInteger(h == null ? void 0 : h.num) && h.num >= 0 && Number.isInteger(h == null ? void 0 : h.gen) && h.gen >= 0;
}
var Uu;
const zu = class zu {
  constructor() {
    this._capability = Promise.withResolvers(), this._transport = null, this._worker = null, this.docId = `d${me(zu, Uu)._++}`, this.destroyed = !1, this.onPassword = null, this.onProgress = null;
  }
  get promise() {
    return this._capability.promise;
  }
  async destroy() {
    var e, t, s, i;
    this.destroyed = !0;
    try {
      (e = this._worker) != null && e.port && (this._worker._pendingDestroy = !0), await ((t = this._transport) == null ? void 0 : t.destroy());
    } catch (n) {
      throw (s = this._worker) != null && s.port && delete this._worker._pendingDestroy, n;
    }
    this._transport = null, (i = this._worker) == null || i.destroy(), this._worker = null;
  }
};
Uu = new WeakMap(), b(zu, Uu, 0);
let gp = zu, ib = class {
  constructor(e, t, s = !1, i = null) {
    this.length = e, this.initialData = t, this.progressiveDone = s, this.contentDispositionFilename = i, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = Promise.withResolvers();
  }
  addRangeListener(e) {
    this._rangeListeners.push(e);
  }
  addProgressListener(e) {
    this._progressListeners.push(e);
  }
  addProgressiveReadListener(e) {
    this._progressiveReadListeners.push(e);
  }
  addProgressiveDoneListener(e) {
    this._progressiveDoneListeners.push(e);
  }
  onDataRange(e, t) {
    for (const s of this._rangeListeners)
      s(e, t);
  }
  onDataProgress(e, t) {
    this._readyCapability.promise.then(() => {
      for (const s of this._progressListeners)
        s(e, t);
    });
  }
  onDataProgressiveRead(e) {
    this._readyCapability.promise.then(() => {
      for (const t of this._progressiveReadListeners)
        t(e);
    });
  }
  onDataProgressiveDone() {
    this._readyCapability.promise.then(() => {
      for (const e of this._progressiveDoneListeners)
        e();
    });
  }
  transportReady() {
    this._readyCapability.resolve();
  }
  requestDataRange(e, t) {
    Pt("Abstract method PDFDataRangeTransport.requestDataRange");
  }
  abort() {
  }
};
class Cw {
  constructor(e, t) {
    this._pdfInfo = e, this._transport = t;
  }
  get annotationStorage() {
    return this._transport.annotationStorage;
  }
  get canvasFactory() {
    return this._transport.canvasFactory;
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get numPages() {
    return this._pdfInfo.numPages;
  }
  get fingerprints() {
    return this._pdfInfo.fingerprints;
  }
  get isPureXfa() {
    return ht(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  get allXfaHtml() {
    return this._transport._htmlForXfa;
  }
  getPage(e) {
    return this._transport.getPage(e);
  }
  getPageIndex(e) {
    return this._transport.getPageIndex(e);
  }
  getDestinations() {
    return this._transport.getDestinations();
  }
  getDestination(e) {
    return this._transport.getDestination(e);
  }
  getPageLabels() {
    return this._transport.getPageLabels();
  }
  getPageLayout() {
    return this._transport.getPageLayout();
  }
  getPageMode() {
    return this._transport.getPageMode();
  }
  getViewerPreferences() {
    return this._transport.getViewerPreferences();
  }
  getOpenAction() {
    return this._transport.getOpenAction();
  }
  getAttachments() {
    return this._transport.getAttachments();
  }
  getJSActions() {
    return this._transport.getDocJSActions();
  }
  getOutline() {
    return this._transport.getOutline();
  }
  getOptionalContentConfig({
    intent: e = "display"
  } = {}) {
    const {
      renderingIntent: t
    } = this._transport.getRenderingIntent(e);
    return this._transport.getOptionalContentConfig(t);
  }
  getPermissions() {
    return this._transport.getPermissions();
  }
  getMetadata() {
    return this._transport.getMetadata();
  }
  getMarkInfo() {
    return this._transport.getMarkInfo();
  }
  getData() {
    return this._transport.getData();
  }
  saveDocument() {
    return this._transport.saveDocument();
  }
  getDownloadInfo() {
    return this._transport.downloadInfoCapability.promise;
  }
  cleanup(e = !1) {
    return this._transport.startCleanup(e || this.isPureXfa);
  }
  destroy() {
    return this.loadingTask.destroy();
  }
  cachedPageNumber(e) {
    return this._transport.cachedPageNumber(e);
  }
  get loadingParams() {
    return this._transport.loadingParams;
  }
  get loadingTask() {
    return this._transport.loadingTask;
  }
  getFieldObjects() {
    return this._transport.getFieldObjects();
  }
  hasJSActions() {
    return this._transport.hasJSActions();
  }
  getCalculationOrderIds() {
    return this._transport.getCalculationOrderIds();
  }
}
var Mn, Fi, As, Za, Kd;
class Rw {
  constructor(e, t, s, i = !1) {
    b(this, As);
    b(this, Mn, null);
    b(this, Fi, !1);
    this._pageIndex = e, this._pageInfo = t, this._transport = s, this._stats = i ? new Jg() : null, this._pdfBug = i, this.commonObjs = s.commonObjs, this.objs = new nb(), this._maybeCleanupAfterRender = !1, this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = !1;
  }
  get pageNumber() {
    return this._pageIndex + 1;
  }
  get rotate() {
    return this._pageInfo.rotate;
  }
  get ref() {
    return this._pageInfo.ref;
  }
  get userUnit() {
    return this._pageInfo.userUnit;
  }
  get view() {
    return this._pageInfo.view;
  }
  getViewport({
    scale: e,
    rotation: t = this.rotate,
    offsetX: s = 0,
    offsetY: i = 0,
    dontFlip: n = !1
  } = {}) {
    return new Ed({
      viewBox: this.view,
      userUnit: this.userUnit,
      scale: e,
      rotation: t,
      offsetX: s,
      offsetY: i,
      dontFlip: n
    });
  }
  getAnnotations({
    intent: e = "display"
  } = {}) {
    const {
      renderingIntent: t
    } = this._transport.getRenderingIntent(e);
    return this._transport.getAnnotations(this._pageIndex, t);
  }
  getJSActions() {
    return this._transport.getPageJSActions(this._pageIndex);
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get isPureXfa() {
    return ht(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  async getXfa() {
    var e;
    return ((e = this._transport._htmlForXfa) == null ? void 0 : e.children[this._pageIndex]) || null;
  }
  render({
    canvasContext: e,
    viewport: t,
    intent: s = "display",
    annotationMode: i = gn.ENABLE,
    transform: n = null,
    background: r = null,
    optionalContentConfigPromise: o = null,
    annotationCanvasMap: l = null,
    pageColors: c = null,
    printAnnotationStorage: d = null,
    isEditing: u = !1
  }) {
    var T, P;
    (T = this._stats) == null || T.time("Overall");
    const f = this._transport.getRenderingIntent(s, i, d, u), {
      renderingIntent: g,
      cacheKey: m
    } = f;
    p(this, Fi, !1), v(this, As, Kd).call(this), o || (o = this._transport.getOptionalContentConfig(g));
    let y = this._intentStates.get(m);
    y || (y = /* @__PURE__ */ Object.create(null), this._intentStates.set(m, y)), y.streamReaderCancelTimeout && (clearTimeout(y.streamReaderCancelTimeout), y.streamReaderCancelTimeout = null);
    const w = !!(g & rs.PRINT);
    y.displayReadyCapability || (y.displayReadyCapability = Promise.withResolvers(), y.operatorList = {
      fnArray: [],
      argsArray: [],
      lastChunk: !1,
      separateAnnots: null
    }, (P = this._stats) == null || P.time("Page Request"), this._pumpOperatorList(f));
    const A = (C) => {
      var R;
      y.renderTasks.delete(E), (this._maybeCleanupAfterRender || w) && p(this, Fi, !0), v(this, As, Za).call(this, !w), C ? (E.capability.reject(C), this._abortOperatorList({
        intentState: y,
        reason: C instanceof Error ? C : new Error(C)
      })) : E.capability.resolve(), this._stats && (this._stats.timeEnd("Rendering"), this._stats.timeEnd("Overall"), (R = globalThis.Stats) != null && R.enabled && globalThis.Stats.add(this.pageNumber, this._stats));
    }, E = new vp({
      callback: A,
      params: {
        canvasContext: e,
        viewport: t,
        transform: n,
        background: r
      },
      objs: this.objs,
      commonObjs: this.commonObjs,
      annotationCanvasMap: l,
      operatorList: y.operatorList,
      pageIndex: this._pageIndex,
      canvasFactory: this._transport.canvasFactory,
      filterFactory: this._transport.filterFactory,
      useRequestAnimationFrame: !w,
      pdfBug: this._pdfBug,
      pageColors: c
    });
    (y.renderTasks || (y.renderTasks = /* @__PURE__ */ new Set())).add(E);
    const S = E.task;
    return Promise.all([y.displayReadyCapability.promise, o]).then(([C, R]) => {
      var _;
      if (this.destroyed) {
        A();
        return;
      }
      if ((_ = this._stats) == null || _.time("Rendering"), !(R.renderingIntent & g))
        throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.");
      E.initializeGraphics({
        transparency: C,
        optionalContentConfig: R
      }), E.operatorListChanged();
    }).catch(A), S;
  }
  getOperatorList({
    intent: e = "display",
    annotationMode: t = gn.ENABLE,
    printAnnotationStorage: s = null,
    isEditing: i = !1
  } = {}) {
    var c;
    function n() {
      o.operatorList.lastChunk && (o.opListReadCapability.resolve(o.operatorList), o.renderTasks.delete(l));
    }
    const r = this._transport.getRenderingIntent(e, t, s, i, !0);
    let o = this._intentStates.get(r.cacheKey);
    o || (o = /* @__PURE__ */ Object.create(null), this._intentStates.set(r.cacheKey, o));
    let l;
    return o.opListReadCapability || (l = /* @__PURE__ */ Object.create(null), l.operatorListChanged = n, o.opListReadCapability = Promise.withResolvers(), (o.renderTasks || (o.renderTasks = /* @__PURE__ */ new Set())).add(l), o.operatorList = {
      fnArray: [],
      argsArray: [],
      lastChunk: !1,
      separateAnnots: null
    }, (c = this._stats) == null || c.time("Page Request"), this._pumpOperatorList(r)), o.opListReadCapability.promise;
  }
  streamTextContent({
    includeMarkedContent: e = !1,
    disableNormalization: t = !1
  } = {}) {
    return this._transport.messageHandler.sendWithStream("GetTextContent", {
      pageIndex: this._pageIndex,
      includeMarkedContent: e === !0,
      disableNormalization: t === !0
    }, {
      highWaterMark: 100,
      size(i) {
        return i.items.length;
      }
    });
  }
  getTextContent(e = {}) {
    if (this._transport._htmlForXfa)
      return this.getXfa().then((s) => bh.textContent(s));
    const t = this.streamTextContent(e);
    return new Promise(function(s, i) {
      function n() {
        r.read().then(function({
          value: l,
          done: c
        }) {
          if (c) {
            s(o);
            return;
          }
          o.lang ?? (o.lang = l.lang), Object.assign(o.styles, l.styles), o.items.push(...l.items), n();
        }, i);
      }
      const r = t.getReader(), o = {
        items: [],
        styles: /* @__PURE__ */ Object.create(null),
        lang: null
      };
      n();
    });
  }
  getStructTree() {
    return this._transport.getStructTree(this._pageIndex);
  }
  _destroy() {
    this.destroyed = !0;
    const e = [];
    for (const t of this._intentStates.values())
      if (this._abortOperatorList({
        intentState: t,
        reason: new Error("Page was destroyed."),
        force: !0
      }), !t.opListReadCapability)
        for (const s of t.renderTasks)
          e.push(s.completed), s.cancel();
    return this.objs.clear(), p(this, Fi, !1), v(this, As, Kd).call(this), Promise.all(e);
  }
  cleanup(e = !1) {
    p(this, Fi, !0);
    const t = v(this, As, Za).call(this, !1);
    return e && t && this._stats && (this._stats = new Jg()), t;
  }
  _startRenderPage(e, t) {
    var i, n;
    const s = this._intentStates.get(t);
    s && ((i = this._stats) == null || i.timeEnd("Page Request"), (n = s.displayReadyCapability) == null || n.resolve(e));
  }
  _renderPageChunk(e, t) {
    for (let s = 0, i = e.length; s < i; s++)
      t.operatorList.fnArray.push(e.fnArray[s]), t.operatorList.argsArray.push(e.argsArray[s]);
    t.operatorList.lastChunk = e.lastChunk, t.operatorList.separateAnnots = e.separateAnnots;
    for (const s of t.renderTasks)
      s.operatorListChanged();
    e.lastChunk && v(this, As, Za).call(this, !0);
  }
  _pumpOperatorList({
    renderingIntent: e,
    cacheKey: t,
    annotationStorageSerializable: s,
    modifiedIds: i
  }) {
    const {
      map: n,
      transfer: r
    } = s, l = this._transport.messageHandler.sendWithStream("GetOperatorList", {
      pageIndex: this._pageIndex,
      intent: e,
      cacheKey: t,
      annotationStorage: n,
      modifiedIds: i
    }, r).getReader(), c = this._intentStates.get(t);
    c.streamReader = l;
    const d = () => {
      l.read().then(({
        value: u,
        done: f
      }) => {
        if (f) {
          c.streamReader = null;
          return;
        }
        this._transport.destroyed || (this._renderPageChunk(u, c), d());
      }, (u) => {
        if (c.streamReader = null, !this._transport.destroyed) {
          if (c.operatorList) {
            c.operatorList.lastChunk = !0;
            for (const f of c.renderTasks)
              f.operatorListChanged();
            v(this, As, Za).call(this, !0);
          }
          if (c.displayReadyCapability)
            c.displayReadyCapability.reject(u);
          else if (c.opListReadCapability)
            c.opListReadCapability.reject(u);
          else
            throw u;
        }
      });
    };
    d();
  }
  _abortOperatorList({
    intentState: e,
    reason: t,
    force: s = !1
  }) {
    if (e.streamReader) {
      if (e.streamReaderCancelTimeout && (clearTimeout(e.streamReaderCancelTimeout), e.streamReaderCancelTimeout = null), !s) {
        if (e.renderTasks.size > 0)
          return;
        if (t instanceof Mg) {
          let i = bw;
          t.extraDelay > 0 && t.extraDelay < 1e3 && (i += t.extraDelay), e.streamReaderCancelTimeout = setTimeout(() => {
            e.streamReaderCancelTimeout = null, this._abortOperatorList({
              intentState: e,
              reason: t,
              force: !0
            });
          }, i);
          return;
        }
      }
      if (e.streamReader.cancel(new dr(t.message)).catch(() => {
      }), e.streamReader = null, !this._transport.destroyed) {
        for (const [i, n] of this._intentStates)
          if (n === e) {
            this._intentStates.delete(i);
            break;
          }
        this.cleanup();
      }
    }
  }
  get stats() {
    return this._stats;
  }
}
Mn = new WeakMap(), Fi = new WeakMap(), As = new WeakSet(), Za = function(e = !1) {
  if (v(this, As, Kd).call(this), !a(this, Fi) || this.destroyed)
    return !1;
  if (e)
    return p(this, Mn, setTimeout(() => {
      p(this, Mn, null), v(this, As, Za).call(this, !1);
    }, yw)), !1;
  for (const {
    renderTasks: t,
    operatorList: s
  } of this._intentStates.values())
    if (t.size > 0 || !s.lastChunk)
      return !1;
  return this._intentStates.clear(), this.objs.clear(), p(this, Fi, !1), !0;
}, Kd = function() {
  a(this, Mn) && (clearTimeout(a(this, Mn)), p(this, Mn, null));
};
var Bi, Wu;
class Iw {
  constructor() {
    b(this, Bi, /* @__PURE__ */ new Map());
    b(this, Wu, Promise.resolve());
  }
  postMessage(e, t) {
    const s = {
      data: structuredClone(e, t ? {
        transfer: t
      } : null)
    };
    a(this, Wu).then(() => {
      for (const [i] of a(this, Bi))
        i.call(this, s);
    });
  }
  addEventListener(e, t, s = null) {
    let i = null;
    if ((s == null ? void 0 : s.signal) instanceof AbortSignal) {
      const {
        signal: n
      } = s;
      if (n.aborted) {
        tt("LoopbackPort - cannot use an `aborted` signal.");
        return;
      }
      const r = () => this.removeEventListener(e, t);
      i = () => n.removeEventListener("abort", r), n.addEventListener("abort", r);
    }
    a(this, Bi).set(t, i);
  }
  removeEventListener(e, t) {
    const s = a(this, Bi).get(t);
    s == null || s(), a(this, Bi).delete(t);
  }
  terminate() {
    for (const [, e] of a(this, Bi))
      e == null || e();
    a(this, Bi).clear();
  }
}
Bi = new WeakMap(), Wu = new WeakMap();
var Tt, Gu, Zr, Jr, Oo, Zd, No, Jd;
let Qd = (Tt = class {
  constructor({
    name: e = null,
    port: t = null,
    verbosity: s = cA()
  } = {}) {
    b(this, Oo);
    var i;
    if (this.name = e, this.destroyed = !1, this.verbosity = s, this._readyCapability = Promise.withResolvers(), this._port = null, this._webWorker = null, this._messageHandler = null, t) {
      if ((i = a(Tt, Jr)) != null && i.has(t))
        throw new Error("Cannot use more than one PDFWorker per port.");
      (a(Tt, Jr) || p(Tt, Jr, /* @__PURE__ */ new WeakMap())).set(t, this), this._initializeFromPort(t);
      return;
    }
    this._initialize();
  }
  get promise() {
    return this._readyCapability.promise;
  }
  get port() {
    return this._port;
  }
  get messageHandler() {
    return this._messageHandler;
  }
  _initializeFromPort(e) {
    this._port = e, this._messageHandler = new Xl("main", "worker", e), this._messageHandler.on("ready", function() {
    }), v(this, Oo, Zd).call(this);
  }
  _initialize() {
    if (a(Tt, Zr) || a(Tt, No, Jd)) {
      this._setupFakeWorker();
      return;
    }
    let {
      workerSrc: e
    } = Tt;
    try {
      Tt._isSameOrigin(window.location.href, e) || (e = Tt._createCDNWrapper(new URL(e, window.location).href));
      const t = new Worker(e, {
        type: "module"
      }), s = new Xl("main", "worker", t), i = () => {
        n.abort(), s.destroy(), t.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
      }, n = new AbortController();
      t.addEventListener("error", () => {
        this._webWorker || i();
      }, {
        signal: n.signal
      }), s.on("test", (o) => {
        if (n.abort(), this.destroyed || !o) {
          i();
          return;
        }
        this._messageHandler = s, this._port = t, this._webWorker = t, v(this, Oo, Zd).call(this);
      }), s.on("ready", (o) => {
        if (n.abort(), this.destroyed) {
          i();
          return;
        }
        try {
          r();
        } catch {
          this._setupFakeWorker();
        }
      });
      const r = () => {
        const o = new Uint8Array();
        s.send("test", o, [o.buffer]);
      };
      r();
      return;
    } catch {
      af("The worker has been disabled.");
    }
    this._setupFakeWorker();
  }
  _setupFakeWorker() {
    a(Tt, Zr) || (tt("Setting up fake worker."), p(Tt, Zr, !0)), Tt._setupFakeWorkerGlobal.then((e) => {
      if (this.destroyed) {
        this._readyCapability.reject(new Error("Worker was destroyed"));
        return;
      }
      const t = new Iw();
      this._port = t;
      const s = `fake${me(Tt, Gu)._++}`, i = new Xl(s + "_worker", s, t);
      e.setup(i, t), this._messageHandler = new Xl(s, s + "_worker", t), v(this, Oo, Zd).call(this);
    }).catch((e) => {
      this._readyCapability.reject(new Error(`Setting up fake worker failed: "${e.message}".`));
    });
  }
  destroy() {
    var e, t, s;
    this.destroyed = !0, (e = this._webWorker) == null || e.terminate(), this._webWorker = null, (t = a(Tt, Jr)) == null || t.delete(this._port), this._port = null, (s = this._messageHandler) == null || s.destroy(), this._messageHandler = null;
  }
  static fromPort(e) {
    var s;
    if (!(e != null && e.port))
      throw new Error("PDFWorker.fromPort - invalid method signature.");
    const t = (s = a(this, Jr)) == null ? void 0 : s.get(e.port);
    if (t) {
      if (t._pendingDestroy)
        throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
      return t;
    }
    return new Tt(e);
  }
  static get workerSrc() {
    if (yr.workerSrc)
      return yr.workerSrc;
    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
  }
  static get _setupFakeWorkerGlobal() {
    return ht(this, "_setupFakeWorkerGlobal", (async () => a(this, No, Jd) ? a(this, No, Jd) : (await import(
      /*webpackIgnore: true*/
      this.workerSrc
    )).WorkerMessageHandler)());
  }
}, Gu = new WeakMap(), Zr = new WeakMap(), Jr = new WeakMap(), Oo = new WeakSet(), Zd = function() {
  this._readyCapability.resolve(), this._messageHandler.send("configure", {
    verbosity: this.verbosity
  });
}, No = new WeakSet(), Jd = function() {
  var e;
  try {
    return ((e = globalThis.pdfjsWorker) == null ? void 0 : e.WorkerMessageHandler) || null;
  } catch {
    return null;
  }
}, b(Tt, No), b(Tt, Gu, 0), b(Tt, Zr, !1), b(Tt, Jr), Te && (p(Tt, Zr, !0), yr.workerSrc || (yr.workerSrc = "./pdf.worker.mjs")), Tt._isSameOrigin = (e, t) => {
  let s;
  try {
    if (s = new URL(e), !s.origin || s.origin === "null")
      return !1;
  } catch {
    return !1;
  }
  const i = new URL(t, s);
  return s.origin === i.origin;
}, Tt._createCDNWrapper = (e) => {
  const t = `await import("${e}");`;
  return URL.createObjectURL(new Blob([t], {
    type: "text/javascript"
  }));
}, Tt);
var ji, ii, Do, ko, Hi, qr, Jl;
class _w {
  constructor(e, t, s, i, n) {
    b(this, qr);
    b(this, ji, /* @__PURE__ */ new Map());
    b(this, ii, /* @__PURE__ */ new Map());
    b(this, Do, /* @__PURE__ */ new Map());
    b(this, ko, /* @__PURE__ */ new Map());
    b(this, Hi, null);
    this.messageHandler = e, this.loadingTask = t, this.commonObjs = new nb(), this.fontLoader = new IA({
      ownerDocument: i.ownerDocument,
      styleElement: i.styleElement
    }), this.loadingParams = i.loadingParams, this._params = i, this.canvasFactory = n.canvasFactory, this.filterFactory = n.filterFactory, this.cMapReaderFactory = n.cMapReaderFactory, this.standardFontDataFactory = n.standardFontDataFactory, this.destroyed = !1, this.destroyCapability = null, this._networkStream = s, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = Promise.withResolvers(), this.setupMessageHandler();
  }
  get annotationStorage() {
    return ht(this, "annotationStorage", new Dg());
  }
  getRenderingIntent(e, t = gn.ENABLE, s = null, i = !1, n = !1) {
    let r = rs.DISPLAY, o = ip;
    switch (e) {
      case "any":
        r = rs.ANY;
        break;
      case "display":
        break;
      case "print":
        r = rs.PRINT;
        break;
      default:
        tt(`getRenderingIntent - invalid intent: ${e}`);
    }
    const l = r & rs.PRINT && s instanceof Dv ? s : this.annotationStorage;
    switch (t) {
      case gn.DISABLE:
        r += rs.ANNOTATIONS_DISABLE;
        break;
      case gn.ENABLE:
        break;
      case gn.ENABLE_FORMS:
        r += rs.ANNOTATIONS_FORMS;
        break;
      case gn.ENABLE_STORAGE:
        r += rs.ANNOTATIONS_STORAGE, o = l.serializable;
        break;
      default:
        tt(`getRenderingIntent - invalid annotationMode: ${t}`);
    }
    i && (r += rs.IS_EDITING), n && (r += rs.OPLIST);
    const {
      ids: c,
      hash: d
    } = l.modifiedIds, u = [r, o.hash, d];
    return {
      renderingIntent: r,
      cacheKey: u.join("_"),
      annotationStorageSerializable: o,
      modifiedIds: c
    };
  }
  destroy() {
    var s;
    if (this.destroyCapability)
      return this.destroyCapability.promise;
    this.destroyed = !0, this.destroyCapability = Promise.withResolvers(), (s = a(this, Hi)) == null || s.reject(new Error("Worker was destroyed during onPassword callback"));
    const e = [];
    for (const i of a(this, ii).values())
      e.push(i._destroy());
    a(this, ii).clear(), a(this, Do).clear(), a(this, ko).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
    const t = this.messageHandler.sendWithPromise("Terminate", null);
    return e.push(t), Promise.all(e).then(() => {
      var i, n;
      this.commonObjs.clear(), this.fontLoader.clear(), a(this, ji).clear(), this.filterFactory.destroy(), up.cleanup(), (i = this._networkStream) == null || i.cancelAllRequests(new dr("Worker was terminated.")), (n = this.messageHandler) == null || n.destroy(), this.messageHandler = null, this.destroyCapability.resolve();
    }, this.destroyCapability.reject), this.destroyCapability.promise;
  }
  setupMessageHandler() {
    const {
      messageHandler: e,
      loadingTask: t
    } = this;
    e.on("GetReader", (s, i) => {
      Wt(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (n) => {
        this._lastProgress = {
          loaded: n.loaded,
          total: n.total
        };
      }, i.onPull = () => {
        this._fullReader.read().then(function({
          value: n,
          done: r
        }) {
          if (r) {
            i.close();
            return;
          }
          Wt(n instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), i.enqueue(new Uint8Array(n), 1, [n]);
        }).catch((n) => {
          i.error(n);
        });
      }, i.onCancel = (n) => {
        this._fullReader.cancel(n), i.ready.catch((r) => {
          if (!this.destroyed)
            throw r;
        });
      };
    }), e.on("ReaderHeadersReady", async (s) => {
      var o;
      await this._fullReader.headersReady;
      const {
        isStreamingSupported: i,
        isRangeSupported: n,
        contentLength: r
      } = this._fullReader;
      return (!i || !n) && (this._lastProgress && ((o = t.onProgress) == null || o.call(t, this._lastProgress)), this._fullReader.onProgress = (l) => {
        var c;
        (c = t.onProgress) == null || c.call(t, {
          loaded: l.loaded,
          total: l.total
        });
      }), {
        isStreamingSupported: i,
        isRangeSupported: n,
        contentLength: r
      };
    }), e.on("GetRangeReader", (s, i) => {
      Wt(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
      const n = this._networkStream.getRangeReader(s.begin, s.end);
      if (!n) {
        i.close();
        return;
      }
      i.onPull = () => {
        n.read().then(function({
          value: r,
          done: o
        }) {
          if (o) {
            i.close();
            return;
          }
          Wt(r instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), i.enqueue(new Uint8Array(r), 1, [r]);
        }).catch((r) => {
          i.error(r);
        });
      }, i.onCancel = (r) => {
        n.cancel(r), i.ready.catch((o) => {
          if (!this.destroyed)
            throw o;
        });
      };
    }), e.on("GetDoc", ({
      pdfInfo: s
    }) => {
      this._numPages = s.numPages, this._htmlForXfa = s.htmlForXfa, delete s.htmlForXfa, t._capability.resolve(new Cw(s, this));
    }), e.on("DocException", (s) => {
      t._capability.reject(Fe(s));
    }), e.on("PasswordRequest", (s) => {
      p(this, Hi, Promise.withResolvers());
      try {
        if (!t.onPassword)
          throw Fe(s);
        const i = (n) => {
          n instanceof Error ? a(this, Hi).reject(n) : a(this, Hi).resolve({
            password: n
          });
        };
        t.onPassword(i, s.code);
      } catch (i) {
        a(this, Hi).reject(i);
      }
      return a(this, Hi).promise;
    }), e.on("DataLoaded", (s) => {
      var i;
      (i = t.onProgress) == null || i.call(t, {
        loaded: s.length,
        total: s.length
      }), this.downloadInfoCapability.resolve(s);
    }), e.on("StartRenderPage", (s) => {
      if (this.destroyed)
        return;
      a(this, ii).get(s.pageIndex)._startRenderPage(s.transparency, s.cacheKey);
    }), e.on("commonobj", ([s, i, n]) => {
      var r;
      if (this.destroyed || this.commonObjs.has(s))
        return null;
      switch (i) {
        case "Font":
          const {
            disableFontFace: o,
            fontExtraProperties: l,
            pdfBug: c
          } = this._params;
          if ("error" in n) {
            const g = n.error;
            tt(`Error during font loading: ${g}`), this.commonObjs.resolve(s, g);
            break;
          }
          const d = c && ((r = globalThis.FontInspector) != null && r.enabled) ? (g, m) => globalThis.FontInspector.fontAdded(g, m) : null, u = new _A(n, {
            disableFontFace: o,
            fontExtraProperties: l,
            inspectFont: d
          });
          this.fontLoader.bind(u).catch(() => e.sendWithPromise("FontFallback", {
            id: s
          })).finally(() => {
            !l && u.data && (u.data = null), this.commonObjs.resolve(s, u);
          });
          break;
        case "CopyLocalImage":
          const {
            imageRef: f
          } = n;
          Wt(f, "The imageRef must be defined.");
          for (const g of a(this, ii).values())
            for (const [, m] of g.objs)
              if ((m == null ? void 0 : m.ref) === f)
                return m.dataLen ? (this.commonObjs.resolve(s, structuredClone(m)), m.dataLen) : null;
          break;
        case "FontPath":
        case "Image":
        case "Pattern":
          this.commonObjs.resolve(s, n);
          break;
        default:
          throw new Error(`Got unknown common object type ${i}`);
      }
      return null;
    }), e.on("obj", ([s, i, n, r]) => {
      var l;
      if (this.destroyed)
        return;
      const o = a(this, ii).get(i);
      if (!o.objs.has(s)) {
        if (o._intentStates.size === 0) {
          (l = r == null ? void 0 : r.bitmap) == null || l.close();
          return;
        }
        switch (n) {
          case "Image":
            o.objs.resolve(s, r), (r == null ? void 0 : r.dataLen) > rA && (o._maybeCleanupAfterRender = !0);
            break;
          case "Pattern":
            o.objs.resolve(s, r);
            break;
          default:
            throw new Error(`Got unknown object type ${n}`);
        }
      }
    }), e.on("DocProgress", (s) => {
      var i;
      this.destroyed || (i = t.onProgress) == null || i.call(t, {
        loaded: s.loaded,
        total: s.total
      });
    }), e.on("FetchBuiltInCMap", async (s) => {
      if (this.destroyed)
        throw new Error("Worker was destroyed.");
      if (!this.cMapReaderFactory)
        throw new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.");
      return this.cMapReaderFactory.fetch(s);
    }), e.on("FetchStandardFontData", async (s) => {
      if (this.destroyed)
        throw new Error("Worker was destroyed.");
      if (!this.standardFontDataFactory)
        throw new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.");
      return this.standardFontDataFactory.fetch(s);
    });
  }
  getData() {
    return this.messageHandler.sendWithPromise("GetData", null);
  }
  saveDocument() {
    var s;
    this.annotationStorage.size <= 0 && tt("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
    const {
      map: e,
      transfer: t
    } = this.annotationStorage.serializable;
    return this.messageHandler.sendWithPromise("SaveDocument", {
      isPureXfa: !!this._htmlForXfa,
      numPages: this._numPages,
      annotationStorage: e,
      filename: ((s = this._fullReader) == null ? void 0 : s.filename) ?? null
    }, t).finally(() => {
      this.annotationStorage.resetModified();
    });
  }
  getPage(e) {
    if (!Number.isInteger(e) || e <= 0 || e > this._numPages)
      return Promise.reject(new Error("Invalid page request."));
    const t = e - 1, s = a(this, Do).get(t);
    if (s)
      return s;
    const i = this.messageHandler.sendWithPromise("GetPage", {
      pageIndex: t
    }).then((n) => {
      if (this.destroyed)
        throw new Error("Transport destroyed");
      n.refStr && a(this, ko).set(n.refStr, e);
      const r = new Rw(t, n, this, this._params.pdfBug);
      return a(this, ii).set(t, r), r;
    });
    return a(this, Do).set(t, i), i;
  }
  getPageIndex(e) {
    return um(e) ? this.messageHandler.sendWithPromise("GetPageIndex", {
      num: e.num,
      gen: e.gen
    }) : Promise.reject(new Error("Invalid pageIndex request."));
  }
  getAnnotations(e, t) {
    return this.messageHandler.sendWithPromise("GetAnnotations", {
      pageIndex: e,
      intent: t
    });
  }
  getFieldObjects() {
    return v(this, qr, Jl).call(this, "GetFieldObjects");
  }
  hasJSActions() {
    return v(this, qr, Jl).call(this, "HasJSActions");
  }
  getCalculationOrderIds() {
    return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
  }
  getDestinations() {
    return this.messageHandler.sendWithPromise("GetDestinations", null);
  }
  getDestination(e) {
    return typeof e != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
      id: e
    });
  }
  getPageLabels() {
    return this.messageHandler.sendWithPromise("GetPageLabels", null);
  }
  getPageLayout() {
    return this.messageHandler.sendWithPromise("GetPageLayout", null);
  }
  getPageMode() {
    return this.messageHandler.sendWithPromise("GetPageMode", null);
  }
  getViewerPreferences() {
    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
  }
  getOpenAction() {
    return this.messageHandler.sendWithPromise("GetOpenAction", null);
  }
  getAttachments() {
    return this.messageHandler.sendWithPromise("GetAttachments", null);
  }
  getDocJSActions() {
    return v(this, qr, Jl).call(this, "GetDocJSActions");
  }
  getPageJSActions(e) {
    return this.messageHandler.sendWithPromise("GetPageJSActions", {
      pageIndex: e
    });
  }
  getStructTree(e) {
    return this.messageHandler.sendWithPromise("GetStructTree", {
      pageIndex: e
    });
  }
  getOutline() {
    return this.messageHandler.sendWithPromise("GetOutline", null);
  }
  getOptionalContentConfig(e) {
    return v(this, qr, Jl).call(this, "GetOptionalContentConfig").then((t) => new JA(t, e));
  }
  getPermissions() {
    return this.messageHandler.sendWithPromise("GetPermissions", null);
  }
  getMetadata() {
    const e = "GetMetadata", t = a(this, ji).get(e);
    if (t)
      return t;
    const s = this.messageHandler.sendWithPromise(e, null).then((i) => {
      var n, r;
      return {
        info: i[0],
        metadata: i[1] ? new QA(i[1]) : null,
        contentDispositionFilename: ((n = this._fullReader) == null ? void 0 : n.filename) ?? null,
        contentLength: ((r = this._fullReader) == null ? void 0 : r.contentLength) ?? null
      };
    });
    return a(this, ji).set(e, s), s;
  }
  getMarkInfo() {
    return this.messageHandler.sendWithPromise("GetMarkInfo", null);
  }
  async startCleanup(e = !1) {
    if (!this.destroyed) {
      await this.messageHandler.sendWithPromise("Cleanup", null);
      for (const t of a(this, ii).values())
        if (!t.cleanup())
          throw new Error(`startCleanup: Page ${t.pageNumber} is currently rendering.`);
      this.commonObjs.clear(), e || this.fontLoader.clear(), a(this, ji).clear(), this.filterFactory.destroy(!0), up.cleanup();
    }
  }
  cachedPageNumber(e) {
    if (!um(e))
      return null;
    const t = e.gen === 0 ? `${e.num}R` : `${e.num}R${e.gen}`;
    return a(this, ko).get(t) ?? null;
  }
}
ji = new WeakMap(), ii = new WeakMap(), Do = new WeakMap(), ko = new WeakMap(), Hi = new WeakMap(), qr = new WeakSet(), Jl = function(e, t = null) {
  const s = a(this, ji).get(e);
  if (s)
    return s;
  const i = this.messageHandler.sendWithPromise(e, t);
  return a(this, ji).set(e, i), i;
};
const Hl = Symbol("INITIAL_DATA");
var Ke, cc, mp;
class nb {
  constructor() {
    b(this, cc);
    b(this, Ke, /* @__PURE__ */ Object.create(null));
  }
  get(e, t = null) {
    if (t) {
      const i = v(this, cc, mp).call(this, e);
      return i.promise.then(() => t(i.data)), null;
    }
    const s = a(this, Ke)[e];
    if (!s || s.data === Hl)
      throw new Error(`Requesting object that isn't resolved yet ${e}.`);
    return s.data;
  }
  has(e) {
    const t = a(this, Ke)[e];
    return !!t && t.data !== Hl;
  }
  delete(e) {
    const t = a(this, Ke)[e];
    return !t || t.data === Hl ? !1 : (delete a(this, Ke)[e], !0);
  }
  resolve(e, t = null) {
    const s = v(this, cc, mp).call(this, e);
    s.data = t, s.resolve();
  }
  clear() {
    var e;
    for (const t in a(this, Ke)) {
      const {
        data: s
      } = a(this, Ke)[t];
      (e = s == null ? void 0 : s.bitmap) == null || e.close();
    }
    p(this, Ke, /* @__PURE__ */ Object.create(null));
  }
  *[Symbol.iterator]() {
    for (const e in a(this, Ke)) {
      const {
        data: t
      } = a(this, Ke)[e];
      t !== Hl && (yield [e, t]);
    }
  }
}
Ke = new WeakMap(), cc = new WeakSet(), mp = function(e) {
  var t;
  return (t = a(this, Ke))[e] || (t[e] = {
    ...Promise.withResolvers(),
    data: Hl
  });
};
var On;
class Lw {
  constructor(e) {
    b(this, On, null);
    p(this, On, e), this.onContinue = null;
  }
  get promise() {
    return a(this, On).capability.promise;
  }
  cancel(e = 0) {
    a(this, On).cancel(null, e);
  }
  get separateAnnots() {
    const {
      separateAnnots: e
    } = a(this, On).operatorList;
    if (!e)
      return !1;
    const {
      annotationCanvasMap: t
    } = a(this, On);
    return e.form || e.canvas && (t == null ? void 0 : t.size) > 0;
  }
}
On = new WeakMap();
var Nn, ta;
const Ar = class Ar {
  constructor({
    callback: e,
    params: t,
    objs: s,
    commonObjs: i,
    annotationCanvasMap: n,
    operatorList: r,
    pageIndex: o,
    canvasFactory: l,
    filterFactory: c,
    useRequestAnimationFrame: d = !1,
    pdfBug: u = !1,
    pageColors: f = null
  }) {
    b(this, Nn, null);
    this.callback = e, this.params = t, this.objs = s, this.commonObjs = i, this.annotationCanvasMap = n, this.operatorListIdx = null, this.operatorList = r, this._pageIndex = o, this.canvasFactory = l, this.filterFactory = c, this._pdfBug = u, this.pageColors = f, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = d === !0 && typeof window < "u", this.cancelled = !1, this.capability = Promise.withResolvers(), this.task = new Lw(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = t.canvasContext.canvas;
  }
  get completed() {
    return this.capability.promise.catch(function() {
    });
  }
  initializeGraphics({
    transparency: e = !1,
    optionalContentConfig: t
  }) {
    var o, l;
    if (this.cancelled)
      return;
    if (this._canvas) {
      if (a(Ar, ta).has(this._canvas))
        throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
      a(Ar, ta).add(this._canvas);
    }
    this._pdfBug && ((o = globalThis.StepperManager) != null && o.enabled) && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
    const {
      canvasContext: s,
      viewport: i,
      transform: n,
      background: r
    } = this.params;
    this.gfx = new no(s, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
      optionalContentConfig: t
    }, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({
      transform: n,
      viewport: i,
      transparency: e,
      background: r
    }), this.operatorListIdx = 0, this.graphicsReady = !0, (l = this.graphicsReadyCallback) == null || l.call(this);
  }
  cancel(e = null, t = 0) {
    var s;
    this.running = !1, this.cancelled = !0, (s = this.gfx) == null || s.endDrawing(), a(this, Nn) && (window.cancelAnimationFrame(a(this, Nn)), p(this, Nn, null)), a(Ar, ta).delete(this._canvas), this.callback(e || new Mg(`Rendering cancelled, page ${this._pageIndex + 1}`, t));
  }
  operatorListChanged() {
    var e;
    if (!this.graphicsReady) {
      this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
      return;
    }
    (e = this.stepper) == null || e.updateOperatorList(this.operatorList), !this.running && this._continue();
  }
  _continue() {
    this.running = !0, !this.cancelled && (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
  }
  _scheduleNext() {
    this._useRequestAnimationFrame ? p(this, Nn, window.requestAnimationFrame(() => {
      p(this, Nn, null), this._nextBound().catch(this._cancelBound);
    })) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
  }
  async _next() {
    this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), a(Ar, ta).delete(this._canvas), this.callback())));
  }
};
Nn = new WeakMap(), ta = new WeakMap(), b(Ar, ta, /* @__PURE__ */ new WeakSet());
let vp = Ar;
const Mw = "4.10.38", Ow = "f9bea397f";
ut(670);
function fm(h) {
  return Math.floor(Math.max(0, Math.min(1, h)) * 255).toString(16).padStart(2, "0");
}
function $l(h) {
  return Math.max(0, Math.min(255, 255 * h));
}
class pm {
  static CMYK_G([e, t, s, i]) {
    return ["G", 1 - Math.min(1, 0.3 * e + 0.59 * s + 0.11 * t + i)];
  }
  static G_CMYK([e]) {
    return ["CMYK", 0, 0, 0, 1 - e];
  }
  static G_RGB([e]) {
    return ["RGB", e, e, e];
  }
  static G_rgb([e]) {
    return e = $l(e), [e, e, e];
  }
  static G_HTML([e]) {
    const t = fm(e);
    return `#${t}${t}${t}`;
  }
  static RGB_G([e, t, s]) {
    return ["G", 0.3 * e + 0.59 * t + 0.11 * s];
  }
  static RGB_rgb(e) {
    return e.map($l);
  }
  static RGB_HTML(e) {
    return `#${e.map(fm).join("")}`;
  }
  static T_HTML() {
    return "#00000000";
  }
  static T_rgb() {
    return [null];
  }
  static CMYK_RGB([e, t, s, i]) {
    return ["RGB", 1 - Math.min(1, e + i), 1 - Math.min(1, s + i), 1 - Math.min(1, t + i)];
  }
  static CMYK_rgb([e, t, s, i]) {
    return [$l(1 - Math.min(1, e + i)), $l(1 - Math.min(1, s + i)), $l(1 - Math.min(1, t + i))];
  }
  static CMYK_HTML(e) {
    const t = this.CMYK_RGB(e).slice(1);
    return this.RGB_HTML(t);
  }
  static RGB_CMYK([e, t, s]) {
    const i = 1 - e, n = 1 - t, r = 1 - s, o = Math.min(i, n, r);
    return ["CMYK", i, n, r, o];
  }
}
class Nw {
  create(e, t, s = !1) {
    if (e <= 0 || t <= 0)
      throw new Error("Invalid SVG dimensions");
    const i = this._createSVG("svg:svg");
    return i.setAttribute("version", "1.1"), s || (i.setAttribute("width", `${e}px`), i.setAttribute("height", `${t}px`)), i.setAttribute("preserveAspectRatio", "none"), i.setAttribute("viewBox", `0 0 ${e} ${t}`), i;
  }
  createElement(e) {
    if (typeof e != "string")
      throw new Error("Invalid SVG element type");
    return this._createSVG(e);
  }
  _createSVG(e) {
    Pt("Abstract method `_createSVG` called.");
  }
}
let Fg = class extends Nw {
  _createSVG(e) {
    return document.createElementNS(Ai, e);
  }
}, rb = class {
  static setupStorage(e, t, s, i, n) {
    const r = i.getValue(t, {
      value: null
    });
    switch (s.name) {
      case "textarea":
        if (r.value !== null && (e.textContent = r.value), n === "print")
          break;
        e.addEventListener("input", (o) => {
          i.setValue(t, {
            value: o.target.value
          });
        });
        break;
      case "input":
        if (s.attributes.type === "radio" || s.attributes.type === "checkbox") {
          if (r.value === s.attributes.xfaOn ? e.setAttribute("checked", !0) : r.value === s.attributes.xfaOff && e.removeAttribute("checked"), n === "print")
            break;
          e.addEventListener("change", (o) => {
            i.setValue(t, {
              value: o.target.checked ? o.target.getAttribute("xfaOn") : o.target.getAttribute("xfaOff")
            });
          });
        } else {
          if (r.value !== null && e.setAttribute("value", r.value), n === "print")
            break;
          e.addEventListener("input", (o) => {
            i.setValue(t, {
              value: o.target.value
            });
          });
        }
        break;
      case "select":
        if (r.value !== null) {
          e.setAttribute("value", r.value);
          for (const o of s.children)
            o.attributes.value === r.value ? o.attributes.selected = !0 : o.attributes.hasOwnProperty("selected") && delete o.attributes.selected;
        }
        e.addEventListener("input", (o) => {
          const l = o.target.options, c = l.selectedIndex === -1 ? "" : l[l.selectedIndex].value;
          i.setValue(t, {
            value: c
          });
        });
        break;
    }
  }
  static setAttributes({
    html: e,
    element: t,
    storage: s = null,
    intent: i,
    linkService: n
  }) {
    const {
      attributes: r
    } = t, o = e instanceof HTMLAnchorElement;
    r.type === "radio" && (r.name = `${r.name}-${i}`);
    for (const [l, c] of Object.entries(r))
      if (c != null)
        switch (l) {
          case "class":
            c.length && e.setAttribute(l, c.join(" "));
            break;
          case "dataId":
            break;
          case "id":
            e.setAttribute("data-element-id", c);
            break;
          case "style":
            Object.assign(e.style, c);
            break;
          case "textContent":
            e.textContent = c;
            break;
          default:
            (!o || l !== "href" && l !== "newWindow") && e.setAttribute(l, c);
        }
    o && n.addLinkAttributes(e, r.href, r.newWindow), s && r.dataId && this.setupStorage(e, r.dataId, t, s);
  }
  static render(e) {
    var u, f;
    const t = e.annotationStorage, s = e.linkService, i = e.xfaHtml, n = e.intent || "display", r = document.createElement(i.name);
    i.attributes && this.setAttributes({
      html: r,
      element: i,
      intent: n,
      linkService: s
    });
    const o = n !== "richText", l = e.div;
    if (l.append(r), e.viewport) {
      const g = `matrix(${e.viewport.transform.join(",")})`;
      l.style.transform = g;
    }
    o && l.setAttribute("class", "xfaLayer xfaFont");
    const c = [];
    if (i.children.length === 0) {
      if (i.value) {
        const g = document.createTextNode(i.value);
        r.append(g), o && bh.shouldBuildText(i.name) && c.push(g);
      }
      return {
        textDivs: c
      };
    }
    const d = [[i, -1, r]];
    for (; d.length > 0; ) {
      const [g, m, y] = d.at(-1);
      if (m + 1 === g.children.length) {
        d.pop();
        continue;
      }
      const w = g.children[++d.at(-1)[1]];
      if (w === null)
        continue;
      const {
        name: A
      } = w;
      if (A === "#text") {
        const S = document.createTextNode(w.value);
        c.push(S), y.append(S);
        continue;
      }
      const E = (u = w == null ? void 0 : w.attributes) != null && u.xmlns ? document.createElementNS(w.attributes.xmlns, A) : document.createElement(A);
      if (y.append(E), w.attributes && this.setAttributes({
        html: E,
        element: w,
        storage: t,
        intent: n,
        linkService: s
      }), ((f = w.children) == null ? void 0 : f.length) > 0)
        d.push([w, -1, E]);
      else if (w.value) {
        const S = document.createTextNode(w.value);
        o && bh.shouldBuildText(A) && c.push(S), E.append(S);
      }
    }
    for (const g of l.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
      g.setAttribute("readOnly", !0);
    return {
      textDivs: c
    };
  }
  static update(e) {
    const t = `matrix(${e.viewport.transform.join(",")})`;
    e.div.style.transform = t, e.div.hidden = !1;
  }
};
const xd = 1e3, Dw = 9, Ua = /* @__PURE__ */ new WeakSet();
function cr(h) {
  return {
    width: h[2] - h[0],
    height: h[3] - h[1]
  };
}
class kw {
  static create(e) {
    switch (e.data.annotationType) {
      case Yt.LINK:
        return new ab(e);
      case Yt.TEXT:
        return new Fw(e);
      case Yt.WIDGET:
        switch (e.data.fieldType) {
          case "Tx":
            return new Bw(e);
          case "Btn":
            return e.data.radioButton ? new hb(e) : e.data.checkBox ? new Hw(e) : new $w(e);
          case "Ch":
            return new Vw(e);
          case "Sig":
            return new jw(e);
        }
        return new Wa(e);
      case Yt.POPUP:
        return new yp(e);
      case Yt.FREETEXT:
        return new pb(e);
      case Yt.LINE:
        return new zw(e);
      case Yt.SQUARE:
        return new Ww(e);
      case Yt.CIRCLE:
        return new Gw(e);
      case Yt.POLYLINE:
        return new gb(e);
      case Yt.CARET:
        return new Yw(e);
      case Yt.INK:
        return new Bg(e);
      case Yt.POLYGON:
        return new Xw(e);
      case Yt.HIGHLIGHT:
        return new mb(e);
      case Yt.UNDERLINE:
        return new Kw(e);
      case Yt.SQUIGGLY:
        return new Qw(e);
      case Yt.STRIKEOUT:
        return new Zw(e);
      case Yt.STAMP:
        return new vb(e);
      case Yt.FILEATTACHMENT:
        return new Jw(e);
      default:
        return new Ut(e);
    }
  }
}
var ea, Fo, Bo, dc, bp;
const Vg = class Vg {
  constructor(e, {
    isRenderable: t = !1,
    ignoreBorder: s = !1,
    createQuadrilaterals: i = !1
  } = {}) {
    b(this, dc);
    b(this, ea, null);
    b(this, Fo, !1);
    b(this, Bo, null);
    this.isRenderable = t, this.data = e.data, this.layer = e.layer, this.linkService = e.linkService, this.downloadManager = e.downloadManager, this.imageResourcesPath = e.imageResourcesPath, this.renderForms = e.renderForms, this.svgFactory = e.svgFactory, this.annotationStorage = e.annotationStorage, this.enableScripting = e.enableScripting, this.hasJSActions = e.hasJSActions, this._fieldObjects = e.fieldObjects, this.parent = e.parent, t && (this.container = this._createContainer(s)), i && this._createQuadrilaterals();
  }
  static _hasPopupData({
    titleObj: e,
    contentsObj: t,
    richText: s
  }) {
    return !!(e != null && e.str || t != null && t.str || s != null && s.str);
  }
  get _isEditable() {
    return this.data.isEditable;
  }
  get hasPopupData() {
    return Vg._hasPopupData(this.data);
  }
  updateEdited(e) {
    var s;
    if (!this.container)
      return;
    a(this, ea) || p(this, ea, {
      rect: this.data.rect.slice(0)
    });
    const {
      rect: t
    } = e;
    t && v(this, dc, bp).call(this, t), (s = a(this, Bo)) == null || s.popup.updateEdited(e);
  }
  resetEdited() {
    var e;
    a(this, ea) && (v(this, dc, bp).call(this, a(this, ea).rect), (e = a(this, Bo)) == null || e.popup.resetEdited(), p(this, ea, null));
  }
  _createContainer(e) {
    const {
      data: t,
      parent: {
        page: s,
        viewport: i
      }
    } = this, n = document.createElement("section");
    n.setAttribute("data-annotation-id", t.id), this instanceof Wa || (n.tabIndex = xd);
    const {
      style: r
    } = n;
    if (r.zIndex = this.parent.zIndex++, t.alternativeText && (n.title = t.alternativeText), t.noRotate && n.classList.add("norotate"), !t.rect || this instanceof yp) {
      const {
        rotation: y
      } = t;
      return !t.hasOwnCanvas && y !== 0 && this.setRotation(y, n), n;
    }
    const {
      width: o,
      height: l
    } = cr(t.rect);
    if (!e && t.borderStyle.width > 0) {
      r.borderWidth = `${t.borderStyle.width}px`;
      const y = t.borderStyle.horizontalCornerRadius, w = t.borderStyle.verticalCornerRadius;
      if (y > 0 || w > 0) {
        const E = `calc(${y}px * var(--scale-factor)) / calc(${w}px * var(--scale-factor))`;
        r.borderRadius = E;
      } else if (this instanceof hb) {
        const E = `calc(${o}px * var(--scale-factor)) / calc(${l}px * var(--scale-factor))`;
        r.borderRadius = E;
      }
      switch (t.borderStyle.style) {
        case Bl.SOLID:
          r.borderStyle = "solid";
          break;
        case Bl.DASHED:
          r.borderStyle = "dashed";
          break;
        case Bl.BEVELED:
          tt("Unimplemented border style: beveled");
          break;
        case Bl.INSET:
          tt("Unimplemented border style: inset");
          break;
        case Bl.UNDERLINE:
          r.borderBottomStyle = "solid";
          break;
      }
      const A = t.borderColor || null;
      A ? (p(this, Fo, !0), r.borderColor = X.makeHexColor(A[0] | 0, A[1] | 0, A[2] | 0)) : r.borderWidth = 0;
    }
    const c = X.normalizeRect([t.rect[0], s.view[3] - t.rect[1] + s.view[1], t.rect[2], s.view[3] - t.rect[3] + s.view[1]]), {
      pageWidth: d,
      pageHeight: u,
      pageX: f,
      pageY: g
    } = i.rawDims;
    r.left = `${100 * (c[0] - f) / d}%`, r.top = `${100 * (c[1] - g) / u}%`;
    const {
      rotation: m
    } = t;
    return t.hasOwnCanvas || m === 0 ? (r.width = `${100 * o / d}%`, r.height = `${100 * l / u}%`) : this.setRotation(m, n), n;
  }
  setRotation(e, t = this.container) {
    if (!this.data.rect)
      return;
    const {
      pageWidth: s,
      pageHeight: i
    } = this.parent.viewport.rawDims, {
      width: n,
      height: r
    } = cr(this.data.rect);
    let o, l;
    e % 180 === 0 ? (o = 100 * n / s, l = 100 * r / i) : (o = 100 * r / s, l = 100 * n / i), t.style.width = `${o}%`, t.style.height = `${l}%`, t.setAttribute("data-main-rotation", (360 - e) % 360);
  }
  get _commonActions() {
    const e = (t, s, i) => {
      const n = i.detail[t], r = n[0], o = n.slice(1);
      i.target.style[s] = pm[`${r}_HTML`](o), this.annotationStorage.setValue(this.data.id, {
        [s]: pm[`${r}_rgb`](o)
      });
    };
    return ht(this, "_commonActions", {
      display: (t) => {
        const {
          display: s
        } = t.detail, i = s % 2 === 1;
        this.container.style.visibility = i ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
          noView: i,
          noPrint: s === 1 || s === 2
        });
      },
      print: (t) => {
        this.annotationStorage.setValue(this.data.id, {
          noPrint: !t.detail.print
        });
      },
      hidden: (t) => {
        const {
          hidden: s
        } = t.detail;
        this.container.style.visibility = s ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
          noPrint: s,
          noView: s
        });
      },
      focus: (t) => {
        setTimeout(() => t.target.focus({
          preventScroll: !1
        }), 0);
      },
      userName: (t) => {
        t.target.title = t.detail.userName;
      },
      readonly: (t) => {
        t.target.disabled = t.detail.readonly;
      },
      required: (t) => {
        this._setRequired(t.target, t.detail.required);
      },
      bgColor: (t) => {
        e("bgColor", "backgroundColor", t);
      },
      fillColor: (t) => {
        e("fillColor", "backgroundColor", t);
      },
      fgColor: (t) => {
        e("fgColor", "color", t);
      },
      textColor: (t) => {
        e("textColor", "color", t);
      },
      borderColor: (t) => {
        e("borderColor", "borderColor", t);
      },
      strokeColor: (t) => {
        e("strokeColor", "borderColor", t);
      },
      rotation: (t) => {
        const s = t.detail.rotation;
        this.setRotation(s), this.annotationStorage.setValue(this.data.id, {
          rotation: s
        });
      }
    });
  }
  _dispatchEventFromSandbox(e, t) {
    const s = this._commonActions;
    for (const i of Object.keys(t.detail)) {
      const n = e[i] || s[i];
      n == null || n(t);
    }
  }
  _setDefaultPropertiesFromJS(e) {
    if (!this.enableScripting)
      return;
    const t = this.annotationStorage.getRawValue(this.data.id);
    if (!t)
      return;
    const s = this._commonActions;
    for (const [i, n] of Object.entries(t)) {
      const r = s[i];
      if (r) {
        const o = {
          detail: {
            [i]: n
          },
          target: e
        };
        r(o), delete t[i];
      }
    }
  }
  _createQuadrilaterals() {
    if (!this.container)
      return;
    const {
      quadPoints: e
    } = this.data;
    if (!e)
      return;
    const [t, s, i, n] = this.data.rect.map((y) => Math.fround(y));
    if (e.length === 8) {
      const [y, w, A, E] = e.subarray(2, 6);
      if (i === y && n === w && t === A && s === E)
        return;
    }
    const {
      style: r
    } = this.container;
    let o;
    if (a(this, Fo)) {
      const {
        borderColor: y,
        borderWidth: w
      } = r;
      r.borderWidth = 0, o = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${y}" stroke-width="${w}">`], this.container.classList.add("hasBorder");
    }
    const l = i - t, c = n - s, {
      svgFactory: d
    } = this, u = d.createElement("svg");
    u.classList.add("quadrilateralsContainer"), u.setAttribute("width", 0), u.setAttribute("height", 0);
    const f = d.createElement("defs");
    u.append(f);
    const g = d.createElement("clipPath"), m = `clippath_${this.data.id}`;
    g.setAttribute("id", m), g.setAttribute("clipPathUnits", "objectBoundingBox"), f.append(g);
    for (let y = 2, w = e.length; y < w; y += 8) {
      const A = e[y], E = e[y + 1], S = e[y + 2], T = e[y + 3], P = d.createElement("rect"), C = (S - t) / l, R = (n - E) / c, _ = (A - S) / l, x = (E - T) / c;
      P.setAttribute("x", C), P.setAttribute("y", R), P.setAttribute("width", _), P.setAttribute("height", x), g.append(P), o == null || o.push(`<rect vector-effect="non-scaling-stroke" x="${C}" y="${R}" width="${_}" height="${x}"/>`);
    }
    a(this, Fo) && (o.push("</g></svg>')"), r.backgroundImage = o.join("")), this.container.append(u), this.container.style.clipPath = `url(#${m})`;
  }
  _createPopup() {
    const {
      data: e
    } = this, t = p(this, Bo, new yp({
      data: {
        color: e.color,
        titleObj: e.titleObj,
        modificationDate: e.modificationDate,
        contentsObj: e.contentsObj,
        richText: e.richText,
        parentRect: e.rect,
        borderStyle: 0,
        id: `popup_${e.id}`,
        rotation: e.rotation
      },
      parent: this.parent,
      elements: [this]
    }));
    this.parent.div.append(t.render());
  }
  render() {
    Pt("Abstract method `AnnotationElement.render` called");
  }
  _getElementsByName(e, t = null) {
    const s = [];
    if (this._fieldObjects) {
      const i = this._fieldObjects[e];
      if (i)
        for (const {
          page: n,
          id: r,
          exportValues: o
        } of i) {
          if (n === -1 || r === t)
            continue;
          const l = typeof o == "string" ? o : null, c = document.querySelector(`[data-element-id="${r}"]`);
          if (c && !Ua.has(c)) {
            tt(`_getElementsByName - element not allowed: ${r}`);
            continue;
          }
          s.push({
            id: r,
            exportValue: l,
            domElement: c
          });
        }
      return s;
    }
    for (const i of document.getElementsByName(e)) {
      const {
        exportValue: n
      } = i, r = i.getAttribute("data-element-id");
      r !== t && Ua.has(i) && s.push({
        id: r,
        exportValue: n,
        domElement: i
      });
    }
    return s;
  }
  show() {
    var e;
    this.container && (this.container.hidden = !1), (e = this.popup) == null || e.maybeShow();
  }
  hide() {
    var e;
    this.container && (this.container.hidden = !0), (e = this.popup) == null || e.forceHide();
  }
  getElementsToTriggerPopup() {
    return this.container;
  }
  addHighlightArea() {
    const e = this.getElementsToTriggerPopup();
    if (Array.isArray(e))
      for (const t of e)
        t.classList.add("highlightArea");
    else
      e.classList.add("highlightArea");
  }
  _editOnDoubleClick() {
    if (!this._isEditable)
      return;
    const {
      annotationEditorType: e,
      data: {
        id: t
      }
    } = this;
    this.container.addEventListener("dblclick", () => {
      var s;
      (s = this.linkService.eventBus) == null || s.dispatch("switchannotationeditormode", {
        source: this,
        mode: e,
        editId: t
      });
    });
  }
};
ea = new WeakMap(), Fo = new WeakMap(), Bo = new WeakMap(), dc = new WeakSet(), bp = function(e) {
  const {
    container: {
      style: t
    },
    data: {
      rect: s,
      rotation: i
    },
    parent: {
      viewport: {
        rawDims: {
          pageWidth: n,
          pageHeight: r,
          pageX: o,
          pageY: l
        }
      }
    }
  } = this;
  s == null || s.splice(0, 4, ...e);
  const {
    width: c,
    height: d
  } = cr(e);
  t.left = `${100 * (e[0] - o) / n}%`, t.top = `${100 * (r - e[3] + l) / r}%`, i === 0 ? (t.width = `${100 * c / n}%`, t.height = `${100 * d / r}%`) : this.setRotation(i);
};
let Ut = Vg;
var as, pr, ob, lb;
class ab extends Ut {
  constructor(t, s = null) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !!(s != null && s.ignoreBorder),
      createQuadrilaterals: !0
    });
    b(this, as);
    this.isTooltipOnly = t.data.isTooltipOnly;
  }
  render() {
    const {
      data: t,
      linkService: s
    } = this, i = document.createElement("a");
    i.setAttribute("data-element-id", t.id);
    let n = !1;
    return t.url ? (s.addLinkAttributes(i, t.url, t.newWindow), n = !0) : t.action ? (this._bindNamedAction(i, t.action), n = !0) : t.attachment ? (v(this, as, ob).call(this, i, t.attachment, t.attachmentDest), n = !0) : t.setOCGState ? (v(this, as, lb).call(this, i, t.setOCGState), n = !0) : t.dest ? (this._bindLink(i, t.dest), n = !0) : (t.actions && (t.actions.Action || t.actions["Mouse Up"] || t.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(i, t), n = !0), t.resetForm ? (this._bindResetFormAction(i, t.resetForm), n = !0) : this.isTooltipOnly && !n && (this._bindLink(i, ""), n = !0)), this.container.classList.add("linkAnnotation"), n && this.container.append(i), this.container;
  }
  _bindLink(t, s) {
    t.href = this.linkService.getDestinationHash(s), t.onclick = () => (s && this.linkService.goToDestination(s), !1), (s || s === "") && v(this, as, pr).call(this);
  }
  _bindNamedAction(t, s) {
    t.href = this.linkService.getAnchorUrl(""), t.onclick = () => (this.linkService.executeNamedAction(s), !1), v(this, as, pr).call(this);
  }
  _bindJSAction(t, s) {
    t.href = this.linkService.getAnchorUrl("");
    const i = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
    for (const n of Object.keys(s.actions)) {
      const r = i.get(n);
      r && (t[r] = () => {
        var o;
        return (o = this.linkService.eventBus) == null || o.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: s.id,
            name: n
          }
        }), !1;
      });
    }
    t.onclick || (t.onclick = () => !1), v(this, as, pr).call(this);
  }
  _bindResetFormAction(t, s) {
    const i = t.onclick;
    if (i || (t.href = this.linkService.getAnchorUrl("")), v(this, as, pr).call(this), !this._fieldObjects) {
      tt('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), i || (t.onclick = () => !1);
      return;
    }
    t.onclick = () => {
      var u;
      i == null || i();
      const {
        fields: n,
        refs: r,
        include: o
      } = s, l = [];
      if (n.length !== 0 || r.length !== 0) {
        const f = new Set(r);
        for (const g of n) {
          const m = this._fieldObjects[g] || [];
          for (const {
            id: y
          } of m)
            f.add(y);
        }
        for (const g of Object.values(this._fieldObjects))
          for (const m of g)
            f.has(m.id) === o && l.push(m);
      } else
        for (const f of Object.values(this._fieldObjects))
          l.push(...f);
      const c = this.annotationStorage, d = [];
      for (const f of l) {
        const {
          id: g
        } = f;
        switch (d.push(g), f.type) {
          case "text": {
            const y = f.defaultValue || "";
            c.setValue(g, {
              value: y
            });
            break;
          }
          case "checkbox":
          case "radiobutton": {
            const y = f.defaultValue === f.exportValues;
            c.setValue(g, {
              value: y
            });
            break;
          }
          case "combobox":
          case "listbox": {
            const y = f.defaultValue || "";
            c.setValue(g, {
              value: y
            });
            break;
          }
          default:
            continue;
        }
        const m = document.querySelector(`[data-element-id="${g}"]`);
        if (m) {
          if (!Ua.has(m)) {
            tt(`_bindResetFormAction - element not allowed: ${g}`);
            continue;
          }
        } else continue;
        m.dispatchEvent(new Event("resetform"));
      }
      return this.enableScripting && ((u = this.linkService.eventBus) == null || u.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: "app",
          ids: d,
          name: "ResetForm"
        }
      })), !1;
    };
  }
}
as = new WeakSet(), pr = function() {
  this.container.setAttribute("data-internal-link", "");
}, ob = function(t, s, i = null) {
  t.href = this.linkService.getAnchorUrl(""), s.description && (t.title = s.description), t.onclick = () => {
    var n;
    return (n = this.downloadManager) == null || n.openOrDownloadData(s.content, s.filename, i), !1;
  }, v(this, as, pr).call(this);
}, lb = function(t, s) {
  t.href = this.linkService.getAnchorUrl(""), t.onclick = () => (this.linkService.executeSetOCGState(s), !1), v(this, as, pr).call(this);
};
class Fw extends Ut {
  constructor(e) {
    super(e, {
      isRenderable: !0
    });
  }
  render() {
    this.container.classList.add("textAnnotation");
    const e = document.createElement("img");
    return e.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", e.setAttribute("data-l10n-id", "pdfjs-text-annotation-type"), e.setAttribute("data-l10n-args", JSON.stringify({
      type: this.data.name
    })), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(e), this.container;
  }
}
class Wa extends Ut {
  render() {
    return this.container;
  }
  showElementAndHideCanvas(e) {
    var t;
    this.data.hasOwnCanvas && (((t = e.previousSibling) == null ? void 0 : t.nodeName) === "CANVAS" && (e.previousSibling.hidden = !0), e.hidden = !1);
  }
  _getKeyModifier(e) {
    return Oe.platform.isMac ? e.metaKey : e.ctrlKey;
  }
  _setEventListener(e, t, s, i, n) {
    s.includes("mouse") ? e.addEventListener(s, (r) => {
      var o;
      (o = this.linkService.eventBus) == null || o.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: this.data.id,
          name: i,
          value: n(r),
          shift: r.shiftKey,
          modifier: this._getKeyModifier(r)
        }
      });
    }) : e.addEventListener(s, (r) => {
      var o;
      if (s === "blur") {
        if (!t.focused || !r.relatedTarget)
          return;
        t.focused = !1;
      } else if (s === "focus") {
        if (t.focused)
          return;
        t.focused = !0;
      }
      n && ((o = this.linkService.eventBus) == null || o.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: this.data.id,
          name: i,
          value: n(r)
        }
      }));
    });
  }
  _setEventListeners(e, t, s, i) {
    var n, r, o;
    for (const [l, c] of s)
      (c === "Action" || (n = this.data.actions) != null && n[c]) && ((c === "Focus" || c === "Blur") && (t || (t = {
        focused: !1
      })), this._setEventListener(e, t, l, c, i), c === "Focus" && !((r = this.data.actions) != null && r.Blur) ? this._setEventListener(e, t, "blur", "Blur", null) : c === "Blur" && !((o = this.data.actions) != null && o.Focus) && this._setEventListener(e, t, "focus", "Focus", null));
  }
  _setBackgroundColor(e) {
    const t = this.data.backgroundColor || null;
    e.style.backgroundColor = t === null ? "transparent" : X.makeHexColor(t[0], t[1], t[2]);
  }
  _setTextStyle(e) {
    const t = ["left", "center", "right"], {
      fontColor: s
    } = this.data.defaultAppearanceData, i = this.data.defaultAppearanceData.fontSize || Dw, n = e.style;
    let r;
    const o = 2, l = (c) => Math.round(10 * c) / 10;
    if (this.data.multiLine) {
      const c = Math.abs(this.data.rect[3] - this.data.rect[1] - o), d = Math.round(c / (mf * i)) || 1, u = c / d;
      r = Math.min(i, l(u / mf));
    } else {
      const c = Math.abs(this.data.rect[3] - this.data.rect[1] - o);
      r = Math.min(i, l(c / mf));
    }
    n.fontSize = `calc(${r}px * var(--scale-factor))`, n.color = X.makeHexColor(s[0], s[1], s[2]), this.data.textAlignment !== null && (n.textAlign = t[this.data.textAlignment]);
  }
  _setRequired(e, t) {
    t ? e.setAttribute("required", !0) : e.removeAttribute("required"), e.setAttribute("aria-required", t);
  }
}
class Bw extends Wa {
  constructor(e) {
    const t = e.renderForms || e.data.hasOwnCanvas || !e.data.hasAppearance && !!e.data.fieldValue;
    super(e, {
      isRenderable: t
    });
  }
  setPropertyOnSiblings(e, t, s, i) {
    const n = this.annotationStorage;
    for (const r of this._getElementsByName(e.name, e.id))
      r.domElement && (r.domElement[t] = s), n.setValue(r.id, {
        [i]: s
      });
  }
  render() {
    var i, n;
    const e = this.annotationStorage, t = this.data.id;
    this.container.classList.add("textWidgetAnnotation");
    let s = null;
    if (this.renderForms) {
      const r = e.getValue(t, {
        value: this.data.fieldValue
      });
      let o = r.value || "";
      const l = e.getValue(t, {
        charLimit: this.data.maxLen
      }).charLimit;
      l && o.length > l && (o = o.slice(0, l));
      let c = r.formattedValue || ((i = this.data.textContent) == null ? void 0 : i.join(`
`)) || null;
      c && this.data.comb && (c = c.replaceAll(/\s+/g, ""));
      const d = {
        userValue: o,
        formattedValue: c,
        lastCommittedValue: null,
        commitKey: 1,
        focused: !1
      };
      this.data.multiLine ? (s = document.createElement("textarea"), s.textContent = c ?? o, this.data.doNotScroll && (s.style.overflowY = "hidden")) : (s = document.createElement("input"), s.type = "text", s.setAttribute("value", c ?? o), this.data.doNotScroll && (s.style.overflowX = "hidden")), this.data.hasOwnCanvas && (s.hidden = !0), Ua.add(s), s.setAttribute("data-element-id", t), s.disabled = this.data.readOnly, s.name = this.data.fieldName, s.tabIndex = xd, this._setRequired(s, this.data.required), l && (s.maxLength = l), s.addEventListener("input", (f) => {
        e.setValue(t, {
          value: f.target.value
        }), this.setPropertyOnSiblings(s, "value", f.target.value, "value"), d.formattedValue = null;
      }), s.addEventListener("resetform", (f) => {
        const g = this.data.defaultFieldValue ?? "";
        s.value = d.userValue = g, d.formattedValue = null;
      });
      let u = (f) => {
        const {
          formattedValue: g
        } = d;
        g != null && (f.target.value = g), f.target.scrollLeft = 0;
      };
      if (this.enableScripting && this.hasJSActions) {
        s.addEventListener("focus", (g) => {
          var y;
          if (d.focused)
            return;
          const {
            target: m
          } = g;
          d.userValue && (m.value = d.userValue), d.lastCommittedValue = m.value, d.commitKey = 1, (y = this.data.actions) != null && y.Focus || (d.focused = !0);
        }), s.addEventListener("updatefromsandbox", (g) => {
          this.showElementAndHideCanvas(g.target);
          const m = {
            value(y) {
              d.userValue = y.detail.value ?? "", e.setValue(t, {
                value: d.userValue.toString()
              }), y.target.value = d.userValue;
            },
            formattedValue(y) {
              const {
                formattedValue: w
              } = y.detail;
              d.formattedValue = w, w != null && y.target !== document.activeElement && (y.target.value = w), e.setValue(t, {
                formattedValue: w
              });
            },
            selRange(y) {
              y.target.setSelectionRange(...y.detail.selRange);
            },
            charLimit: (y) => {
              var S;
              const {
                charLimit: w
              } = y.detail, {
                target: A
              } = y;
              if (w === 0) {
                A.removeAttribute("maxLength");
                return;
              }
              A.setAttribute("maxLength", w);
              let E = d.userValue;
              !E || E.length <= w || (E = E.slice(0, w), A.value = d.userValue = E, e.setValue(t, {
                value: E
              }), (S = this.linkService.eventBus) == null || S.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id: t,
                  name: "Keystroke",
                  value: E,
                  willCommit: !0,
                  commitKey: 1,
                  selStart: A.selectionStart,
                  selEnd: A.selectionEnd
                }
              }));
            }
          };
          this._dispatchEventFromSandbox(m, g);
        }), s.addEventListener("keydown", (g) => {
          var w;
          d.commitKey = 1;
          let m = -1;
          if (g.key === "Escape" ? m = 0 : g.key === "Enter" && !this.data.multiLine ? m = 2 : g.key === "Tab" && (d.commitKey = 3), m === -1)
            return;
          const {
            value: y
          } = g.target;
          d.lastCommittedValue !== y && (d.lastCommittedValue = y, d.userValue = y, (w = this.linkService.eventBus) == null || w.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: t,
              name: "Keystroke",
              value: y,
              willCommit: !0,
              commitKey: m,
              selStart: g.target.selectionStart,
              selEnd: g.target.selectionEnd
            }
          }));
        });
        const f = u;
        u = null, s.addEventListener("blur", (g) => {
          var y, w;
          if (!d.focused || !g.relatedTarget)
            return;
          (y = this.data.actions) != null && y.Blur || (d.focused = !1);
          const {
            value: m
          } = g.target;
          d.userValue = m, d.lastCommittedValue !== m && ((w = this.linkService.eventBus) == null || w.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: t,
              name: "Keystroke",
              value: m,
              willCommit: !0,
              commitKey: d.commitKey,
              selStart: g.target.selectionStart,
              selEnd: g.target.selectionEnd
            }
          })), f(g);
        }), (n = this.data.actions) != null && n.Keystroke && s.addEventListener("beforeinput", (g) => {
          var P;
          d.lastCommittedValue = null;
          const {
            data: m,
            target: y
          } = g, {
            value: w,
            selectionStart: A,
            selectionEnd: E
          } = y;
          let S = A, T = E;
          switch (g.inputType) {
            case "deleteWordBackward": {
              const C = w.substring(0, A).match(/\w*[^\w]*$/);
              C && (S -= C[0].length);
              break;
            }
            case "deleteWordForward": {
              const C = w.substring(A).match(/^[^\w]*\w*/);
              C && (T += C[0].length);
              break;
            }
            case "deleteContentBackward":
              A === E && (S -= 1);
              break;
            case "deleteContentForward":
              A === E && (T += 1);
              break;
          }
          g.preventDefault(), (P = this.linkService.eventBus) == null || P.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: t,
              name: "Keystroke",
              value: w,
              change: m || "",
              willCommit: !1,
              selStart: S,
              selEnd: T
            }
          });
        }), this._setEventListeners(s, d, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (g) => g.target.value);
      }
      if (u && s.addEventListener("blur", u), this.data.comb) {
        const g = (this.data.rect[2] - this.data.rect[0]) / l;
        s.classList.add("comb"), s.style.letterSpacing = `calc(${g}px * var(--scale-factor) - 1ch)`;
      }
    } else
      s = document.createElement("div"), s.textContent = this.data.fieldValue, s.style.verticalAlign = "middle", s.style.display = "table-cell", this.data.hasOwnCanvas && (s.hidden = !0);
    return this._setTextStyle(s), this._setBackgroundColor(s), this._setDefaultPropertiesFromJS(s), this.container.append(s), this.container;
  }
}
class jw extends Wa {
  constructor(e) {
    super(e, {
      isRenderable: !!e.data.hasOwnCanvas
    });
  }
}
class Hw extends Wa {
  constructor(e) {
    super(e, {
      isRenderable: e.renderForms
    });
  }
  render() {
    const e = this.annotationStorage, t = this.data, s = t.id;
    let i = e.getValue(s, {
      value: t.exportValue === t.fieldValue
    }).value;
    typeof i == "string" && (i = i !== "Off", e.setValue(s, {
      value: i
    })), this.container.classList.add("buttonWidgetAnnotation", "checkBox");
    const n = document.createElement("input");
    return Ua.add(n), n.setAttribute("data-element-id", s), n.disabled = t.readOnly, this._setRequired(n, this.data.required), n.type = "checkbox", n.name = t.fieldName, i && n.setAttribute("checked", !0), n.setAttribute("exportValue", t.exportValue), n.tabIndex = xd, n.addEventListener("change", (r) => {
      const {
        name: o,
        checked: l
      } = r.target;
      for (const c of this._getElementsByName(o, s)) {
        const d = l && c.exportValue === t.exportValue;
        c.domElement && (c.domElement.checked = d), e.setValue(c.id, {
          value: d
        });
      }
      e.setValue(s, {
        value: l
      });
    }), n.addEventListener("resetform", (r) => {
      const o = t.defaultFieldValue || "Off";
      r.target.checked = o === t.exportValue;
    }), this.enableScripting && this.hasJSActions && (n.addEventListener("updatefromsandbox", (r) => {
      const o = {
        value(l) {
          l.target.checked = l.detail.value !== "Off", e.setValue(s, {
            value: l.target.checked
          });
        }
      };
      this._dispatchEventFromSandbox(o, r);
    }), this._setEventListeners(n, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (r) => r.target.checked)), this._setBackgroundColor(n), this._setDefaultPropertiesFromJS(n), this.container.append(n), this.container;
  }
}
class hb extends Wa {
  constructor(e) {
    super(e, {
      isRenderable: e.renderForms
    });
  }
  render() {
    this.container.classList.add("buttonWidgetAnnotation", "radioButton");
    const e = this.annotationStorage, t = this.data, s = t.id;
    let i = e.getValue(s, {
      value: t.fieldValue === t.buttonValue
    }).value;
    if (typeof i == "string" && (i = i !== t.buttonValue, e.setValue(s, {
      value: i
    })), i)
      for (const r of this._getElementsByName(t.fieldName, s))
        e.setValue(r.id, {
          value: !1
        });
    const n = document.createElement("input");
    if (Ua.add(n), n.setAttribute("data-element-id", s), n.disabled = t.readOnly, this._setRequired(n, this.data.required), n.type = "radio", n.name = t.fieldName, i && n.setAttribute("checked", !0), n.tabIndex = xd, n.addEventListener("change", (r) => {
      const {
        name: o,
        checked: l
      } = r.target;
      for (const c of this._getElementsByName(o, s))
        e.setValue(c.id, {
          value: !1
        });
      e.setValue(s, {
        value: l
      });
    }), n.addEventListener("resetform", (r) => {
      const o = t.defaultFieldValue;
      r.target.checked = o != null && o === t.buttonValue;
    }), this.enableScripting && this.hasJSActions) {
      const r = t.buttonValue;
      n.addEventListener("updatefromsandbox", (o) => {
        const l = {
          value: (c) => {
            const d = r === c.detail.value;
            for (const u of this._getElementsByName(c.target.name)) {
              const f = d && u.id === s;
              u.domElement && (u.domElement.checked = f), e.setValue(u.id, {
                value: f
              });
            }
          }
        };
        this._dispatchEventFromSandbox(l, o);
      }), this._setEventListeners(n, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (o) => o.target.checked);
    }
    return this._setBackgroundColor(n), this._setDefaultPropertiesFromJS(n), this.container.append(n), this.container;
  }
}
class $w extends ab {
  constructor(e) {
    super(e, {
      ignoreBorder: e.data.hasAppearance
    });
  }
  render() {
    const e = super.render();
    e.classList.add("buttonWidgetAnnotation", "pushButton");
    const t = e.lastChild;
    return this.enableScripting && this.hasJSActions && t && (this._setDefaultPropertiesFromJS(t), t.addEventListener("updatefromsandbox", (s) => {
      this._dispatchEventFromSandbox({}, s);
    })), e;
  }
}
class Vw extends Wa {
  constructor(e) {
    super(e, {
      isRenderable: e.renderForms
    });
  }
  render() {
    this.container.classList.add("choiceWidgetAnnotation");
    const e = this.annotationStorage, t = this.data.id, s = e.getValue(t, {
      value: this.data.fieldValue
    }), i = document.createElement("select");
    Ua.add(i), i.setAttribute("data-element-id", t), i.disabled = this.data.readOnly, this._setRequired(i, this.data.required), i.name = this.data.fieldName, i.tabIndex = xd;
    let n = this.data.combo && this.data.options.length > 0;
    this.data.combo || (i.size = this.data.options.length, this.data.multiSelect && (i.multiple = !0)), i.addEventListener("resetform", (d) => {
      const u = this.data.defaultFieldValue;
      for (const f of i.options)
        f.selected = f.value === u;
    });
    for (const d of this.data.options) {
      const u = document.createElement("option");
      u.textContent = d.displayValue, u.value = d.exportValue, s.value.includes(d.exportValue) && (u.setAttribute("selected", !0), n = !1), i.append(u);
    }
    let r = null;
    if (n) {
      const d = document.createElement("option");
      d.value = " ", d.setAttribute("hidden", !0), d.setAttribute("selected", !0), i.prepend(d), r = () => {
        d.remove(), i.removeEventListener("input", r), r = null;
      }, i.addEventListener("input", r);
    }
    const o = (d) => {
      const u = d ? "value" : "textContent", {
        options: f,
        multiple: g
      } = i;
      return g ? Array.prototype.filter.call(f, (m) => m.selected).map((m) => m[u]) : f.selectedIndex === -1 ? null : f[f.selectedIndex][u];
    };
    let l = o(!1);
    const c = (d) => {
      const u = d.target.options;
      return Array.prototype.map.call(u, (f) => ({
        displayValue: f.textContent,
        exportValue: f.value
      }));
    };
    return this.enableScripting && this.hasJSActions ? (i.addEventListener("updatefromsandbox", (d) => {
      const u = {
        value(f) {
          r == null || r();
          const g = f.detail.value, m = new Set(Array.isArray(g) ? g : [g]);
          for (const y of i.options)
            y.selected = m.has(y.value);
          e.setValue(t, {
            value: o(!0)
          }), l = o(!1);
        },
        multipleSelection(f) {
          i.multiple = !0;
        },
        remove(f) {
          const g = i.options, m = f.detail.remove;
          g[m].selected = !1, i.remove(m), g.length > 0 && Array.prototype.findIndex.call(g, (w) => w.selected) === -1 && (g[0].selected = !0), e.setValue(t, {
            value: o(!0),
            items: c(f)
          }), l = o(!1);
        },
        clear(f) {
          for (; i.length !== 0; )
            i.remove(0);
          e.setValue(t, {
            value: null,
            items: []
          }), l = o(!1);
        },
        insert(f) {
          const {
            index: g,
            displayValue: m,
            exportValue: y
          } = f.detail.insert, w = i.children[g], A = document.createElement("option");
          A.textContent = m, A.value = y, w ? w.before(A) : i.append(A), e.setValue(t, {
            value: o(!0),
            items: c(f)
          }), l = o(!1);
        },
        items(f) {
          const {
            items: g
          } = f.detail;
          for (; i.length !== 0; )
            i.remove(0);
          for (const m of g) {
            const {
              displayValue: y,
              exportValue: w
            } = m, A = document.createElement("option");
            A.textContent = y, A.value = w, i.append(A);
          }
          i.options.length > 0 && (i.options[0].selected = !0), e.setValue(t, {
            value: o(!0),
            items: c(f)
          }), l = o(!1);
        },
        indices(f) {
          const g = new Set(f.detail.indices);
          for (const m of f.target.options)
            m.selected = g.has(m.index);
          e.setValue(t, {
            value: o(!0)
          }), l = o(!1);
        },
        editable(f) {
          f.target.disabled = !f.detail.editable;
        }
      };
      this._dispatchEventFromSandbox(u, d);
    }), i.addEventListener("input", (d) => {
      var g;
      const u = o(!0), f = o(!1);
      e.setValue(t, {
        value: u
      }), d.preventDefault(), (g = this.linkService.eventBus) == null || g.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: t,
          name: "Keystroke",
          value: l,
          change: f,
          changeEx: u,
          willCommit: !1,
          commitKey: 1,
          keyDown: !1
        }
      });
    }), this._setEventListeners(i, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (d) => d.target.value)) : i.addEventListener("input", function(d) {
      e.setValue(t, {
        value: o(!0)
      });
    }), this.data.combo && this._setTextStyle(i), this._setBackgroundColor(i), this._setDefaultPropertiesFromJS(i), this.container.append(i), this.container;
  }
}
class yp extends Ut {
  constructor(e) {
    const {
      data: t,
      elements: s
    } = e;
    super(e, {
      isRenderable: Ut._hasPopupData(t)
    }), this.elements = s, this.popup = null;
  }
  render() {
    this.container.classList.add("popupAnnotation");
    const e = this.popup = new Uw({
      container: this.container,
      color: this.data.color,
      titleObj: this.data.titleObj,
      modificationDate: this.data.modificationDate,
      contentsObj: this.data.contentsObj,
      richText: this.data.richText,
      rect: this.data.rect,
      parentRect: this.data.parentRect || null,
      parent: this.parent,
      elements: this.elements,
      open: this.data.open
    }), t = [];
    for (const s of this.elements)
      s.popup = e, s.container.ariaHasPopup = "dialog", t.push(s.data.id), s.addHighlightArea();
    return this.container.setAttribute("aria-controls", t.map((s) => `${Lg}${s}`).join(",")), this.container;
  }
}
var jo, Xu, Yu, Ho, sa, Bt, $i, $o, uc, fc, Vo, Vi, Is, Ui, pc, zi, gc, ia, na, wt, qd, Ap, cb, db, ub, fb, tu, eu, wp;
class Uw {
  constructor({
    container: e,
    color: t,
    elements: s,
    titleObj: i,
    modificationDate: n,
    contentsObj: r,
    richText: o,
    parent: l,
    rect: c,
    parentRect: d,
    open: u
  }) {
    b(this, wt);
    b(this, jo, v(this, wt, ub).bind(this));
    b(this, Xu, v(this, wt, wp).bind(this));
    b(this, Yu, v(this, wt, eu).bind(this));
    b(this, Ho, v(this, wt, tu).bind(this));
    b(this, sa, null);
    b(this, Bt, null);
    b(this, $i, null);
    b(this, $o, null);
    b(this, uc, null);
    b(this, fc, null);
    b(this, Vo, null);
    b(this, Vi, !1);
    b(this, Is, null);
    b(this, Ui, null);
    b(this, pc, null);
    b(this, zi, null);
    b(this, gc, null);
    b(this, ia, null);
    b(this, na, !1);
    var f;
    p(this, Bt, e), p(this, gc, i), p(this, $i, r), p(this, zi, o), p(this, fc, l), p(this, sa, t), p(this, pc, c), p(this, Vo, d), p(this, uc, s), p(this, $o, sv.toDateObject(n)), this.trigger = s.flatMap((g) => g.getElementsToTriggerPopup());
    for (const g of this.trigger)
      g.addEventListener("click", a(this, Ho)), g.addEventListener("mouseenter", a(this, Yu)), g.addEventListener("mouseleave", a(this, Xu)), g.classList.add("popupTriggerArea");
    for (const g of s)
      (f = g.container) == null || f.addEventListener("keydown", a(this, jo));
    a(this, Bt).hidden = !0, u && v(this, wt, tu).call(this);
  }
  render() {
    if (a(this, Is))
      return;
    const e = p(this, Is, document.createElement("div"));
    if (e.className = "popup", a(this, sa)) {
      const n = e.style.outlineColor = X.makeHexColor(...a(this, sa));
      CSS.supports("background-color", "color-mix(in srgb, red 30%, white)") ? e.style.backgroundColor = `color-mix(in srgb, ${n} 30%, white)` : e.style.backgroundColor = X.makeHexColor(...a(this, sa).map((o) => Math.floor(0.7 * (255 - o) + o)));
    }
    const t = document.createElement("span");
    t.className = "header";
    const s = document.createElement("h1");
    if (t.append(s), {
      dir: s.dir,
      str: s.textContent
    } = a(this, gc), e.append(t), a(this, $o)) {
      const n = document.createElement("span");
      n.classList.add("popupDate"), n.setAttribute("data-l10n-id", "pdfjs-annotation-date-time-string"), n.setAttribute("data-l10n-args", JSON.stringify({
        dateObj: a(this, $o).valueOf()
      })), t.append(n);
    }
    const i = a(this, wt, qd);
    if (i)
      rb.render({
        xfaHtml: i,
        intent: "richText",
        div: e
      }), e.lastChild.classList.add("richText", "popupContent");
    else {
      const n = this._formatContents(a(this, $i));
      e.append(n);
    }
    a(this, Bt).append(e);
  }
  _formatContents({
    str: e,
    dir: t
  }) {
    const s = document.createElement("p");
    s.classList.add("popupContent"), s.dir = t;
    const i = e.split(/(?:\r\n?|\n)/);
    for (let n = 0, r = i.length; n < r; ++n) {
      const o = i[n];
      s.append(document.createTextNode(o)), n < r - 1 && s.append(document.createElement("br"));
    }
    return s;
  }
  updateEdited({
    rect: e,
    popupContent: t
  }) {
    var s;
    a(this, ia) || p(this, ia, {
      contentsObj: a(this, $i),
      richText: a(this, zi)
    }), e && p(this, Ui, null), t && (p(this, zi, v(this, wt, db).call(this, t)), p(this, $i, null)), (s = a(this, Is)) == null || s.remove(), p(this, Is, null);
  }
  resetEdited() {
    var e;
    a(this, ia) && ({
      contentsObj: me(this, $i)._,
      richText: me(this, zi)._
    } = a(this, ia), p(this, ia, null), (e = a(this, Is)) == null || e.remove(), p(this, Is, null), p(this, Ui, null));
  }
  forceHide() {
    p(this, na, this.isVisible), a(this, na) && (a(this, Bt).hidden = !0);
  }
  maybeShow() {
    a(this, na) && (a(this, Is) || v(this, wt, eu).call(this), p(this, na, !1), a(this, Bt).hidden = !1);
  }
  get isVisible() {
    return a(this, Bt).hidden === !1;
  }
}
jo = new WeakMap(), Xu = new WeakMap(), Yu = new WeakMap(), Ho = new WeakMap(), sa = new WeakMap(), Bt = new WeakMap(), $i = new WeakMap(), $o = new WeakMap(), uc = new WeakMap(), fc = new WeakMap(), Vo = new WeakMap(), Vi = new WeakMap(), Is = new WeakMap(), Ui = new WeakMap(), pc = new WeakMap(), zi = new WeakMap(), gc = new WeakMap(), ia = new WeakMap(), na = new WeakMap(), wt = new WeakSet(), qd = function() {
  const e = a(this, zi), t = a(this, $i);
  return e != null && e.str && (!(t != null && t.str) || t.str === e.str) && a(this, zi).html || null;
}, Ap = function() {
  var e, t, s;
  return ((s = (t = (e = a(this, wt, qd)) == null ? void 0 : e.attributes) == null ? void 0 : t.style) == null ? void 0 : s.fontSize) || 0;
}, cb = function() {
  var e, t, s;
  return ((s = (t = (e = a(this, wt, qd)) == null ? void 0 : e.attributes) == null ? void 0 : t.style) == null ? void 0 : s.color) || null;
}, db = function(e) {
  const t = [], s = {
    str: e,
    html: {
      name: "div",
      attributes: {
        dir: "auto"
      },
      children: [{
        name: "p",
        children: t
      }]
    }
  }, i = {
    style: {
      color: a(this, wt, cb),
      fontSize: a(this, wt, Ap) ? `calc(${a(this, wt, Ap)}px * var(--scale-factor))` : ""
    }
  };
  for (const n of e.split(`
`))
    t.push({
      name: "span",
      value: n,
      attributes: i
    });
  return s;
}, ub = function(e) {
  e.altKey || e.shiftKey || e.ctrlKey || e.metaKey || (e.key === "Enter" || e.key === "Escape" && a(this, Vi)) && v(this, wt, tu).call(this);
}, fb = function() {
  if (a(this, Ui) !== null)
    return;
  const {
    page: {
      view: e
    },
    viewport: {
      rawDims: {
        pageWidth: t,
        pageHeight: s,
        pageX: i,
        pageY: n
      }
    }
  } = a(this, fc);
  let r = !!a(this, Vo), o = r ? a(this, Vo) : a(this, pc);
  for (const m of a(this, uc))
    if (!o || X.intersect(m.data.rect, o) !== null) {
      o = m.data.rect, r = !0;
      break;
    }
  const l = X.normalizeRect([o[0], e[3] - o[1] + e[1], o[2], e[3] - o[3] + e[1]]), d = r ? o[2] - o[0] + 5 : 0, u = l[0] + d, f = l[1];
  p(this, Ui, [100 * (u - i) / t, 100 * (f - n) / s]);
  const {
    style: g
  } = a(this, Bt);
  g.left = `${a(this, Ui)[0]}%`, g.top = `${a(this, Ui)[1]}%`;
}, tu = function() {
  p(this, Vi, !a(this, Vi)), a(this, Vi) ? (v(this, wt, eu).call(this), a(this, Bt).addEventListener("click", a(this, Ho)), a(this, Bt).addEventListener("keydown", a(this, jo))) : (v(this, wt, wp).call(this), a(this, Bt).removeEventListener("click", a(this, Ho)), a(this, Bt).removeEventListener("keydown", a(this, jo)));
}, eu = function() {
  a(this, Is) || this.render(), this.isVisible ? a(this, Vi) && a(this, Bt).classList.add("focused") : (v(this, wt, fb).call(this), a(this, Bt).hidden = !1, a(this, Bt).style.zIndex = parseInt(a(this, Bt).style.zIndex) + 1e3);
}, wp = function() {
  a(this, Bt).classList.remove("focused"), !(a(this, Vi) || !this.isVisible) && (a(this, Bt).hidden = !0, a(this, Bt).style.zIndex = parseInt(a(this, Bt).style.zIndex) - 1e3);
};
class pb extends Ut {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0
    }), this.textContent = e.data.textContent, this.textPosition = e.data.textPosition, this.annotationEditorType = at.FREETEXT;
  }
  render() {
    if (this.container.classList.add("freeTextAnnotation"), this.textContent) {
      const e = document.createElement("div");
      e.classList.add("annotationTextContent"), e.setAttribute("role", "comment");
      for (const t of this.textContent) {
        const s = document.createElement("span");
        s.textContent = t, e.append(s);
      }
      this.container.append(e);
    }
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
  }
}
var mc;
class zw extends Ut {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    b(this, mc, null);
  }
  render() {
    this.container.classList.add("lineAnnotation");
    const t = this.data, {
      width: s,
      height: i
    } = cr(t.rect), n = this.svgFactory.create(s, i, !0), r = p(this, mc, this.svgFactory.createElement("svg:line"));
    return r.setAttribute("x1", t.rect[2] - t.lineCoordinates[0]), r.setAttribute("y1", t.rect[3] - t.lineCoordinates[1]), r.setAttribute("x2", t.rect[2] - t.lineCoordinates[2]), r.setAttribute("y2", t.rect[3] - t.lineCoordinates[3]), r.setAttribute("stroke-width", t.borderStyle.width || 1), r.setAttribute("stroke", "transparent"), r.setAttribute("fill", "transparent"), n.append(r), this.container.append(n), !t.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return a(this, mc);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
mc = new WeakMap();
var vc;
class Ww extends Ut {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    b(this, vc, null);
  }
  render() {
    this.container.classList.add("squareAnnotation");
    const t = this.data, {
      width: s,
      height: i
    } = cr(t.rect), n = this.svgFactory.create(s, i, !0), r = t.borderStyle.width, o = p(this, vc, this.svgFactory.createElement("svg:rect"));
    return o.setAttribute("x", r / 2), o.setAttribute("y", r / 2), o.setAttribute("width", s - r), o.setAttribute("height", i - r), o.setAttribute("stroke-width", r || 1), o.setAttribute("stroke", "transparent"), o.setAttribute("fill", "transparent"), n.append(o), this.container.append(n), !t.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return a(this, vc);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
vc = new WeakMap();
var bc;
class Gw extends Ut {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    b(this, bc, null);
  }
  render() {
    this.container.classList.add("circleAnnotation");
    const t = this.data, {
      width: s,
      height: i
    } = cr(t.rect), n = this.svgFactory.create(s, i, !0), r = t.borderStyle.width, o = p(this, bc, this.svgFactory.createElement("svg:ellipse"));
    return o.setAttribute("cx", s / 2), o.setAttribute("cy", i / 2), o.setAttribute("rx", s / 2 - r / 2), o.setAttribute("ry", i / 2 - r / 2), o.setAttribute("stroke-width", r || 1), o.setAttribute("stroke", "transparent"), o.setAttribute("fill", "transparent"), n.append(o), this.container.append(n), !t.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return a(this, bc);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
bc = new WeakMap();
var yc;
class gb extends Ut {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    b(this, yc, null);
    this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const {
      data: {
        rect: t,
        vertices: s,
        borderStyle: i,
        popupRef: n
      }
    } = this;
    if (!s)
      return this.container;
    const {
      width: r,
      height: o
    } = cr(t), l = this.svgFactory.create(r, o, !0);
    let c = [];
    for (let u = 0, f = s.length; u < f; u += 2) {
      const g = s[u] - t[0], m = t[3] - s[u + 1];
      c.push(`${g},${m}`);
    }
    c = c.join(" ");
    const d = p(this, yc, this.svgFactory.createElement(this.svgElementName));
    return d.setAttribute("points", c), d.setAttribute("stroke-width", i.width || 1), d.setAttribute("stroke", "transparent"), d.setAttribute("fill", "transparent"), l.append(d), this.container.append(l), !n && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return a(this, yc);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
yc = new WeakMap();
class Xw extends gb {
  constructor(e) {
    super(e), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
  }
}
class Yw extends Ut {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0
    });
  }
  render() {
    return this.container.classList.add("caretAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
}
var Ac, ra, wc, Ep;
class Bg extends Ut {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    b(this, wc);
    b(this, Ac, null);
    b(this, ra, []);
    this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = this.data.it === "InkHighlight" ? at.HIGHLIGHT : at.INK;
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const {
      data: {
        rect: t,
        rotation: s,
        inkLists: i,
        borderStyle: n,
        popupRef: r
      }
    } = this, {
      transform: o,
      width: l,
      height: c
    } = v(this, wc, Ep).call(this, s, t), d = this.svgFactory.create(l, c, !0), u = p(this, Ac, this.svgFactory.createElement("svg:g"));
    d.append(u), u.setAttribute("stroke-width", n.width || 1), u.setAttribute("stroke-linecap", "round"), u.setAttribute("stroke-linejoin", "round"), u.setAttribute("stroke-miterlimit", 10), u.setAttribute("stroke", "transparent"), u.setAttribute("fill", "transparent"), u.setAttribute("transform", o);
    for (let f = 0, g = i.length; f < g; f++) {
      const m = this.svgFactory.createElement(this.svgElementName);
      a(this, ra).push(m), m.setAttribute("points", i[f].join(",")), u.append(m);
    }
    return !r && this.hasPopupData && this._createPopup(), this.container.append(d), this._editOnDoubleClick(), this.container;
  }
  updateEdited(t) {
    super.updateEdited(t);
    const {
      thickness: s,
      points: i,
      rect: n
    } = t, r = a(this, Ac);
    if (s >= 0 && r.setAttribute("stroke-width", s || 1), i)
      for (let o = 0, l = a(this, ra).length; o < l; o++)
        a(this, ra)[o].setAttribute("points", i[o].join(","));
    if (n) {
      const {
        transform: o,
        width: l,
        height: c
      } = v(this, wc, Ep).call(this, this.data.rotation, n);
      r.parentElement.setAttribute("viewBox", `0 0 ${l} ${c}`), r.setAttribute("transform", o);
    }
  }
  getElementsToTriggerPopup() {
    return a(this, ra);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
Ac = new WeakMap(), ra = new WeakMap(), wc = new WeakSet(), Ep = function(t, s) {
  switch (t) {
    case 90:
      return {
        transform: `rotate(90) translate(${-s[0]},${s[1]}) scale(1,-1)`,
        width: s[3] - s[1],
        height: s[2] - s[0]
      };
    case 180:
      return {
        transform: `rotate(180) translate(${-s[2]},${s[1]}) scale(1,-1)`,
        width: s[2] - s[0],
        height: s[3] - s[1]
      };
    case 270:
      return {
        transform: `rotate(270) translate(${-s[2]},${s[3]}) scale(1,-1)`,
        width: s[3] - s[1],
        height: s[2] - s[0]
      };
    default:
      return {
        transform: `translate(${-s[0]},${s[3]}) scale(1,-1)`,
        width: s[2] - s[0],
        height: s[3] - s[1]
      };
  }
};
class mb extends Ut {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    }), this.annotationEditorType = at.HIGHLIGHT;
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("highlightAnnotation"), this._editOnDoubleClick(), this.container;
  }
}
class Kw extends Ut {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("underlineAnnotation"), this.container;
  }
}
class Qw extends Ut {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("squigglyAnnotation"), this.container;
  }
}
class Zw extends Ut {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), this.container;
  }
}
class vb extends Ut {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0
    }), this.annotationEditorType = at.STAMP;
  }
  render() {
    return this.container.classList.add("stampAnnotation"), this.container.setAttribute("role", "img"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
  }
}
var Ec, Sc, Sp;
class Jw extends Ut {
  constructor(t) {
    var i;
    super(t, {
      isRenderable: !0
    });
    b(this, Sc);
    b(this, Ec, null);
    const {
      file: s
    } = this.data;
    this.filename = s.filename, this.content = s.content, (i = this.linkService.eventBus) == null || i.dispatch("fileattachmentannotation", {
      source: this,
      ...s
    });
  }
  render() {
    this.container.classList.add("fileAttachmentAnnotation");
    const {
      container: t,
      data: s
    } = this;
    let i;
    s.hasAppearance || s.fillAlpha === 0 ? i = document.createElement("div") : (i = document.createElement("img"), i.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(s.name) ? "paperclip" : "pushpin"}.svg`, s.fillAlpha && s.fillAlpha < 1 && (i.style = `filter: opacity(${Math.round(s.fillAlpha * 100)}%);`)), i.addEventListener("dblclick", v(this, Sc, Sp).bind(this)), p(this, Ec, i);
    const {
      isMac: n
    } = Oe.platform;
    return t.addEventListener("keydown", (r) => {
      r.key === "Enter" && (n ? r.metaKey : r.ctrlKey) && v(this, Sc, Sp).call(this);
    }), !s.popupRef && this.hasPopupData ? this._createPopup() : i.classList.add("popupTriggerArea"), t.append(i), t;
  }
  getElementsToTriggerPopup() {
    return a(this, Ec);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
Ec = new WeakMap(), Sc = new WeakSet(), Sp = function() {
  var t;
  (t = this.downloadManager) == null || t.openOrDownloadData(this.content, this.filename);
};
var xc, aa, oa, Tc, za, bb, xp, Zm;
let qw = (Zm = class {
  constructor({
    div: e,
    accessibilityManager: t,
    annotationCanvasMap: s,
    annotationEditorUIManager: i,
    page: n,
    viewport: r,
    structTreeLayer: o
  }) {
    b(this, za);
    b(this, xc, null);
    b(this, aa, null);
    b(this, oa, /* @__PURE__ */ new Map());
    b(this, Tc, null);
    this.div = e, p(this, xc, t), p(this, aa, s), p(this, Tc, o || null), this.page = n, this.viewport = r, this.zIndex = 0, this._annotationEditorUIManager = i;
  }
  hasEditableAnnotations() {
    return a(this, oa).size > 0;
  }
  async render(e) {
    var r;
    const {
      annotations: t
    } = e, s = this.div;
    Va(s, this.viewport);
    const i = /* @__PURE__ */ new Map(), n = {
      data: null,
      layer: s,
      linkService: e.linkService,
      downloadManager: e.downloadManager,
      imageResourcesPath: e.imageResourcesPath || "",
      renderForms: e.renderForms !== !1,
      svgFactory: new Fg(),
      annotationStorage: e.annotationStorage || new Dg(),
      enableScripting: e.enableScripting === !0,
      hasJSActions: e.hasJSActions,
      fieldObjects: e.fieldObjects,
      parent: this,
      elements: null
    };
    for (const o of t) {
      if (o.noHTML)
        continue;
      const l = o.annotationType === Yt.POPUP;
      if (l) {
        const u = i.get(o.id);
        if (!u)
          continue;
        n.elements = u;
      } else {
        const {
          width: u,
          height: f
        } = cr(o.rect);
        if (u <= 0 || f <= 0)
          continue;
      }
      n.data = o;
      const c = kw.create(n);
      if (!c.isRenderable)
        continue;
      if (!l && o.popupRef) {
        const u = i.get(o.popupRef);
        u ? u.push(c) : i.set(o.popupRef, [c]);
      }
      const d = c.render();
      o.hidden && (d.style.visibility = "hidden"), await v(this, za, bb).call(this, d, o.id), c._isEditable && (a(this, oa).set(c.data.id, c), (r = this._annotationEditorUIManager) == null || r.renderAnnotationElement(c));
    }
    v(this, za, xp).call(this);
  }
  update({
    viewport: e
  }) {
    const t = this.div;
    this.viewport = e, Va(t, {
      rotation: e.rotation
    }), v(this, za, xp).call(this), t.hidden = !1;
  }
  getEditableAnnotations() {
    return Array.from(a(this, oa).values());
  }
  getEditableAnnotation(e) {
    return a(this, oa).get(e);
  }
}, xc = new WeakMap(), aa = new WeakMap(), oa = new WeakMap(), Tc = new WeakMap(), za = new WeakSet(), bb = async function(e, t) {
  var r, o;
  const s = e.firstChild || e, i = s.id = `${Lg}${t}`, n = await ((r = a(this, Tc)) == null ? void 0 : r.getAriaAttributes(i));
  if (n)
    for (const [l, c] of n)
      s.setAttribute(l, c);
  this.div.append(e), (o = a(this, xc)) == null || o.moveElementInDOM(this.div, e, s, !1);
}, xp = function() {
  if (!a(this, aa))
    return;
  const e = this.div;
  for (const [t, s] of a(this, aa)) {
    const i = e.querySelector(`[data-annotation-id="${t}"]`);
    if (!i)
      continue;
    s.className = "annotationContent";
    const {
      firstChild: n
    } = i;
    n ? n.nodeName === "CANVAS" ? n.replaceWith(s) : n.classList.contains("annotationContent") ? n.after(s) : n.before(s) : i.append(s);
  }
  a(this, aa).clear();
}, Zm);
const Id = /\r\n?|\n/g;
var _s, Qe, Pc, la, Ze, Xt, yb, Ab, wb, su, ln, iu, nu, Eb, Pp, Sb;
const Ct = class Ct extends Ot {
  constructor(t) {
    super({
      ...t,
      name: "freeTextEditor"
    });
    b(this, Xt);
    b(this, _s);
    b(this, Qe, "");
    b(this, Pc, `${this.id}-editor`);
    b(this, la, null);
    b(this, Ze);
    p(this, _s, t.color || Ct._defaultColor || Ot._defaultLineColor), p(this, Ze, t.fontSize || Ct._defaultFontSize);
  }
  static get _keyboardManager() {
    const t = Ct.prototype, s = (r) => r.isEmpty(), i = vh.TRANSLATE_SMALL, n = vh.TRANSLATE_BIG;
    return ht(this, "_keyboardManager", new Sd([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], t.commitOrRemove, {
      bubbles: !0
    }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], t.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], t._translateEmpty, {
      args: [-i, 0],
      checker: s
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], t._translateEmpty, {
      args: [-n, 0],
      checker: s
    }], [["ArrowRight", "mac+ArrowRight"], t._translateEmpty, {
      args: [i, 0],
      checker: s
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], t._translateEmpty, {
      args: [n, 0],
      checker: s
    }], [["ArrowUp", "mac+ArrowUp"], t._translateEmpty, {
      args: [0, -i],
      checker: s
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], t._translateEmpty, {
      args: [0, -n],
      checker: s
    }], [["ArrowDown", "mac+ArrowDown"], t._translateEmpty, {
      args: [0, i],
      checker: s
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], t._translateEmpty, {
      args: [0, n],
      checker: s
    }]]));
  }
  static initialize(t, s) {
    Ot.initialize(t, s);
    const i = getComputedStyle(document.documentElement);
    this._internalPadding = parseFloat(i.getPropertyValue("--freetext-padding"));
  }
  static updateDefaultParams(t, s) {
    switch (t) {
      case ct.FREETEXT_SIZE:
        Ct._defaultFontSize = s;
        break;
      case ct.FREETEXT_COLOR:
        Ct._defaultColor = s;
        break;
    }
  }
  updateParams(t, s) {
    switch (t) {
      case ct.FREETEXT_SIZE:
        v(this, Xt, yb).call(this, s);
        break;
      case ct.FREETEXT_COLOR:
        v(this, Xt, Ab).call(this, s);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[ct.FREETEXT_SIZE, Ct._defaultFontSize], [ct.FREETEXT_COLOR, Ct._defaultColor || Ot._defaultLineColor]];
  }
  get propertiesToUpdate() {
    return [[ct.FREETEXT_SIZE, a(this, Ze)], [ct.FREETEXT_COLOR, a(this, _s)]];
  }
  _translateEmpty(t, s) {
    this._uiManager.translateSelectedEditors(t, s, !0);
  }
  getInitialTranslation() {
    const t = this.parentScale;
    return [-Ct._internalPadding * t, -(Ct._internalPadding + a(this, Ze)) * t];
  }
  rebuild() {
    this.parent && (super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this)));
  }
  enableEditMode() {
    if (this.isInEditMode())
      return;
    this.parent.setEditingState(!1), this.parent.updateToolbar(at.FREETEXT), super.enableEditMode(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this._isDraggable = !1, this.div.removeAttribute("aria-activedescendant"), p(this, la, new AbortController());
    const t = this._uiManager.combinedSignal(a(this, la));
    this.editorDiv.addEventListener("keydown", this.editorDivKeydown.bind(this), {
      signal: t
    }), this.editorDiv.addEventListener("focus", this.editorDivFocus.bind(this), {
      signal: t
    }), this.editorDiv.addEventListener("blur", this.editorDivBlur.bind(this), {
      signal: t
    }), this.editorDiv.addEventListener("input", this.editorDivInput.bind(this), {
      signal: t
    }), this.editorDiv.addEventListener("paste", this.editorDivPaste.bind(this), {
      signal: t
    });
  }
  disableEditMode() {
    var t;
    this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.setAttribute("aria-activedescendant", a(this, Pc)), this._isDraggable = !0, (t = a(this, la)) == null || t.abort(), p(this, la, null), this.div.focus({
      preventScroll: !0
    }), this.isEditing = !1, this.parent.div.classList.add("freetextEditing"));
  }
  focusin(t) {
    this._focusEventsAllowed && (super.focusin(t), t.target !== this.editorDiv && this.editorDiv.focus());
  }
  onceAdded(t) {
    var s;
    this.width || (this.enableEditMode(), t && this.editorDiv.focus(), (s = this._initialOptions) != null && s.isCentered && this.center(), this._initialOptions = null);
  }
  isEmpty() {
    return !this.editorDiv || this.editorDiv.innerText.trim() === "";
  }
  remove() {
    this.isEditing = !1, this.parent && (this.parent.setEditingState(!0), this.parent.div.classList.add("freetextEditing")), super.remove();
  }
  commit() {
    if (!this.isInEditMode())
      return;
    super.commit(), this.disableEditMode();
    const t = a(this, Qe), s = p(this, Qe, v(this, Xt, wb).call(this).trimEnd());
    if (t === s)
      return;
    const i = (n) => {
      if (p(this, Qe, n), !n) {
        this.remove();
        return;
      }
      v(this, Xt, nu).call(this), this._uiManager.rebuild(this), v(this, Xt, su).call(this);
    };
    this.addCommands({
      cmd: () => {
        i(s);
      },
      undo: () => {
        i(t);
      },
      mustExec: !1
    }), v(this, Xt, su).call(this);
  }
  shouldGetKeyboardEvents() {
    return this.isInEditMode();
  }
  enterInEditMode() {
    this.enableEditMode(), this.editorDiv.focus();
  }
  dblclick(t) {
    this.enterInEditMode();
  }
  keydown(t) {
    t.target === this.div && t.key === "Enter" && (this.enterInEditMode(), t.preventDefault());
  }
  editorDivKeydown(t) {
    Ct._keyboardManager.exec(this, t);
  }
  editorDivFocus(t) {
    this.isEditing = !0;
  }
  editorDivBlur(t) {
    this.isEditing = !1;
  }
  editorDivInput(t) {
    this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
  }
  disableEditing() {
    this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
  }
  enableEditing() {
    this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0);
  }
  render() {
    if (this.div)
      return this.div;
    let t, s;
    this.width && (t = this.x, s = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", a(this, Pc)), this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text2"), this.editorDiv.setAttribute("data-l10n-attrs", "default-content"), this.enableEditing(), this.editorDiv.contentEditable = !0;
    const {
      style: i
    } = this.editorDiv;
    if (i.fontSize = `calc(${a(this, Ze)}px * var(--scale-factor))`, i.color = a(this, _s), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), Pu(this, this.div, ["dblclick", "keydown"]), this.width) {
      const [n, r] = this.parentDimensions;
      if (this.annotationElementId) {
        const {
          position: o
        } = this._initialData;
        let [l, c] = this.getInitialTranslation();
        [l, c] = this.pageTranslationToScreen(l, c);
        const [d, u] = this.pageDimensions, [f, g] = this.pageTranslation;
        let m, y;
        switch (this.rotation) {
          case 0:
            m = t + (o[0] - f) / d, y = s + this.height - (o[1] - g) / u;
            break;
          case 90:
            m = t + (o[0] - f) / d, y = s - (o[1] - g) / u, [l, c] = [c, -l];
            break;
          case 180:
            m = t - this.width + (o[0] - f) / d, y = s - (o[1] - g) / u, [l, c] = [-l, -c];
            break;
          case 270:
            m = t + (o[0] - f - this.height * u) / d, y = s + (o[1] - g - this.width * d) / u, [l, c] = [-c, l];
            break;
        }
        this.setAt(m * n, y * r, l, c);
      } else
        this.setAt(t * n, s * r, this.width * n, this.height * r);
      v(this, Xt, nu).call(this), this._isDraggable = !0, this.editorDiv.contentEditable = !1;
    } else
      this._isDraggable = !1, this.editorDiv.contentEditable = !0;
    return this.div;
  }
  editorDivPaste(t) {
    var m, y, w;
    const s = t.clipboardData || window.clipboardData, {
      types: i
    } = s;
    if (i.length === 1 && i[0] === "text/plain")
      return;
    t.preventDefault();
    const n = v(m = Ct, ln, Pp).call(m, s.getData("text") || "").replaceAll(Id, `
`);
    if (!n)
      return;
    const r = window.getSelection();
    if (!r.rangeCount)
      return;
    this.editorDiv.normalize(), r.deleteFromDocument();
    const o = r.getRangeAt(0);
    if (!n.includes(`
`)) {
      o.insertNode(document.createTextNode(n)), this.editorDiv.normalize(), r.collapseToStart();
      return;
    }
    const {
      startContainer: l,
      startOffset: c
    } = o, d = [], u = [];
    if (l.nodeType === Node.TEXT_NODE) {
      const A = l.parentElement;
      if (u.push(l.nodeValue.slice(c).replaceAll(Id, "")), A !== this.editorDiv) {
        let E = d;
        for (const S of this.editorDiv.childNodes) {
          if (S === A) {
            E = u;
            continue;
          }
          E.push(v(y = Ct, ln, iu).call(y, S));
        }
      }
      d.push(l.nodeValue.slice(0, c).replaceAll(Id, ""));
    } else if (l === this.editorDiv) {
      let A = d, E = 0;
      for (const S of this.editorDiv.childNodes)
        E++ === c && (A = u), A.push(v(w = Ct, ln, iu).call(w, S));
    }
    p(this, Qe, `${d.join(`
`)}${n}${u.join(`
`)}`), v(this, Xt, nu).call(this);
    const f = new Range();
    let g = d.reduce((A, E) => A + E.length, 0);
    for (const {
      firstChild: A
    } of this.editorDiv.childNodes)
      if (A.nodeType === Node.TEXT_NODE) {
        const E = A.nodeValue.length;
        if (g <= E) {
          f.setStart(A, g), f.setEnd(A, g);
          break;
        }
        g -= E;
      }
    r.removeAllRanges(), r.addRange(f);
  }
  get contentDiv() {
    return this.editorDiv;
  }
  static async deserialize(t, s, i) {
    var o;
    let n = null;
    if (t instanceof pb) {
      const {
        data: {
          defaultAppearanceData: {
            fontSize: l,
            fontColor: c
          },
          rect: d,
          rotation: u,
          id: f,
          popupRef: g
        },
        textContent: m,
        textPosition: y,
        parent: {
          page: {
            pageNumber: w
          }
        }
      } = t;
      if (!m || m.length === 0)
        return null;
      n = t = {
        annotationType: at.FREETEXT,
        color: Array.from(c),
        fontSize: l,
        value: m.join(`
`),
        position: y,
        pageIndex: w - 1,
        rect: d.slice(0),
        rotation: u,
        id: f,
        deleted: !1,
        popupRef: g
      };
    }
    const r = await super.deserialize(t, s, i);
    return p(r, Ze, t.fontSize), p(r, _s, X.makeHexColor(...t.color)), p(r, Qe, v(o = Ct, ln, Pp).call(o, t.value)), r.annotationElementId = t.id || null, r._initialData = n, r;
  }
  serialize(t = !1) {
    if (this.isEmpty())
      return null;
    if (this.deleted)
      return this.serializeDeleted();
    const s = Ct._internalPadding * this.parentScale, i = this.getRect(s, s), n = Ot._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : a(this, _s)), r = {
      annotationType: at.FREETEXT,
      color: n,
      fontSize: a(this, Ze),
      value: v(this, Xt, Eb).call(this),
      pageIndex: this.pageIndex,
      rect: i,
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId
    };
    return t ? r : this.annotationElementId && !v(this, Xt, Sb).call(this, r) ? null : (r.id = this.annotationElementId, r);
  }
  renderAnnotationElement(t) {
    const s = super.renderAnnotationElement(t);
    if (this.deleted)
      return s;
    const {
      style: i
    } = s;
    i.fontSize = `calc(${a(this, Ze)}px * var(--scale-factor))`, i.color = a(this, _s), s.replaceChildren();
    for (const r of a(this, Qe).split(`
`)) {
      const o = document.createElement("div");
      o.append(r ? document.createTextNode(r) : document.createElement("br")), s.append(o);
    }
    const n = Ct._internalPadding * this.parentScale;
    return t.updateEdited({
      rect: this.getRect(n, n),
      popupContent: a(this, Qe)
    }), s;
  }
  resetAnnotationElement(t) {
    super.resetAnnotationElement(t), t.resetEdited();
  }
};
_s = new WeakMap(), Qe = new WeakMap(), Pc = new WeakMap(), la = new WeakMap(), Ze = new WeakMap(), Xt = new WeakSet(), yb = function(t) {
  const s = (n) => {
    this.editorDiv.style.fontSize = `calc(${n}px * var(--scale-factor))`, this.translate(0, -(n - a(this, Ze)) * this.parentScale), p(this, Ze, n), v(this, Xt, su).call(this);
  }, i = a(this, Ze);
  this.addCommands({
    cmd: s.bind(this, t),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: ct.FREETEXT_SIZE,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, Ab = function(t) {
  const s = (n) => {
    p(this, _s, this.editorDiv.style.color = n);
  }, i = a(this, _s);
  this.addCommands({
    cmd: s.bind(this, t),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: ct.FREETEXT_COLOR,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, wb = function() {
  var i;
  const t = [];
  this.editorDiv.normalize();
  let s = null;
  for (const n of this.editorDiv.childNodes)
    (s == null ? void 0 : s.nodeType) === Node.TEXT_NODE && n.nodeName === "BR" || (t.push(v(i = Ct, ln, iu).call(i, n)), s = n);
  return t.join(`
`);
}, su = function() {
  const [t, s] = this.parentDimensions;
  let i;
  if (this.isAttachedToDOM)
    i = this.div.getBoundingClientRect();
  else {
    const {
      currentLayer: n,
      div: r
    } = this, o = r.style.display, l = r.classList.contains("hidden");
    r.classList.remove("hidden"), r.style.display = "hidden", n.div.append(this.div), i = r.getBoundingClientRect(), r.remove(), r.style.display = o, r.classList.toggle("hidden", l);
  }
  this.rotation % 180 === this.parentRotation % 180 ? (this.width = i.width / t, this.height = i.height / s) : (this.width = i.height / t, this.height = i.width / s), this.fixAndSetPosition();
}, ln = new WeakSet(), iu = function(t) {
  return (t.nodeType === Node.TEXT_NODE ? t.nodeValue : t.innerText).replaceAll(Id, "");
}, nu = function() {
  if (this.editorDiv.replaceChildren(), !!a(this, Qe))
    for (const t of a(this, Qe).split(`
`)) {
      const s = document.createElement("div");
      s.append(t ? document.createTextNode(t) : document.createElement("br")), this.editorDiv.append(s);
    }
}, Eb = function() {
  return a(this, Qe).replaceAll(" ", " ");
}, Pp = function(t) {
  return t.replaceAll(" ", " ");
}, Sb = function(t) {
  const {
    value: s,
    fontSize: i,
    color: n,
    pageIndex: r
  } = this._initialData;
  return this._hasBeenMoved || t.value !== s || t.fontSize !== i || t.color.some((o, l) => o !== n[l]) || t.pageIndex !== r;
}, b(Ct, ln), K(Ct, "_freeTextDefaultContent", ""), K(Ct, "_internalPadding", 0), K(Ct, "_defaultColor", null), K(Ct, "_defaultFontSize", 10), K(Ct, "_type", "freetext"), K(Ct, "_editorType", at.FREETEXT);
let Tp = Ct;
class U {
  toSVGPath() {
    Pt("Abstract method `toSVGPath` must be implemented.");
  }
  get box() {
    Pt("Abstract getter `box` must be implemented.");
  }
  serialize(e, t) {
    Pt("Abstract method `serialize` must be implemented.");
  }
  static _rescale(e, t, s, i, n, r) {
    r || (r = new Float32Array(e.length));
    for (let o = 0, l = e.length; o < l; o += 2)
      r[o] = t + e[o] * i, r[o + 1] = s + e[o + 1] * n;
    return r;
  }
  static _rescaleAndSwap(e, t, s, i, n, r) {
    r || (r = new Float32Array(e.length));
    for (let o = 0, l = e.length; o < l; o += 2)
      r[o] = t + e[o + 1] * i, r[o + 1] = s + e[o] * n;
    return r;
  }
  static _translate(e, t, s, i) {
    i || (i = new Float32Array(e.length));
    for (let n = 0, r = e.length; n < r; n += 2)
      i[n] = t + e[n], i[n + 1] = s + e[n + 1];
    return i;
  }
  static svgRound(e) {
    return Math.round(e * 1e4);
  }
  static _normalizePoint(e, t, s, i, n) {
    switch (n) {
      case 90:
        return [1 - t / s, e / i];
      case 180:
        return [1 - e / s, 1 - t / i];
      case 270:
        return [t / s, 1 - e / i];
      default:
        return [e / s, t / i];
    }
  }
  static _normalizePagePoint(e, t, s) {
    switch (s) {
      case 90:
        return [1 - t, e];
      case 180:
        return [1 - e, 1 - t];
      case 270:
        return [t, 1 - e];
      default:
        return [e, t];
    }
  }
  static createBezierPoints(e, t, s, i, n, r) {
    return [(e + 5 * s) / 6, (t + 5 * i) / 6, (5 * s + n) / 6, (5 * i + r) / 6, (s + n) / 2, (i + r) / 2];
  }
}
K(U, "PRECISION", 1e-4);
var Je, Ls, Uo, zo, ni, lt, ha, ca, Cc, Rc, Wo, Go, Dn, Ic, Ku, Qu, qt, ql, xb, Tb, Pb, Cb, Rb, Ib;
const Ti = class Ti {
  constructor({
    x: e,
    y: t
  }, s, i, n, r, o = 0) {
    b(this, qt);
    b(this, Je);
    b(this, Ls, []);
    b(this, Uo);
    b(this, zo);
    b(this, ni, []);
    b(this, lt, new Float32Array(18));
    b(this, ha);
    b(this, ca);
    b(this, Cc);
    b(this, Rc);
    b(this, Wo);
    b(this, Go);
    b(this, Dn, []);
    p(this, Je, s), p(this, Go, n * i), p(this, zo, r), a(this, lt).set([NaN, NaN, NaN, NaN, e, t], 6), p(this, Uo, o), p(this, Rc, a(Ti, Ic) * i), p(this, Cc, a(Ti, Qu) * i), p(this, Wo, i), a(this, Dn).push(e, t);
  }
  isEmpty() {
    return isNaN(a(this, lt)[8]);
  }
  add({
    x: e,
    y: t
  }) {
    var x;
    p(this, ha, e), p(this, ca, t);
    const [s, i, n, r] = a(this, Je);
    let [o, l, c, d] = a(this, lt).subarray(8, 12);
    const u = e - c, f = t - d, g = Math.hypot(u, f);
    if (g < a(this, Cc))
      return !1;
    const m = g - a(this, Rc), y = m / g, w = y * u, A = y * f;
    let E = o, S = l;
    o = c, l = d, c += w, d += A, (x = a(this, Dn)) == null || x.push(e, t);
    const T = -A / m, P = w / m, C = T * a(this, Go), R = P * a(this, Go);
    return a(this, lt).set(a(this, lt).subarray(2, 8), 0), a(this, lt).set([c + C, d + R], 4), a(this, lt).set(a(this, lt).subarray(14, 18), 12), a(this, lt).set([c - C, d - R], 16), isNaN(a(this, lt)[6]) ? (a(this, ni).length === 0 && (a(this, lt).set([o + C, l + R], 2), a(this, ni).push(NaN, NaN, NaN, NaN, (o + C - s) / n, (l + R - i) / r), a(this, lt).set([o - C, l - R], 14), a(this, Ls).push(NaN, NaN, NaN, NaN, (o - C - s) / n, (l - R - i) / r)), a(this, lt).set([E, S, o, l, c, d], 6), !this.isEmpty()) : (a(this, lt).set([E, S, o, l, c, d], 6), Math.abs(Math.atan2(S - l, E - o) - Math.atan2(A, w)) < Math.PI / 2 ? ([o, l, c, d] = a(this, lt).subarray(2, 6), a(this, ni).push(NaN, NaN, NaN, NaN, ((o + c) / 2 - s) / n, ((l + d) / 2 - i) / r), [o, l, E, S] = a(this, lt).subarray(14, 18), a(this, Ls).push(NaN, NaN, NaN, NaN, ((E + o) / 2 - s) / n, ((S + l) / 2 - i) / r), !0) : ([E, S, o, l, c, d] = a(this, lt).subarray(0, 6), a(this, ni).push(((E + 5 * o) / 6 - s) / n, ((S + 5 * l) / 6 - i) / r, ((5 * o + c) / 6 - s) / n, ((5 * l + d) / 6 - i) / r, ((o + c) / 2 - s) / n, ((l + d) / 2 - i) / r), [c, d, o, l, E, S] = a(this, lt).subarray(12, 18), a(this, Ls).push(((E + 5 * o) / 6 - s) / n, ((S + 5 * l) / 6 - i) / r, ((5 * o + c) / 6 - s) / n, ((5 * l + d) / 6 - i) / r, ((o + c) / 2 - s) / n, ((l + d) / 2 - i) / r), !0));
  }
  toSVGPath() {
    if (this.isEmpty())
      return "";
    const e = a(this, ni), t = a(this, Ls);
    if (isNaN(a(this, lt)[6]) && !this.isEmpty())
      return v(this, qt, xb).call(this);
    const s = [];
    s.push(`M${e[4]} ${e[5]}`);
    for (let i = 6; i < e.length; i += 6)
      isNaN(e[i]) ? s.push(`L${e[i + 4]} ${e[i + 5]}`) : s.push(`C${e[i]} ${e[i + 1]} ${e[i + 2]} ${e[i + 3]} ${e[i + 4]} ${e[i + 5]}`);
    v(this, qt, Pb).call(this, s);
    for (let i = t.length - 6; i >= 6; i -= 6)
      isNaN(t[i]) ? s.push(`L${t[i + 4]} ${t[i + 5]}`) : s.push(`C${t[i]} ${t[i + 1]} ${t[i + 2]} ${t[i + 3]} ${t[i + 4]} ${t[i + 5]}`);
    return v(this, qt, Tb).call(this, s), s.join(" ");
  }
  newFreeDrawOutline(e, t, s, i, n, r) {
    return new _b(e, t, s, i, n, r);
  }
  getOutlines() {
    var u;
    const e = a(this, ni), t = a(this, Ls), s = a(this, lt), [i, n, r, o] = a(this, Je), l = new Float32Array((((u = a(this, Dn)) == null ? void 0 : u.length) ?? 0) + 2);
    for (let f = 0, g = l.length - 2; f < g; f += 2)
      l[f] = (a(this, Dn)[f] - i) / r, l[f + 1] = (a(this, Dn)[f + 1] - n) / o;
    if (l[l.length - 2] = (a(this, ha) - i) / r, l[l.length - 1] = (a(this, ca) - n) / o, isNaN(s[6]) && !this.isEmpty())
      return v(this, qt, Cb).call(this, l);
    const c = new Float32Array(a(this, ni).length + 24 + a(this, Ls).length);
    let d = e.length;
    for (let f = 0; f < d; f += 2) {
      if (isNaN(e[f])) {
        c[f] = c[f + 1] = NaN;
        continue;
      }
      c[f] = e[f], c[f + 1] = e[f + 1];
    }
    d = v(this, qt, Ib).call(this, c, d);
    for (let f = t.length - 6; f >= 6; f -= 6)
      for (let g = 0; g < 6; g += 2) {
        if (isNaN(t[f + g])) {
          c[d] = c[d + 1] = NaN, d += 2;
          continue;
        }
        c[d] = t[f + g], c[d + 1] = t[f + g + 1], d += 2;
      }
    return v(this, qt, Rb).call(this, c, d), this.newFreeDrawOutline(c, l, a(this, Je), a(this, Wo), a(this, Uo), a(this, zo));
  }
};
Je = new WeakMap(), Ls = new WeakMap(), Uo = new WeakMap(), zo = new WeakMap(), ni = new WeakMap(), lt = new WeakMap(), ha = new WeakMap(), ca = new WeakMap(), Cc = new WeakMap(), Rc = new WeakMap(), Wo = new WeakMap(), Go = new WeakMap(), Dn = new WeakMap(), Ic = new WeakMap(), Ku = new WeakMap(), Qu = new WeakMap(), qt = new WeakSet(), ql = function() {
  const e = a(this, lt).subarray(4, 6), t = a(this, lt).subarray(16, 18), [s, i, n, r] = a(this, Je);
  return [(a(this, ha) + (e[0] - t[0]) / 2 - s) / n, (a(this, ca) + (e[1] - t[1]) / 2 - i) / r, (a(this, ha) + (t[0] - e[0]) / 2 - s) / n, (a(this, ca) + (t[1] - e[1]) / 2 - i) / r];
}, xb = function() {
  const [e, t, s, i] = a(this, Je), [n, r, o, l] = v(this, qt, ql).call(this);
  return `M${(a(this, lt)[2] - e) / s} ${(a(this, lt)[3] - t) / i} L${(a(this, lt)[4] - e) / s} ${(a(this, lt)[5] - t) / i} L${n} ${r} L${o} ${l} L${(a(this, lt)[16] - e) / s} ${(a(this, lt)[17] - t) / i} L${(a(this, lt)[14] - e) / s} ${(a(this, lt)[15] - t) / i} Z`;
}, Tb = function(e) {
  const t = a(this, Ls);
  e.push(`L${t[4]} ${t[5]} Z`);
}, Pb = function(e) {
  const [t, s, i, n] = a(this, Je), r = a(this, lt).subarray(4, 6), o = a(this, lt).subarray(16, 18), [l, c, d, u] = v(this, qt, ql).call(this);
  e.push(`L${(r[0] - t) / i} ${(r[1] - s) / n} L${l} ${c} L${d} ${u} L${(o[0] - t) / i} ${(o[1] - s) / n}`);
}, Cb = function(e) {
  const t = a(this, lt), [s, i, n, r] = a(this, Je), [o, l, c, d] = v(this, qt, ql).call(this), u = new Float32Array(36);
  return u.set([NaN, NaN, NaN, NaN, (t[2] - s) / n, (t[3] - i) / r, NaN, NaN, NaN, NaN, (t[4] - s) / n, (t[5] - i) / r, NaN, NaN, NaN, NaN, o, l, NaN, NaN, NaN, NaN, c, d, NaN, NaN, NaN, NaN, (t[16] - s) / n, (t[17] - i) / r, NaN, NaN, NaN, NaN, (t[14] - s) / n, (t[15] - i) / r], 0), this.newFreeDrawOutline(u, e, a(this, Je), a(this, Wo), a(this, Uo), a(this, zo));
}, Rb = function(e, t) {
  const s = a(this, Ls);
  return e.set([NaN, NaN, NaN, NaN, s[4], s[5]], t), t += 6;
}, Ib = function(e, t) {
  const s = a(this, lt).subarray(4, 6), i = a(this, lt).subarray(16, 18), [n, r, o, l] = a(this, Je), [c, d, u, f] = v(this, qt, ql).call(this);
  return e.set([NaN, NaN, NaN, NaN, (s[0] - n) / o, (s[1] - r) / l, NaN, NaN, NaN, NaN, c, d, NaN, NaN, NaN, NaN, u, f, NaN, NaN, NaN, NaN, (i[0] - n) / o, (i[1] - r) / l], t), t += 24;
}, b(Ti, Ic, 8), b(Ti, Ku, 2), b(Ti, Qu, a(Ti, Ic) + a(Ti, Ku));
let Ru = Ti;
var Xo, da, Wi, _c, qe, Lc, Vt, Zu, Lb;
class _b extends U {
  constructor(t, s, i, n, r, o) {
    super();
    b(this, Zu);
    b(this, Xo);
    b(this, da, new Float32Array(4));
    b(this, Wi);
    b(this, _c);
    b(this, qe);
    b(this, Lc);
    b(this, Vt);
    p(this, Vt, t), p(this, qe, s), p(this, Xo, i), p(this, Lc, n), p(this, Wi, r), p(this, _c, o), this.lastPoint = [NaN, NaN], v(this, Zu, Lb).call(this, o);
    const [l, c, d, u] = a(this, da);
    for (let f = 0, g = t.length; f < g; f += 2)
      t[f] = (t[f] - l) / d, t[f + 1] = (t[f + 1] - c) / u;
    for (let f = 0, g = s.length; f < g; f += 2)
      s[f] = (s[f] - l) / d, s[f + 1] = (s[f + 1] - c) / u;
  }
  toSVGPath() {
    const t = [`M${a(this, Vt)[4]} ${a(this, Vt)[5]}`];
    for (let s = 6, i = a(this, Vt).length; s < i; s += 6) {
      if (isNaN(a(this, Vt)[s])) {
        t.push(`L${a(this, Vt)[s + 4]} ${a(this, Vt)[s + 5]}`);
        continue;
      }
      t.push(`C${a(this, Vt)[s]} ${a(this, Vt)[s + 1]} ${a(this, Vt)[s + 2]} ${a(this, Vt)[s + 3]} ${a(this, Vt)[s + 4]} ${a(this, Vt)[s + 5]}`);
    }
    return t.push("Z"), t.join(" ");
  }
  serialize([t, s, i, n], r) {
    const o = i - t, l = n - s;
    let c, d;
    switch (r) {
      case 0:
        c = U._rescale(a(this, Vt), t, n, o, -l), d = U._rescale(a(this, qe), t, n, o, -l);
        break;
      case 90:
        c = U._rescaleAndSwap(a(this, Vt), t, s, o, l), d = U._rescaleAndSwap(a(this, qe), t, s, o, l);
        break;
      case 180:
        c = U._rescale(a(this, Vt), i, s, -o, l), d = U._rescale(a(this, qe), i, s, -o, l);
        break;
      case 270:
        c = U._rescaleAndSwap(a(this, Vt), i, n, -o, -l), d = U._rescaleAndSwap(a(this, qe), i, n, -o, -l);
        break;
    }
    return {
      outline: Array.from(c),
      points: [Array.from(d)]
    };
  }
  get box() {
    return a(this, da);
  }
  newOutliner(t, s, i, n, r, o = 0) {
    return new Ru(t, s, i, n, r, o);
  }
  getNewOutline(t, s) {
    const [i, n, r, o] = a(this, da), [l, c, d, u] = a(this, Xo), f = r * d, g = o * u, m = i * d + l, y = n * u + c, w = this.newOutliner({
      x: a(this, qe)[0] * f + m,
      y: a(this, qe)[1] * g + y
    }, a(this, Xo), a(this, Lc), t, a(this, _c), s ?? a(this, Wi));
    for (let A = 2; A < a(this, qe).length; A += 2)
      w.add({
        x: a(this, qe)[A] * f + m,
        y: a(this, qe)[A + 1] * g + y
      });
    return w.getOutlines();
  }
}
Xo = new WeakMap(), da = new WeakMap(), Wi = new WeakMap(), _c = new WeakMap(), qe = new WeakMap(), Lc = new WeakMap(), Vt = new WeakMap(), Zu = new WeakSet(), Lb = function(t) {
  const s = a(this, Vt);
  let i = s[4], n = s[5], r = i, o = n, l = i, c = n, d = i, u = n;
  const f = t ? Math.max : Math.min;
  for (let m = 6, y = s.length; m < y; m += 6) {
    if (isNaN(s[m]))
      r = Math.min(r, s[m + 4]), o = Math.min(o, s[m + 5]), l = Math.max(l, s[m + 4]), c = Math.max(c, s[m + 5]), u < s[m + 5] ? (d = s[m + 4], u = s[m + 5]) : u === s[m + 5] && (d = f(d, s[m + 4]));
    else {
      const w = X.bezierBoundingBox(i, n, ...s.slice(m, m + 6));
      r = Math.min(r, w[0]), o = Math.min(o, w[1]), l = Math.max(l, w[2]), c = Math.max(c, w[3]), u < w[3] ? (d = w[2], u = w[3]) : u === w[3] && (d = f(d, w[2]));
    }
    i = s[m + 4], n = s[m + 5];
  }
  const g = a(this, da);
  g[0] = r - a(this, Wi), g[1] = o - a(this, Wi), g[2] = l - r + 2 * a(this, Wi), g[3] = c - o + 2 * a(this, Wi), this.lastPoint = [d, u];
};
var Mc, Oc, kn, Ms, De, Mb, ru, Ob, Nb, Rp;
class Cp {
  constructor(e, t = 0, s = 0, i = !0) {
    b(this, De);
    b(this, Mc);
    b(this, Oc);
    b(this, kn, []);
    b(this, Ms, []);
    let n = 1 / 0, r = -1 / 0, o = 1 / 0, l = -1 / 0;
    const d = 10 ** -4;
    for (const {
      x: A,
      y: E,
      width: S,
      height: T
    } of e) {
      const P = Math.floor((A - t) / d) * d, C = Math.ceil((A + S + t) / d) * d, R = Math.floor((E - t) / d) * d, _ = Math.ceil((E + T + t) / d) * d, x = [P, R, _, !0], I = [C, R, _, !1];
      a(this, kn).push(x, I), n = Math.min(n, P), r = Math.max(r, C), o = Math.min(o, R), l = Math.max(l, _);
    }
    const u = r - n + 2 * s, f = l - o + 2 * s, g = n - s, m = o - s, y = a(this, kn).at(i ? -1 : -2), w = [y[0], y[2]];
    for (const A of a(this, kn)) {
      const [E, S, T] = A;
      A[0] = (E - g) / u, A[1] = (S - m) / f, A[2] = (T - m) / f;
    }
    p(this, Mc, new Float32Array([g, m, u, f])), p(this, Oc, w);
  }
  getOutlines() {
    a(this, kn).sort((t, s) => t[0] - s[0] || t[1] - s[1] || t[2] - s[2]);
    const e = [];
    for (const t of a(this, kn))
      t[3] ? (e.push(...v(this, De, Rp).call(this, t)), v(this, De, Ob).call(this, t)) : (v(this, De, Nb).call(this, t), e.push(...v(this, De, Rp).call(this, t)));
    return v(this, De, Mb).call(this, e);
  }
}
Mc = new WeakMap(), Oc = new WeakMap(), kn = new WeakMap(), Ms = new WeakMap(), De = new WeakSet(), Mb = function(e) {
  const t = [], s = /* @__PURE__ */ new Set();
  for (const r of e) {
    const [o, l, c] = r;
    t.push([o, l, r], [o, c, r]);
  }
  t.sort((r, o) => r[1] - o[1] || r[0] - o[0]);
  for (let r = 0, o = t.length; r < o; r += 2) {
    const l = t[r][2], c = t[r + 1][2];
    l.push(c), c.push(l), s.add(l), s.add(c);
  }
  const i = [];
  let n;
  for (; s.size > 0; ) {
    const r = s.values().next().value;
    let [o, l, c, d, u] = r;
    s.delete(r);
    let f = o, g = l;
    for (n = [o, c], i.push(n); ; ) {
      let m;
      if (s.has(d))
        m = d;
      else if (s.has(u))
        m = u;
      else
        break;
      s.delete(m), [o, l, c, d, u] = m, f !== o && (n.push(f, g, o, g === l ? l : c), f = o), g = g === l ? c : l;
    }
    n.push(f, g);
  }
  return new tE(i, a(this, Mc), a(this, Oc));
}, ru = function(e) {
  const t = a(this, Ms);
  let s = 0, i = t.length - 1;
  for (; s <= i; ) {
    const n = s + i >> 1, r = t[n][0];
    if (r === e)
      return n;
    r < e ? s = n + 1 : i = n - 1;
  }
  return i + 1;
}, Ob = function([, e, t]) {
  const s = v(this, De, ru).call(this, e);
  a(this, Ms).splice(s, 0, [e, t]);
}, Nb = function([, e, t]) {
  const s = v(this, De, ru).call(this, e);
  for (let i = s; i < a(this, Ms).length; i++) {
    const [n, r] = a(this, Ms)[i];
    if (n !== e)
      break;
    if (n === e && r === t) {
      a(this, Ms).splice(i, 1);
      return;
    }
  }
  for (let i = s - 1; i >= 0; i--) {
    const [n, r] = a(this, Ms)[i];
    if (n !== e)
      break;
    if (n === e && r === t) {
      a(this, Ms).splice(i, 1);
      return;
    }
  }
}, Rp = function(e) {
  const [t, s, i] = e, n = [[t, s, i]], r = v(this, De, ru).call(this, i);
  for (let o = 0; o < r; o++) {
    const [l, c] = a(this, Ms)[o];
    for (let d = 0, u = n.length; d < u; d++) {
      const [, f, g] = n[d];
      if (!(c <= f || g <= l)) {
        if (f >= l) {
          if (g > c)
            n[d][1] = c;
          else {
            if (u === 1)
              return [];
            n.splice(d, 1), d--, u--;
          }
          continue;
        }
        n[d][2] = l, g > c && n.push([t, c, g]);
      }
    }
  }
  return n;
};
var Nc, Yo;
class tE extends U {
  constructor(t, s, i) {
    super();
    b(this, Nc);
    b(this, Yo);
    p(this, Yo, t), p(this, Nc, s), this.lastPoint = i;
  }
  toSVGPath() {
    const t = [];
    for (const s of a(this, Yo)) {
      let [i, n] = s;
      t.push(`M${i} ${n}`);
      for (let r = 2; r < s.length; r += 2) {
        const o = s[r], l = s[r + 1];
        o === i ? (t.push(`V${l}`), n = l) : l === n && (t.push(`H${o}`), i = o);
      }
      t.push("Z");
    }
    return t.join(" ");
  }
  serialize([t, s, i, n], r) {
    const o = [], l = i - t, c = n - s;
    for (const d of a(this, Yo)) {
      const u = new Array(d.length);
      for (let f = 0; f < d.length; f += 2)
        u[f] = t + d[f] * l, u[f + 1] = n - d[f + 1] * c;
      o.push(u);
    }
    return o;
  }
  get box() {
    return a(this, Nc);
  }
  get classNamesForOutlining() {
    return ["highlightOutline"];
  }
}
Nc = new WeakMap(), Yo = new WeakMap();
class Ip extends Ru {
  newFreeDrawOutline(e, t, s, i, n, r) {
    return new eE(e, t, s, i, n, r);
  }
}
class eE extends _b {
  newOutliner(e, t, s, i, n, r = 0) {
    return new Ip(e, t, s, i, n, r);
  }
}
var Os, ua, Ko, Qt, Dc, Qo, kc, Fc, Fn, Ns, Zo, pe, Bc, At, _p, Lp, Mp, gr, kb, dn;
let Db = (pe = class {
  constructor({
    editor: e = null,
    uiManager: t = null
  }) {
    b(this, At);
    b(this, Os, null);
    b(this, ua, null);
    b(this, Ko);
    b(this, Qt, null);
    b(this, Dc, !1);
    b(this, Qo, !1);
    b(this, kc, null);
    b(this, Fc);
    b(this, Fn, null);
    b(this, Ns, null);
    b(this, Zo);
    var s;
    e ? (p(this, Qo, !1), p(this, Zo, ct.HIGHLIGHT_COLOR), p(this, kc, e)) : (p(this, Qo, !0), p(this, Zo, ct.HIGHLIGHT_DEFAULT_COLOR)), p(this, Ns, (e == null ? void 0 : e._uiManager) || t), p(this, Fc, a(this, Ns)._eventBus), p(this, Ko, (e == null ? void 0 : e.color) || ((s = a(this, Ns)) == null ? void 0 : s.highlightColors.values().next().value) || "#FFFF98"), a(pe, Bc) || p(pe, Bc, Object.freeze({
      blue: "pdfjs-editor-colorpicker-blue",
      green: "pdfjs-editor-colorpicker-green",
      pink: "pdfjs-editor-colorpicker-pink",
      red: "pdfjs-editor-colorpicker-red",
      yellow: "pdfjs-editor-colorpicker-yellow"
    }));
  }
  static get _keyboardManager() {
    return ht(this, "_keyboardManager", new Sd([[["Escape", "mac+Escape"], pe.prototype._hideDropdownFromKeyboard], [[" ", "mac+ "], pe.prototype._colorSelectFromKeyboard], [["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"], pe.prototype._moveToNext], [["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"], pe.prototype._moveToPrevious], [["Home", "mac+Home"], pe.prototype._moveToBeginning], [["End", "mac+End"], pe.prototype._moveToEnd]]));
  }
  renderButton() {
    const e = p(this, Os, document.createElement("button"));
    e.className = "colorPicker", e.tabIndex = "0", e.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button"), e.setAttribute("aria-haspopup", !0);
    const t = a(this, Ns)._signal;
    e.addEventListener("click", v(this, At, gr).bind(this), {
      signal: t
    }), e.addEventListener("keydown", v(this, At, Mp).bind(this), {
      signal: t
    });
    const s = p(this, ua, document.createElement("span"));
    return s.className = "swatch", s.setAttribute("aria-hidden", !0), s.style.backgroundColor = a(this, Ko), e.append(s), e;
  }
  renderMainDropdown() {
    const e = p(this, Qt, v(this, At, _p).call(this));
    return e.setAttribute("aria-orientation", "horizontal"), e.setAttribute("aria-labelledby", "highlightColorPickerLabel"), e;
  }
  _colorSelectFromKeyboard(e) {
    if (e.target === a(this, Os)) {
      v(this, At, gr).call(this, e);
      return;
    }
    const t = e.target.getAttribute("data-color");
    t && v(this, At, Lp).call(this, t, e);
  }
  _moveToNext(e) {
    var t, s;
    if (!a(this, At, dn)) {
      v(this, At, gr).call(this, e);
      return;
    }
    if (e.target === a(this, Os)) {
      (t = a(this, Qt).firstChild) == null || t.focus();
      return;
    }
    (s = e.target.nextSibling) == null || s.focus();
  }
  _moveToPrevious(e) {
    var t, s;
    if (e.target === ((t = a(this, Qt)) == null ? void 0 : t.firstChild) || e.target === a(this, Os)) {
      a(this, At, dn) && this._hideDropdownFromKeyboard();
      return;
    }
    a(this, At, dn) || v(this, At, gr).call(this, e), (s = e.target.previousSibling) == null || s.focus();
  }
  _moveToBeginning(e) {
    var t;
    if (!a(this, At, dn)) {
      v(this, At, gr).call(this, e);
      return;
    }
    (t = a(this, Qt).firstChild) == null || t.focus();
  }
  _moveToEnd(e) {
    var t;
    if (!a(this, At, dn)) {
      v(this, At, gr).call(this, e);
      return;
    }
    (t = a(this, Qt).lastChild) == null || t.focus();
  }
  hideDropdown() {
    var e, t;
    (e = a(this, Qt)) == null || e.classList.add("hidden"), (t = a(this, Fn)) == null || t.abort(), p(this, Fn, null);
  }
  _hideDropdownFromKeyboard() {
    var e;
    if (!a(this, Qo)) {
      if (!a(this, At, dn)) {
        (e = a(this, kc)) == null || e.unselect();
        return;
      }
      this.hideDropdown(), a(this, Os).focus({
        preventScroll: !0,
        focusVisible: a(this, Dc)
      });
    }
  }
  updateColor(e) {
    if (a(this, ua) && (a(this, ua).style.backgroundColor = e), !a(this, Qt))
      return;
    const t = a(this, Ns).highlightColors.values();
    for (const s of a(this, Qt).children)
      s.setAttribute("aria-selected", t.next().value === e);
  }
  destroy() {
    var e, t;
    (e = a(this, Os)) == null || e.remove(), p(this, Os, null), p(this, ua, null), (t = a(this, Qt)) == null || t.remove(), p(this, Qt, null);
  }
}, Os = new WeakMap(), ua = new WeakMap(), Ko = new WeakMap(), Qt = new WeakMap(), Dc = new WeakMap(), Qo = new WeakMap(), kc = new WeakMap(), Fc = new WeakMap(), Fn = new WeakMap(), Ns = new WeakMap(), Zo = new WeakMap(), Bc = new WeakMap(), At = new WeakSet(), _p = function() {
  const e = document.createElement("div"), t = a(this, Ns)._signal;
  e.addEventListener("contextmenu", js, {
    signal: t
  }), e.className = "dropdown", e.role = "listbox", e.setAttribute("aria-multiselectable", !1), e.setAttribute("aria-orientation", "vertical"), e.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown");
  for (const [s, i] of a(this, Ns).highlightColors) {
    const n = document.createElement("button");
    n.tabIndex = "0", n.role = "option", n.setAttribute("data-color", i), n.title = s, n.setAttribute("data-l10n-id", a(pe, Bc)[s]);
    const r = document.createElement("span");
    n.append(r), r.className = "swatch", r.style.backgroundColor = i, n.setAttribute("aria-selected", i === a(this, Ko)), n.addEventListener("click", v(this, At, Lp).bind(this, i), {
      signal: t
    }), e.append(n);
  }
  return e.addEventListener("keydown", v(this, At, Mp).bind(this), {
    signal: t
  }), e;
}, Lp = function(e, t) {
  t.stopPropagation(), a(this, Fc).dispatch("switchannotationeditorparams", {
    source: this,
    type: a(this, Zo),
    value: e
  });
}, Mp = function(e) {
  pe._keyboardManager.exec(this, e);
}, gr = function(e) {
  if (a(this, At, dn)) {
    this.hideDropdown();
    return;
  }
  if (p(this, Dc, e.detail === 0), a(this, Fn) || (p(this, Fn, new AbortController()), window.addEventListener("pointerdown", v(this, At, kb).bind(this), {
    signal: a(this, Ns).combinedSignal(a(this, Fn))
  })), a(this, Qt)) {
    a(this, Qt).classList.remove("hidden");
    return;
  }
  const t = p(this, Qt, v(this, At, _p).call(this));
  a(this, Os).append(t);
}, kb = function(e) {
  var t;
  (t = a(this, Qt)) != null && t.contains(e.target) || this.hideDropdown();
}, dn = function() {
  return a(this, Qt) && !a(this, Qt).classList.contains("hidden");
}, b(pe, Bc, null), pe);
var Jo, jc, Gi, fa, qo, He, Hc, $c, pa, ps, ts, de, tl, Xi, we, el, gs, Vc, nt, Op, au, Fb, Bb, jb, Np, mr, ws, Ja, Hb, ou, th, $b, Vb, Ub, zb, Wb;
const mt = class mt extends Ot {
  constructor(t) {
    super({
      ...t,
      name: "highlightEditor"
    });
    b(this, nt);
    b(this, Jo, null);
    b(this, jc, 0);
    b(this, Gi);
    b(this, fa, null);
    b(this, qo, null);
    b(this, He, null);
    b(this, Hc, null);
    b(this, $c, 0);
    b(this, pa, null);
    b(this, ps, null);
    b(this, ts, null);
    b(this, de, !1);
    b(this, tl, null);
    b(this, Xi);
    b(this, we, null);
    b(this, el, "");
    b(this, gs);
    b(this, Vc, "");
    this.color = t.color || mt._defaultColor, p(this, gs, t.thickness || mt._defaultThickness), p(this, Xi, t.opacity || mt._defaultOpacity), p(this, Gi, t.boxes || null), p(this, Vc, t.methodOfCreation || ""), p(this, el, t.text || ""), this._isDraggable = !1, t.highlightId > -1 ? (p(this, de, !0), v(this, nt, au).call(this, t), v(this, nt, mr).call(this)) : a(this, Gi) && (p(this, Jo, t.anchorNode), p(this, jc, t.anchorOffset), p(this, Hc, t.focusNode), p(this, $c, t.focusOffset), v(this, nt, Op).call(this), v(this, nt, mr).call(this), this.rotate(this.rotation));
  }
  static get _keyboardManager() {
    const t = mt.prototype;
    return ht(this, "_keyboardManager", new Sd([[["ArrowLeft", "mac+ArrowLeft"], t._moveCaret, {
      args: [0]
    }], [["ArrowRight", "mac+ArrowRight"], t._moveCaret, {
      args: [1]
    }], [["ArrowUp", "mac+ArrowUp"], t._moveCaret, {
      args: [2]
    }], [["ArrowDown", "mac+ArrowDown"], t._moveCaret, {
      args: [3]
    }]]));
  }
  get telemetryInitialData() {
    return {
      action: "added",
      type: a(this, de) ? "free_highlight" : "highlight",
      color: this._uiManager.highlightColorNames.get(this.color),
      thickness: a(this, gs),
      methodOfCreation: a(this, Vc)
    };
  }
  get telemetryFinalData() {
    return {
      type: "highlight",
      color: this._uiManager.highlightColorNames.get(this.color)
    };
  }
  static computeTelemetryFinalData(t) {
    return {
      numberOfColors: t.get("color").size
    };
  }
  static initialize(t, s) {
    var i;
    Ot.initialize(t, s), mt._defaultColor || (mt._defaultColor = ((i = s.highlightColors) == null ? void 0 : i.values().next().value) || "#fff066");
  }
  static updateDefaultParams(t, s) {
    switch (t) {
      case ct.HIGHLIGHT_DEFAULT_COLOR:
        mt._defaultColor = s;
        break;
      case ct.HIGHLIGHT_THICKNESS:
        mt._defaultThickness = s;
        break;
    }
  }
  translateInPage(t, s) {
  }
  get toolbarPosition() {
    return a(this, tl);
  }
  updateParams(t, s) {
    switch (t) {
      case ct.HIGHLIGHT_COLOR:
        v(this, nt, Fb).call(this, s);
        break;
      case ct.HIGHLIGHT_THICKNESS:
        v(this, nt, Bb).call(this, s);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[ct.HIGHLIGHT_DEFAULT_COLOR, mt._defaultColor], [ct.HIGHLIGHT_THICKNESS, mt._defaultThickness]];
  }
  get propertiesToUpdate() {
    return [[ct.HIGHLIGHT_COLOR, this.color || mt._defaultColor], [ct.HIGHLIGHT_THICKNESS, a(this, gs) || mt._defaultThickness], [ct.HIGHLIGHT_FREE, a(this, de)]];
  }
  async addEditToolbar() {
    const t = await super.addEditToolbar();
    return t ? (this._uiManager.highlightColors && (p(this, qo, new Db({
      editor: this
    })), t.addColorPicker(a(this, qo))), t) : null;
  }
  disableEditing() {
    super.disableEditing(), this.div.classList.toggle("disabled", !0);
  }
  enableEditing() {
    super.enableEditing(), this.div.classList.toggle("disabled", !1);
  }
  fixAndSetPosition() {
    return super.fixAndSetPosition(v(this, nt, th).call(this));
  }
  getBaseTranslation() {
    return [0, 0];
  }
  getRect(t, s) {
    return super.getRect(t, s, v(this, nt, th).call(this));
  }
  onceAdded(t) {
    this.annotationElementId || this.parent.addUndoableEditor(this), t && this.div.focus();
  }
  remove() {
    v(this, nt, Np).call(this), this._reportTelemetry({
      action: "deleted"
    }), super.remove();
  }
  rebuild() {
    this.parent && (super.rebuild(), this.div !== null && (v(this, nt, mr).call(this), this.isAttachedToDOM || this.parent.add(this)));
  }
  setParent(t) {
    var i;
    let s = !1;
    this.parent && !t ? v(this, nt, Np).call(this) : t && (v(this, nt, mr).call(this, t), s = !this.parent && ((i = this.div) == null ? void 0 : i.classList.contains("selectedEditor"))), super.setParent(t), this.show(this._isVisible), s && this.select();
  }
  rotate(t) {
    var n, r, o;
    const {
      drawLayer: s
    } = this.parent;
    let i;
    a(this, de) ? (t = (t - this.rotation + 360) % 360, i = v(n = mt, ws, Ja).call(n, a(this, ps).box, t)) : i = v(r = mt, ws, Ja).call(r, [this.x, this.y, this.width, this.height], t), s.updateProperties(a(this, ts), {
      bbox: i,
      root: {
        "data-main-rotation": t
      }
    }), s.updateProperties(a(this, we), {
      bbox: v(o = mt, ws, Ja).call(o, a(this, He).box, t),
      root: {
        "data-main-rotation": t
      }
    });
  }
  render() {
    if (this.div)
      return this.div;
    const t = super.render();
    a(this, el) && (t.setAttribute("aria-label", a(this, el)), t.setAttribute("role", "mark")), a(this, de) ? t.classList.add("free") : this.div.addEventListener("keydown", v(this, nt, Hb).bind(this), {
      signal: this._uiManager._signal
    });
    const s = p(this, pa, document.createElement("div"));
    t.append(s), s.setAttribute("aria-hidden", "true"), s.className = "internal", s.style.clipPath = a(this, fa);
    const [i, n] = this.parentDimensions;
    return this.setDims(this.width * i, this.height * n), Pu(this, a(this, pa), ["pointerover", "pointerleave"]), this.enableEditing(), t;
  }
  pointerover() {
    var t;
    this.isSelected || (t = this.parent) == null || t.drawLayer.updateProperties(a(this, we), {
      rootClass: {
        hovered: !0
      }
    });
  }
  pointerleave() {
    var t;
    this.isSelected || (t = this.parent) == null || t.drawLayer.updateProperties(a(this, we), {
      rootClass: {
        hovered: !1
      }
    });
  }
  _moveCaret(t) {
    switch (this.parent.unselect(this), t) {
      case 0:
      case 2:
        v(this, nt, ou).call(this, !0);
        break;
      case 1:
      case 3:
        v(this, nt, ou).call(this, !1);
        break;
    }
  }
  select() {
    var t;
    super.select(), a(this, we) && ((t = this.parent) == null || t.drawLayer.updateProperties(a(this, we), {
      rootClass: {
        hovered: !1,
        selected: !0
      }
    }));
  }
  unselect() {
    var t;
    super.unselect(), a(this, we) && ((t = this.parent) == null || t.drawLayer.updateProperties(a(this, we), {
      rootClass: {
        selected: !1
      }
    }), a(this, de) || v(this, nt, ou).call(this, !1));
  }
  get _mustFixPosition() {
    return !a(this, de);
  }
  show(t = this._isVisible) {
    super.show(t), this.parent && (this.parent.drawLayer.updateProperties(a(this, ts), {
      rootClass: {
        hidden: !t
      }
    }), this.parent.drawLayer.updateProperties(a(this, we), {
      rootClass: {
        hidden: !t
      }
    }));
  }
  static startHighlighting(t, s, {
    target: i,
    x: n,
    y: r
  }) {
    const {
      x: o,
      y: l,
      width: c,
      height: d
    } = i.getBoundingClientRect(), u = new AbortController(), f = t.combinedSignal(u), g = (m) => {
      u.abort(), v(this, ws, zb).call(this, t, m);
    };
    window.addEventListener("blur", g, {
      signal: f
    }), window.addEventListener("pointerup", g, {
      signal: f
    }), window.addEventListener("pointerdown", os, {
      capture: !0,
      passive: !1,
      signal: f
    }), window.addEventListener("contextmenu", js, {
      signal: f
    }), i.addEventListener("pointermove", v(this, ws, Ub).bind(this, t), {
      signal: f
    }), this._freeHighlight = new Ip({
      x: n,
      y: r
    }, [o, l, c, d], t.scale, this._defaultThickness / 2, s, 1e-3), {
      id: this._freeHighlightId,
      clipPathId: this._freeHighlightClipId
    } = t.drawLayer.draw({
      bbox: [0, 0, 1, 1],
      root: {
        viewBox: "0 0 1 1",
        fill: this._defaultColor,
        "fill-opacity": this._defaultOpacity
      },
      rootClass: {
        highlight: !0,
        free: !0
      },
      path: {
        d: this._freeHighlight.toSVGPath()
      }
    }, !0, !0);
  }
  static async deserialize(t, s, i) {
    var y, w, A, E;
    let n = null;
    if (t instanceof mb) {
      const {
        data: {
          quadPoints: S,
          rect: T,
          rotation: P,
          id: C,
          color: R,
          opacity: _,
          popupRef: x
        },
        parent: {
          page: {
            pageNumber: I
          }
        }
      } = t;
      n = t = {
        annotationType: at.HIGHLIGHT,
        color: Array.from(R),
        opacity: _,
        quadPoints: S,
        boxes: null,
        pageIndex: I - 1,
        rect: T.slice(0),
        rotation: P,
        id: C,
        deleted: !1,
        popupRef: x
      };
    } else if (t instanceof Bg) {
      const {
        data: {
          inkLists: S,
          rect: T,
          rotation: P,
          id: C,
          color: R,
          borderStyle: {
            rawWidth: _
          },
          popupRef: x
        },
        parent: {
          page: {
            pageNumber: I
          }
        }
      } = t;
      n = t = {
        annotationType: at.HIGHLIGHT,
        color: Array.from(R),
        thickness: _,
        inkLists: S,
        boxes: null,
        pageIndex: I - 1,
        rect: T.slice(0),
        rotation: P,
        id: C,
        deleted: !1,
        popupRef: x
      };
    }
    const {
      color: r,
      quadPoints: o,
      inkLists: l,
      opacity: c
    } = t, d = await super.deserialize(t, s, i);
    d.color = X.makeHexColor(...r), p(d, Xi, c || 1), l && p(d, gs, t.thickness), d.annotationElementId = t.id || null, d._initialData = n;
    const [u, f] = d.pageDimensions, [g, m] = d.pageTranslation;
    if (o) {
      const S = p(d, Gi, []);
      for (let T = 0; T < o.length; T += 8)
        S.push({
          x: (o[T] - g) / u,
          y: 1 - (o[T + 1] - m) / f,
          width: (o[T + 2] - o[T]) / u,
          height: (o[T + 1] - o[T + 5]) / f
        });
      v(y = d, nt, Op).call(y), v(w = d, nt, mr).call(w), d.rotate(d.rotation);
    } else if (l) {
      p(d, de, !0);
      const S = l[0], T = {
        x: S[0] - g,
        y: f - (S[1] - m)
      }, P = new Ip(T, [0, 0, u, f], 1, a(d, gs) / 2, !0, 1e-3);
      for (let _ = 0, x = S.length; _ < x; _ += 2)
        T.x = S[_] - g, T.y = f - (S[_ + 1] - m), P.add(T);
      const {
        id: C,
        clipPathId: R
      } = s.drawLayer.draw({
        bbox: [0, 0, 1, 1],
        root: {
          viewBox: "0 0 1 1",
          fill: d.color,
          "fill-opacity": d._defaultOpacity
        },
        rootClass: {
          highlight: !0,
          free: !0
        },
        path: {
          d: P.toSVGPath()
        }
      }, !0, !0);
      v(A = d, nt, au).call(A, {
        highlightOutlines: P.getOutlines(),
        highlightId: C,
        clipPathId: R
      }), v(E = d, nt, mr).call(E);
    }
    return d;
  }
  serialize(t = !1) {
    if (this.isEmpty() || t)
      return null;
    if (this.deleted)
      return this.serializeDeleted();
    const s = this.getRect(0, 0), i = Ot._colorManager.convert(this.color), n = {
      annotationType: at.HIGHLIGHT,
      color: i,
      opacity: a(this, Xi),
      thickness: a(this, gs),
      quadPoints: v(this, nt, $b).call(this),
      outlines: v(this, nt, Vb).call(this, s),
      pageIndex: this.pageIndex,
      rect: s,
      rotation: v(this, nt, th).call(this),
      structTreeParentId: this._structTreeParentId
    };
    return this.annotationElementId && !v(this, nt, Wb).call(this, n) ? null : (n.id = this.annotationElementId, n);
  }
  renderAnnotationElement(t) {
    return t.updateEdited({
      rect: this.getRect(0, 0)
    }), null;
  }
  static canCreateNewEmptyEditor() {
    return !1;
  }
};
Jo = new WeakMap(), jc = new WeakMap(), Gi = new WeakMap(), fa = new WeakMap(), qo = new WeakMap(), He = new WeakMap(), Hc = new WeakMap(), $c = new WeakMap(), pa = new WeakMap(), ps = new WeakMap(), ts = new WeakMap(), de = new WeakMap(), tl = new WeakMap(), Xi = new WeakMap(), we = new WeakMap(), el = new WeakMap(), gs = new WeakMap(), Vc = new WeakMap(), nt = new WeakSet(), Op = function() {
  const t = new Cp(a(this, Gi), 1e-3);
  p(this, ps, t.getOutlines()), [this.x, this.y, this.width, this.height] = a(this, ps).box;
  const s = new Cp(a(this, Gi), 25e-4, 1e-3, this._uiManager.direction === "ltr");
  p(this, He, s.getOutlines());
  const {
    lastPoint: i
  } = a(this, He);
  p(this, tl, [(i[0] - this.x) / this.width, (i[1] - this.y) / this.height]);
}, au = function({
  highlightOutlines: t,
  highlightId: s,
  clipPathId: i
}) {
  var u, f;
  if (p(this, ps, t), p(this, He, t.getNewOutline(a(this, gs) / 2 + 1.5, 25e-4)), s >= 0)
    p(this, ts, s), p(this, fa, i), this.parent.drawLayer.finalizeDraw(s, {
      bbox: t.box,
      path: {
        d: t.toSVGPath()
      }
    }), p(this, we, this.parent.drawLayer.drawOutline({
      rootClass: {
        highlightOutline: !0,
        free: !0
      },
      bbox: a(this, He).box,
      path: {
        d: a(this, He).toSVGPath()
      }
    }, !0));
  else if (this.parent) {
    const g = this.parent.viewport.rotation;
    this.parent.drawLayer.updateProperties(a(this, ts), {
      bbox: v(u = mt, ws, Ja).call(u, a(this, ps).box, (g - this.rotation + 360) % 360),
      path: {
        d: t.toSVGPath()
      }
    }), this.parent.drawLayer.updateProperties(a(this, we), {
      bbox: v(f = mt, ws, Ja).call(f, a(this, He).box, g),
      path: {
        d: a(this, He).toSVGPath()
      }
    });
  }
  const [r, o, l, c] = t.box;
  switch (this.rotation) {
    case 0:
      this.x = r, this.y = o, this.width = l, this.height = c;
      break;
    case 90: {
      const [g, m] = this.parentDimensions;
      this.x = o, this.y = 1 - r, this.width = l * m / g, this.height = c * g / m;
      break;
    }
    case 180:
      this.x = 1 - r, this.y = 1 - o, this.width = l, this.height = c;
      break;
    case 270: {
      const [g, m] = this.parentDimensions;
      this.x = 1 - o, this.y = r, this.width = l * m / g, this.height = c * g / m;
      break;
    }
  }
  const {
    lastPoint: d
  } = a(this, He);
  p(this, tl, [(d[0] - r) / l, (d[1] - o) / c]);
}, Fb = function(t) {
  const s = (r, o) => {
    var l, c;
    this.color = r, p(this, Xi, o), (l = this.parent) == null || l.drawLayer.updateProperties(a(this, ts), {
      root: {
        fill: r,
        "fill-opacity": o
      }
    }), (c = a(this, qo)) == null || c.updateColor(r);
  }, i = this.color, n = a(this, Xi);
  this.addCommands({
    cmd: s.bind(this, t, mt._defaultOpacity),
    undo: s.bind(this, i, n),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: ct.HIGHLIGHT_COLOR,
    overwriteIfSameType: !0,
    keepUndo: !0
  }), this._reportTelemetry({
    action: "color_changed",
    color: this._uiManager.highlightColorNames.get(t)
  }, !0);
}, Bb = function(t) {
  const s = a(this, gs), i = (n) => {
    p(this, gs, n), v(this, nt, jb).call(this, n);
  };
  this.addCommands({
    cmd: i.bind(this, t),
    undo: i.bind(this, s),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: ct.INK_THICKNESS,
    overwriteIfSameType: !0,
    keepUndo: !0
  }), this._reportTelemetry({
    action: "thickness_changed",
    thickness: t
  }, !0);
}, jb = function(t) {
  if (!a(this, de))
    return;
  v(this, nt, au).call(this, {
    highlightOutlines: a(this, ps).getNewOutline(t / 2)
  }), this.fixAndSetPosition();
  const [s, i] = this.parentDimensions;
  this.setDims(this.width * s, this.height * i);
}, Np = function() {
  a(this, ts) === null || !this.parent || (this.parent.drawLayer.remove(a(this, ts)), p(this, ts, null), this.parent.drawLayer.remove(a(this, we)), p(this, we, null));
}, mr = function(t = this.parent) {
  a(this, ts) === null && ({
    id: me(this, ts)._,
    clipPathId: me(this, fa)._
  } = t.drawLayer.draw({
    bbox: a(this, ps).box,
    root: {
      viewBox: "0 0 1 1",
      fill: this.color,
      "fill-opacity": a(this, Xi)
    },
    rootClass: {
      highlight: !0,
      free: a(this, de)
    },
    path: {
      d: a(this, ps).toSVGPath()
    }
  }, !1, !0), p(this, we, t.drawLayer.drawOutline({
    rootClass: {
      highlightOutline: !0,
      free: a(this, de)
    },
    bbox: a(this, He).box,
    path: {
      d: a(this, He).toSVGPath()
    }
  }, a(this, de))), a(this, pa) && (a(this, pa).style.clipPath = a(this, fa)));
}, ws = new WeakSet(), Ja = function([t, s, i, n], r) {
  switch (r) {
    case 90:
      return [1 - s - n, t, n, i];
    case 180:
      return [1 - t - i, 1 - s - n, i, n];
    case 270:
      return [s, 1 - t - i, n, i];
  }
  return [t, s, i, n];
}, Hb = function(t) {
  mt._keyboardManager.exec(this, t);
}, ou = function(t) {
  if (!a(this, Jo))
    return;
  const s = window.getSelection();
  t ? s.setPosition(a(this, Jo), a(this, jc)) : s.setPosition(a(this, Hc), a(this, $c));
}, th = function() {
  return a(this, de) ? this.rotation : 0;
}, $b = function() {
  if (a(this, de))
    return null;
  const [t, s] = this.pageDimensions, [i, n] = this.pageTranslation, r = a(this, Gi), o = new Float32Array(r.length * 8);
  let l = 0;
  for (const {
    x: c,
    y: d,
    width: u,
    height: f
  } of r) {
    const g = c * t + i, m = (1 - d) * s + n;
    o[l] = o[l + 4] = g, o[l + 1] = o[l + 3] = m, o[l + 2] = o[l + 6] = g + u * t, o[l + 5] = o[l + 7] = m - f * s, l += 8;
  }
  return o;
}, Vb = function(t) {
  return a(this, ps).serialize(t, v(this, nt, th).call(this));
}, Ub = function(t, s) {
  this._freeHighlight.add(s) && t.drawLayer.updateProperties(this._freeHighlightId, {
    path: {
      d: this._freeHighlight.toSVGPath()
    }
  });
}, zb = function(t, s) {
  this._freeHighlight.isEmpty() ? t.drawLayer.remove(this._freeHighlightId) : t.createAndAddNewEditor(s, !1, {
    highlightId: this._freeHighlightId,
    highlightOutlines: this._freeHighlight.getOutlines(),
    clipPathId: this._freeHighlightClipId,
    methodOfCreation: "main_toolbar"
  }), this._freeHighlightId = -1, this._freeHighlight = null, this._freeHighlightClipId = "";
}, Wb = function(t) {
  const {
    color: s
  } = this._initialData;
  return t.color.some((i, n) => i !== s[n]);
}, b(mt, ws), K(mt, "_defaultColor", null), K(mt, "_defaultOpacity", 1), K(mt, "_defaultThickness", 12), K(mt, "_type", "highlight"), K(mt, "_editorType", at.HIGHLIGHT), K(mt, "_freeHighlightId", -1), K(mt, "_freeHighlight", null), K(mt, "_freeHighlightClipId", "");
let Iu = mt;
var ga;
class sE {
  constructor() {
    b(this, ga, /* @__PURE__ */ Object.create(null));
  }
  updateProperty(e, t) {
    this[e] = t, this.updateSVGProperty(e, t);
  }
  updateProperties(e) {
    if (e)
      for (const [t, s] of Object.entries(e))
        this.updateProperty(t, s);
  }
  updateSVGProperty(e, t) {
    a(this, ga)[e] = t;
  }
  toSVGProperties() {
    const e = a(this, ga);
    return p(this, ga, /* @__PURE__ */ Object.create(null)), {
      root: e
    };
  }
  reset() {
    p(this, ga, /* @__PURE__ */ Object.create(null));
  }
  updateAll(e = this) {
    this.updateProperties(e);
  }
  clone() {
    Pt("Not implemented");
  }
}
ga = new WeakMap();
var es, sl, ne, ma, va, Bn, jn, Hn, ba, pt, kp, Fp, Bp, eh, Gb, lu, sh, qa;
const z = class z extends Ot {
  constructor(t) {
    super(t);
    b(this, pt);
    b(this, es, null);
    b(this, sl);
    K(this, "_drawId", null);
    p(this, sl, t.mustBeCommitted || !1), t.drawOutlines && (v(this, pt, kp).call(this, t), v(this, pt, eh).call(this));
  }
  static _mergeSVGProperties(t, s) {
    const i = new Set(Object.keys(t));
    for (const [n, r] of Object.entries(s))
      i.has(n) ? Object.assign(t[n], r) : t[n] = r;
    return t;
  }
  static getDefaultDrawingOptions(t) {
    Pt("Not implemented");
  }
  static get typesMap() {
    Pt("Not implemented");
  }
  static get isDrawer() {
    return !0;
  }
  static get supportMultipleDrawings() {
    return !1;
  }
  static updateDefaultParams(t, s) {
    const i = this.typesMap.get(t);
    i && this._defaultDrawingOptions.updateProperty(i, s), this._currentParent && (a(z, ne).updateProperty(i, s), this._currentParent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties()));
  }
  updateParams(t, s) {
    const i = this.constructor.typesMap.get(t);
    i && this._updateProperty(t, i, s);
  }
  static get defaultPropertiesToUpdate() {
    const t = [], s = this._defaultDrawingOptions;
    for (const [i, n] of this.typesMap)
      t.push([i, s[n]]);
    return t;
  }
  get propertiesToUpdate() {
    const t = [], {
      _drawingOptions: s
    } = this;
    for (const [i, n] of this.constructor.typesMap)
      t.push([i, s[n]]);
    return t;
  }
  _updateProperty(t, s, i) {
    const n = this._drawingOptions, r = n[s], o = (l) => {
      var d;
      n.updateProperty(s, l);
      const c = a(this, es).updateProperty(s, l);
      c && v(this, pt, sh).call(this, c), (d = this.parent) == null || d.drawLayer.updateProperties(this._drawId, n.toSVGProperties());
    };
    this.addCommands({
      cmd: o.bind(this, i),
      undo: o.bind(this, r),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: !0,
      type: t,
      overwriteIfSameType: !0,
      keepUndo: !0
    });
  }
  _onResizing() {
    var t;
    (t = this.parent) == null || t.drawLayer.updateProperties(this._drawId, z._mergeSVGProperties(a(this, es).getPathResizingSVGProperties(v(this, pt, lu).call(this)), {
      bbox: v(this, pt, qa).call(this)
    }));
  }
  _onResized() {
    var t;
    (t = this.parent) == null || t.drawLayer.updateProperties(this._drawId, z._mergeSVGProperties(a(this, es).getPathResizedSVGProperties(v(this, pt, lu).call(this)), {
      bbox: v(this, pt, qa).call(this)
    }));
  }
  _onTranslating(t, s) {
    var i;
    (i = this.parent) == null || i.drawLayer.updateProperties(this._drawId, {
      bbox: v(this, pt, qa).call(this, t, s)
    });
  }
  _onTranslated() {
    var t;
    (t = this.parent) == null || t.drawLayer.updateProperties(this._drawId, z._mergeSVGProperties(a(this, es).getPathTranslatedSVGProperties(v(this, pt, lu).call(this), this.parentDimensions), {
      bbox: v(this, pt, qa).call(this)
    }));
  }
  _onStartDragging() {
    var t;
    (t = this.parent) == null || t.drawLayer.updateProperties(this._drawId, {
      rootClass: {
        moving: !0
      }
    });
  }
  _onStopDragging() {
    var t;
    (t = this.parent) == null || t.drawLayer.updateProperties(this._drawId, {
      rootClass: {
        moving: !1
      }
    });
  }
  commit() {
    super.commit(), this.disableEditMode(), this.disableEditing();
  }
  disableEditing() {
    super.disableEditing(), this.div.classList.toggle("disabled", !0);
  }
  enableEditing() {
    super.enableEditing(), this.div.classList.toggle("disabled", !1);
  }
  getBaseTranslation() {
    return [0, 0];
  }
  get isResizable() {
    return !0;
  }
  onceAdded(t) {
    this.annotationElementId || this.parent.addUndoableEditor(this), this._isDraggable = !0, a(this, sl) && (p(this, sl, !1), this.commit(), this.parent.setSelected(this), t && this.isOnScreen && this.div.focus());
  }
  remove() {
    v(this, pt, Bp).call(this), super.remove();
  }
  rebuild() {
    this.parent && (super.rebuild(), this.div !== null && (v(this, pt, eh).call(this), v(this, pt, sh).call(this, a(this, es).box), this.isAttachedToDOM || this.parent.add(this)));
  }
  setParent(t) {
    var i;
    let s = !1;
    this.parent && !t ? (this._uiManager.removeShouldRescale(this), v(this, pt, Bp).call(this)) : t && (this._uiManager.addShouldRescale(this), v(this, pt, eh).call(this, t), s = !this.parent && ((i = this.div) == null ? void 0 : i.classList.contains("selectedEditor"))), super.setParent(t), s && this.select();
  }
  rotate() {
    this.parent && this.parent.drawLayer.updateProperties(this._drawId, z._mergeSVGProperties({
      bbox: v(this, pt, qa).call(this)
    }, a(this, es).updateRotation((this.parentRotation - this.rotation + 360) % 360)));
  }
  onScaleChanging() {
    this.parent && v(this, pt, sh).call(this, a(this, es).updateParentDimensions(this.parentDimensions, this.parent.scale));
  }
  static onScaleChangingWhenDrawing() {
  }
  render() {
    if (this.div)
      return this.div;
    const t = super.render();
    t.classList.add("draw");
    const s = document.createElement("div");
    t.append(s), s.setAttribute("aria-hidden", "true"), s.className = "internal";
    const [i, n] = this.parentDimensions;
    return this.setDims(this.width * i, this.height * n), this._uiManager.addShouldRescale(this), this.disableEditing(), t;
  }
  static createDrawerInstance(t, s, i, n, r) {
    Pt("Not implemented");
  }
  static startDrawing(t, s, i, n) {
    var w;
    const {
      target: r,
      offsetX: o,
      offsetY: l,
      pointerId: c,
      pointerType: d
    } = n;
    if (a(z, jn) && a(z, jn) !== d)
      return;
    const {
      viewport: {
        rotation: u
      }
    } = t, {
      width: f,
      height: g
    } = r.getBoundingClientRect(), m = p(z, ma, new AbortController()), y = t.combinedSignal(m);
    if (a(z, Bn) || p(z, Bn, c), a(z, jn) ?? p(z, jn, d), window.addEventListener("pointerup", (A) => {
      var E;
      a(z, Bn) === A.pointerId ? this._endDraw(A) : (E = a(z, Hn)) == null || E.delete(A.pointerId);
    }, {
      signal: y
    }), window.addEventListener("pointercancel", (A) => {
      var E;
      a(z, Bn) === A.pointerId ? this._currentParent.endDrawingSession() : (E = a(z, Hn)) == null || E.delete(A.pointerId);
    }, {
      signal: y
    }), window.addEventListener("pointerdown", (A) => {
      a(z, jn) === A.pointerType && ((a(z, Hn) || p(z, Hn, /* @__PURE__ */ new Set())).add(A.pointerId), a(z, ne).isCancellable() && (a(z, ne).removeLastElement(), a(z, ne).isEmpty() ? this._currentParent.endDrawingSession(!0) : this._endDraw(null)));
    }, {
      capture: !0,
      passive: !1,
      signal: y
    }), window.addEventListener("contextmenu", js, {
      signal: y
    }), r.addEventListener("pointermove", this._drawMove.bind(this), {
      signal: y
    }), r.addEventListener("touchmove", (A) => {
      A.timeStamp === a(z, ba) && os(A);
    }, {
      signal: y
    }), t.toggleDrawing(), (w = s._editorUndoBar) == null || w.hide(), a(z, ne)) {
      t.drawLayer.updateProperties(this._currentDrawId, a(z, ne).startNew(o, l, f, g, u));
      return;
    }
    s.updateUIForDefaultProperties(this), p(z, ne, this.createDrawerInstance(o, l, f, g, u)), p(z, va, this.getDefaultDrawingOptions()), this._currentParent = t, {
      id: this._currentDrawId
    } = t.drawLayer.draw(this._mergeSVGProperties(a(z, va).toSVGProperties(), a(z, ne).defaultSVGProperties), !0, !1);
  }
  static _drawMove(t) {
    var r;
    if (p(z, ba, -1), !a(z, ne))
      return;
    const {
      offsetX: s,
      offsetY: i,
      pointerId: n
    } = t;
    if (a(z, Bn) === n) {
      if (((r = a(z, Hn)) == null ? void 0 : r.size) >= 1) {
        this._endDraw(t);
        return;
      }
      this._currentParent.drawLayer.updateProperties(this._currentDrawId, a(z, ne).add(s, i)), p(z, ba, t.timeStamp), os(t);
    }
  }
  static _cleanup(t) {
    t && (this._currentDrawId = -1, this._currentParent = null, p(z, ne, null), p(z, va, null), p(z, jn, null), p(z, ba, NaN)), a(z, ma) && (a(z, ma).abort(), p(z, ma, null), p(z, Bn, NaN), p(z, Hn, null));
  }
  static _endDraw(t) {
    const s = this._currentParent;
    if (s) {
      if (s.toggleDrawing(!0), this._cleanup(!1), t && s.drawLayer.updateProperties(this._currentDrawId, a(z, ne).end(t.offsetX, t.offsetY)), this.supportMultipleDrawings) {
        const i = a(z, ne), n = this._currentDrawId, r = i.getLastElement();
        s.addCommands({
          cmd: () => {
            s.drawLayer.updateProperties(n, i.setLastElement(r));
          },
          undo: () => {
            s.drawLayer.updateProperties(n, i.removeLastElement());
          },
          mustExec: !1,
          type: ct.DRAW_STEP
        });
        return;
      }
      this.endDrawing(!1);
    }
  }
  static endDrawing(t) {
    const s = this._currentParent;
    if (!s)
      return null;
    if (s.toggleDrawing(!0), s.cleanUndoStack(ct.DRAW_STEP), !a(z, ne).isEmpty()) {
      const {
        pageDimensions: [i, n],
        scale: r
      } = s, o = s.createAndAddNewEditor({
        offsetX: 0,
        offsetY: 0
      }, !1, {
        drawId: this._currentDrawId,
        drawOutlines: a(z, ne).getOutlines(i * r, n * r, r, this._INNER_MARGIN),
        drawingOptions: a(z, va),
        mustBeCommitted: !t
      });
      return this._cleanup(!0), o;
    }
    return s.drawLayer.remove(this._currentDrawId), this._cleanup(!0), null;
  }
  createDrawingOptions(t) {
  }
  static deserializeDraw(t, s, i, n, r, o) {
    Pt("Not implemented");
  }
  static async deserialize(t, s, i) {
    var u, f;
    const {
      rawDims: {
        pageWidth: n,
        pageHeight: r,
        pageX: o,
        pageY: l
      }
    } = s.viewport, c = this.deserializeDraw(o, l, n, r, this._INNER_MARGIN, t), d = await super.deserialize(t, s, i);
    return d.createDrawingOptions(t), v(u = d, pt, kp).call(u, {
      drawOutlines: c
    }), v(f = d, pt, eh).call(f), d.onScaleChanging(), d.rotate(), d;
  }
  serializeDraw(t) {
    const [s, i] = this.pageTranslation, [n, r] = this.pageDimensions;
    return a(this, es).serialize([s, i, n, r], t);
  }
  renderAnnotationElement(t) {
    return t.updateEdited({
      rect: this.getRect(0, 0)
    }), null;
  }
  static canCreateNewEmptyEditor() {
    return !1;
  }
};
es = new WeakMap(), sl = new WeakMap(), ne = new WeakMap(), ma = new WeakMap(), va = new WeakMap(), Bn = new WeakMap(), jn = new WeakMap(), Hn = new WeakMap(), ba = new WeakMap(), pt = new WeakSet(), kp = function({
  drawOutlines: t,
  drawId: s,
  drawingOptions: i
}) {
  p(this, es, t), this._drawingOptions || (this._drawingOptions = i), s >= 0 ? (this._drawId = s, this.parent.drawLayer.finalizeDraw(s, t.defaultProperties)) : this._drawId = v(this, pt, Fp).call(this, t, this.parent), v(this, pt, sh).call(this, t.box);
}, Fp = function(t, s) {
  const {
    id: i
  } = s.drawLayer.draw(z._mergeSVGProperties(this._drawingOptions.toSVGProperties(), t.defaultSVGProperties), !1, !1);
  return i;
}, Bp = function() {
  this._drawId === null || !this.parent || (this.parent.drawLayer.remove(this._drawId), this._drawId = null, this._drawingOptions.reset());
}, eh = function(t = this.parent) {
  if (!(this._drawId !== null && this.parent === t)) {
    if (this._drawId !== null) {
      this.parent.drawLayer.updateParent(this._drawId, t.drawLayer);
      return;
    }
    this._drawingOptions.updateAll(), this._drawId = v(this, pt, Fp).call(this, a(this, es), t);
  }
}, Gb = function([t, s, i, n]) {
  const {
    parentDimensions: [r, o],
    rotation: l
  } = this;
  switch (l) {
    case 90:
      return [s, 1 - t, i * (o / r), n * (r / o)];
    case 180:
      return [1 - t, 1 - s, i, n];
    case 270:
      return [1 - s, t, i * (o / r), n * (r / o)];
    default:
      return [t, s, i, n];
  }
}, lu = function() {
  const {
    x: t,
    y: s,
    width: i,
    height: n,
    parentDimensions: [r, o],
    rotation: l
  } = this;
  switch (l) {
    case 90:
      return [1 - s, t, i * (r / o), n * (o / r)];
    case 180:
      return [1 - t, 1 - s, i, n];
    case 270:
      return [s, 1 - t, i * (r / o), n * (o / r)];
    default:
      return [t, s, i, n];
  }
}, sh = function(t) {
  if ([this.x, this.y, this.width, this.height] = v(this, pt, Gb).call(this, t), this.div) {
    this.fixAndSetPosition();
    const [s, i] = this.parentDimensions;
    this.setDims(this.width * s, this.height * i);
  }
  this._onResized();
}, qa = function() {
  const {
    x: t,
    y: s,
    width: i,
    height: n,
    rotation: r,
    parentRotation: o,
    parentDimensions: [l, c]
  } = this;
  switch ((r * 4 + o) / 90) {
    case 1:
      return [1 - s - n, t, n, i];
    case 2:
      return [1 - t - i, 1 - s - n, i, n];
    case 3:
      return [s, 1 - t - i, n, i];
    case 4:
      return [t, s - i * (l / c), n * (c / l), i * (l / c)];
    case 5:
      return [1 - s, t, i * (l / c), n * (c / l)];
    case 6:
      return [1 - t - n * (c / l), 1 - s, n * (c / l), i * (l / c)];
    case 7:
      return [s - i * (l / c), 1 - t - n * (c / l), i * (l / c), n * (c / l)];
    case 8:
      return [t - i, s - n, i, n];
    case 9:
      return [1 - s, t - i, n, i];
    case 10:
      return [1 - t, 1 - s, i, n];
    case 11:
      return [s - n, 1 - t, n, i];
    case 12:
      return [t - n * (c / l), s, n * (c / l), i * (l / c)];
    case 13:
      return [1 - s - i * (l / c), t - n * (c / l), i * (l / c), n * (c / l)];
    case 14:
      return [1 - t, 1 - s - i * (l / c), n * (c / l), i * (l / c)];
    case 15:
      return [s, 1 - t, i * (l / c), n * (c / l)];
    default:
      return [t, s, i, n];
  }
}, K(z, "_currentDrawId", -1), K(z, "_currentParent", null), b(z, ne, null), b(z, ma, null), b(z, va, null), b(z, Bn, NaN), b(z, jn, null), b(z, Hn, null), b(z, ba, NaN), K(z, "_INNER_MARGIN", 3);
let Dp = z;
var ri, re, ae, ya, il, Ie, ue, ms, Aa, wa, Ea, nl, hu;
class iE {
  constructor(e, t, s, i, n, r) {
    b(this, nl);
    b(this, ri, new Float64Array(6));
    b(this, re);
    b(this, ae);
    b(this, ya);
    b(this, il);
    b(this, Ie);
    b(this, ue, "");
    b(this, ms, 0);
    b(this, Aa, new _u());
    b(this, wa);
    b(this, Ea);
    p(this, wa, s), p(this, Ea, i), p(this, ya, n), p(this, il, r), [e, t] = v(this, nl, hu).call(this, e, t);
    const o = p(this, re, [NaN, NaN, NaN, NaN, e, t]);
    p(this, Ie, [e, t]), p(this, ae, [{
      line: o,
      points: a(this, Ie)
    }]), a(this, ri).set(o, 0);
  }
  updateProperty(e, t) {
    e === "stroke-width" && p(this, il, t);
  }
  isEmpty() {
    return !a(this, ae) || a(this, ae).length === 0;
  }
  isCancellable() {
    return a(this, Ie).length <= 10;
  }
  add(e, t) {
    [e, t] = v(this, nl, hu).call(this, e, t);
    const [s, i, n, r] = a(this, ri).subarray(2, 6), o = e - n, l = t - r;
    return Math.hypot(a(this, wa) * o, a(this, Ea) * l) <= 2 ? null : (a(this, Ie).push(e, t), isNaN(s) ? (a(this, ri).set([n, r, e, t], 2), a(this, re).push(NaN, NaN, NaN, NaN, e, t), {
      path: {
        d: this.toSVGPath()
      }
    }) : (isNaN(a(this, ri)[0]) && a(this, re).splice(6, 6), a(this, ri).set([s, i, n, r, e, t], 0), a(this, re).push(...U.createBezierPoints(s, i, n, r, e, t)), {
      path: {
        d: this.toSVGPath()
      }
    }));
  }
  end(e, t) {
    const s = this.add(e, t);
    return s || (a(this, Ie).length === 2 ? {
      path: {
        d: this.toSVGPath()
      }
    } : null);
  }
  startNew(e, t, s, i, n) {
    p(this, wa, s), p(this, Ea, i), p(this, ya, n), [e, t] = v(this, nl, hu).call(this, e, t);
    const r = p(this, re, [NaN, NaN, NaN, NaN, e, t]);
    p(this, Ie, [e, t]);
    const o = a(this, ae).at(-1);
    return o && (o.line = new Float32Array(o.line), o.points = new Float32Array(o.points)), a(this, ae).push({
      line: r,
      points: a(this, Ie)
    }), a(this, ri).set(r, 0), p(this, ms, 0), this.toSVGPath(), null;
  }
  getLastElement() {
    return a(this, ae).at(-1);
  }
  setLastElement(e) {
    return a(this, ae) ? (a(this, ae).push(e), p(this, re, e.line), p(this, Ie, e.points), p(this, ms, 0), {
      path: {
        d: this.toSVGPath()
      }
    }) : a(this, Aa).setLastElement(e);
  }
  removeLastElement() {
    if (!a(this, ae))
      return a(this, Aa).removeLastElement();
    a(this, ae).pop(), p(this, ue, "");
    for (let e = 0, t = a(this, ae).length; e < t; e++) {
      const {
        line: s,
        points: i
      } = a(this, ae)[e];
      p(this, re, s), p(this, Ie, i), p(this, ms, 0), this.toSVGPath();
    }
    return {
      path: {
        d: a(this, ue)
      }
    };
  }
  toSVGPath() {
    const e = U.svgRound(a(this, re)[4]), t = U.svgRound(a(this, re)[5]);
    if (a(this, Ie).length === 2)
      return p(this, ue, `${a(this, ue)} M ${e} ${t} Z`), a(this, ue);
    if (a(this, Ie).length <= 6) {
      const i = a(this, ue).lastIndexOf("M");
      p(this, ue, `${a(this, ue).slice(0, i)} M ${e} ${t}`), p(this, ms, 6);
    }
    if (a(this, Ie).length === 4) {
      const i = U.svgRound(a(this, re)[10]), n = U.svgRound(a(this, re)[11]);
      return p(this, ue, `${a(this, ue)} L ${i} ${n}`), p(this, ms, 12), a(this, ue);
    }
    const s = [];
    a(this, ms) === 0 && (s.push(`M ${e} ${t}`), p(this, ms, 6));
    for (let i = a(this, ms), n = a(this, re).length; i < n; i += 6) {
      const [r, o, l, c, d, u] = a(this, re).slice(i, i + 6).map(U.svgRound);
      s.push(`C${r} ${o} ${l} ${c} ${d} ${u}`);
    }
    return p(this, ue, a(this, ue) + s.join(" ")), p(this, ms, a(this, re).length), a(this, ue);
  }
  getOutlines(e, t, s, i) {
    const n = a(this, ae).at(-1);
    return n.line = new Float32Array(n.line), n.points = new Float32Array(n.points), a(this, Aa).build(a(this, ae), e, t, s, a(this, ya), a(this, il), i), p(this, ri, null), p(this, re, null), p(this, ae, null), p(this, ue, null), a(this, Aa);
  }
  get defaultSVGProperties() {
    return {
      root: {
        viewBox: "0 0 10000 10000"
      },
      rootClass: {
        draw: !0
      },
      bbox: [0, 0, 1, 1]
    };
  }
}
ri = new WeakMap(), re = new WeakMap(), ae = new WeakMap(), ya = new WeakMap(), il = new WeakMap(), Ie = new WeakMap(), ue = new WeakMap(), ms = new WeakMap(), Aa = new WeakMap(), wa = new WeakMap(), Ea = new WeakMap(), nl = new WeakSet(), hu = function(e, t) {
  return U._normalizePoint(e, t, a(this, wa), a(this, Ea), a(this, ya));
};
var _e, Uc, zc, ss, ai, oi, rl, al, ol, ge, Ei, Xb, Yb, Kb;
const Ug = class Ug extends U {
  constructor() {
    super(...arguments);
    b(this, ge);
    b(this, _e);
    b(this, Uc, 0);
    b(this, zc);
    b(this, ss);
    b(this, ai);
    b(this, oi);
    b(this, rl);
    b(this, al);
    b(this, ol);
  }
  build(t, s, i, n, r, o, l) {
    p(this, ai, s), p(this, oi, i), p(this, rl, n), p(this, al, r), p(this, ol, o), p(this, zc, l ?? 0), p(this, ss, t), v(this, ge, Yb).call(this);
  }
  setLastElement(t) {
    return a(this, ss).push(t), {
      path: {
        d: this.toSVGPath()
      }
    };
  }
  removeLastElement() {
    return a(this, ss).pop(), {
      path: {
        d: this.toSVGPath()
      }
    };
  }
  toSVGPath() {
    const t = [];
    for (const {
      line: s
    } of a(this, ss)) {
      if (t.push(`M${U.svgRound(s[4])} ${U.svgRound(s[5])}`), s.length === 6) {
        t.push("Z");
        continue;
      }
      if (s.length === 12) {
        t.push(`L${U.svgRound(s[10])} ${U.svgRound(s[11])}`);
        continue;
      }
      for (let i = 6, n = s.length; i < n; i += 6) {
        const [r, o, l, c, d, u] = s.subarray(i, i + 6).map(U.svgRound);
        t.push(`C${r} ${o} ${l} ${c} ${d} ${u}`);
      }
    }
    return t.join("");
  }
  serialize([t, s, i, n], r) {
    const o = [], l = [], [c, d, u, f] = v(this, ge, Xb).call(this);
    let g, m, y, w, A, E, S, T, P;
    switch (a(this, al)) {
      case 0:
        P = U._rescale, g = t, m = s + n, y = i, w = -n, A = t + c * i, E = s + (1 - d - f) * n, S = t + (c + u) * i, T = s + (1 - d) * n;
        break;
      case 90:
        P = U._rescaleAndSwap, g = t, m = s, y = i, w = n, A = t + d * i, E = s + c * n, S = t + (d + f) * i, T = s + (c + u) * n;
        break;
      case 180:
        P = U._rescale, g = t + i, m = s, y = -i, w = n, A = t + (1 - c - u) * i, E = s + d * n, S = t + (1 - c) * i, T = s + (d + f) * n;
        break;
      case 270:
        P = U._rescaleAndSwap, g = t + i, m = s + n, y = -i, w = -n, A = t + (1 - d - f) * i, E = s + (1 - c - u) * n, S = t + (1 - d) * i, T = s + (1 - c) * n;
        break;
    }
    for (const {
      line: C,
      points: R
    } of a(this, ss))
      o.push(P(C, g, m, y, w, r ? new Array(C.length) : null)), l.push(P(R, g, m, y, w, r ? new Array(R.length) : null));
    return {
      lines: o,
      points: l,
      rect: [A, E, S, T]
    };
  }
  static deserialize(t, s, i, n, r, {
    paths: {
      lines: o,
      points: l
    },
    rotation: c,
    thickness: d
  }) {
    const u = [];
    let f, g, m, y, w;
    switch (c) {
      case 0:
        w = U._rescale, f = -t / i, g = s / n + 1, m = 1 / i, y = -1 / n;
        break;
      case 90:
        w = U._rescaleAndSwap, f = -s / n, g = -t / i, m = 1 / n, y = 1 / i;
        break;
      case 180:
        w = U._rescale, f = t / i + 1, g = -s / n, m = -1 / i, y = 1 / n;
        break;
      case 270:
        w = U._rescaleAndSwap, f = s / n + 1, g = t / i + 1, m = -1 / n, y = -1 / i;
        break;
    }
    if (!o) {
      o = [];
      for (const E of l) {
        const S = E.length;
        if (S === 2) {
          o.push(new Float32Array([NaN, NaN, NaN, NaN, E[0], E[1]]));
          continue;
        }
        if (S === 4) {
          o.push(new Float32Array([NaN, NaN, NaN, NaN, E[0], E[1], NaN, NaN, NaN, NaN, E[2], E[3]]));
          continue;
        }
        const T = new Float32Array(3 * (S - 2));
        o.push(T);
        let [P, C, R, _] = E.subarray(0, 4);
        T.set([NaN, NaN, NaN, NaN, P, C], 0);
        for (let x = 4; x < S; x += 2) {
          const I = E[x], L = E[x + 1];
          T.set(U.createBezierPoints(P, C, R, _, I, L), (x - 2) * 3), [P, C, R, _] = [R, _, I, L];
        }
      }
    }
    for (let E = 0, S = o.length; E < S; E++)
      u.push({
        line: w(o[E].map((T) => T ?? NaN), f, g, m, y),
        points: w(l[E].map((T) => T ?? NaN), f, g, m, y)
      });
    const A = new Ug();
    return A.build(u, i, n, 1, c, d, r), A;
  }
  get box() {
    return a(this, _e);
  }
  updateProperty(t, s) {
    return t === "stroke-width" ? v(this, ge, Kb).call(this, s) : null;
  }
  updateParentDimensions([t, s], i) {
    const [n, r] = v(this, ge, Ei).call(this);
    p(this, ai, t), p(this, oi, s), p(this, rl, i);
    const [o, l] = v(this, ge, Ei).call(this), c = o - n, d = l - r, u = a(this, _e);
    return u[0] -= c, u[1] -= d, u[2] += 2 * c, u[3] += 2 * d, u;
  }
  updateRotation(t) {
    return p(this, Uc, t), {
      path: {
        transform: this.rotationTransform
      }
    };
  }
  get viewBox() {
    return a(this, _e).map(U.svgRound).join(" ");
  }
  get defaultProperties() {
    const [t, s] = a(this, _e);
    return {
      root: {
        viewBox: this.viewBox
      },
      path: {
        "transform-origin": `${U.svgRound(t)} ${U.svgRound(s)}`
      }
    };
  }
  get rotationTransform() {
    const [, , t, s] = a(this, _e);
    let i = 0, n = 0, r = 0, o = 0, l = 0, c = 0;
    switch (a(this, Uc)) {
      case 90:
        n = s / t, r = -t / s, l = t;
        break;
      case 180:
        i = -1, o = -1, l = t, c = s;
        break;
      case 270:
        n = -s / t, r = t / s, c = s;
        break;
      default:
        return "";
    }
    return `matrix(${i} ${n} ${r} ${o} ${U.svgRound(l)} ${U.svgRound(c)})`;
  }
  getPathResizingSVGProperties([t, s, i, n]) {
    const [r, o] = v(this, ge, Ei).call(this), [l, c, d, u] = a(this, _e);
    if (Math.abs(d - r) <= U.PRECISION || Math.abs(u - o) <= U.PRECISION) {
      const w = t + i / 2 - (l + d / 2), A = s + n / 2 - (c + u / 2);
      return {
        path: {
          "transform-origin": `${U.svgRound(t)} ${U.svgRound(s)}`,
          transform: `${this.rotationTransform} translate(${w} ${A})`
        }
      };
    }
    const f = (i - 2 * r) / (d - 2 * r), g = (n - 2 * o) / (u - 2 * o), m = d / i, y = u / n;
    return {
      path: {
        "transform-origin": `${U.svgRound(l)} ${U.svgRound(c)}`,
        transform: `${this.rotationTransform} scale(${m} ${y}) translate(${U.svgRound(r)} ${U.svgRound(o)}) scale(${f} ${g}) translate(${U.svgRound(-r)} ${U.svgRound(-o)})`
      }
    };
  }
  getPathResizedSVGProperties([t, s, i, n]) {
    const [r, o] = v(this, ge, Ei).call(this), l = a(this, _e), [c, d, u, f] = l;
    if (l[0] = t, l[1] = s, l[2] = i, l[3] = n, Math.abs(u - r) <= U.PRECISION || Math.abs(f - o) <= U.PRECISION) {
      const A = t + i / 2 - (c + u / 2), E = s + n / 2 - (d + f / 2);
      for (const {
        line: S,
        points: T
      } of a(this, ss))
        U._translate(S, A, E, S), U._translate(T, A, E, T);
      return {
        root: {
          viewBox: this.viewBox
        },
        path: {
          "transform-origin": `${U.svgRound(t)} ${U.svgRound(s)}`,
          transform: this.rotationTransform || null,
          d: this.toSVGPath()
        }
      };
    }
    const g = (i - 2 * r) / (u - 2 * r), m = (n - 2 * o) / (f - 2 * o), y = -g * (c + r) + t + r, w = -m * (d + o) + s + o;
    if (g !== 1 || m !== 1 || y !== 0 || w !== 0)
      for (const {
        line: A,
        points: E
      } of a(this, ss))
        U._rescale(A, y, w, g, m, A), U._rescale(E, y, w, g, m, E);
    return {
      root: {
        viewBox: this.viewBox
      },
      path: {
        "transform-origin": `${U.svgRound(t)} ${U.svgRound(s)}`,
        transform: this.rotationTransform || null,
        d: this.toSVGPath()
      }
    };
  }
  getPathTranslatedSVGProperties([t, s], i) {
    const [n, r] = i, o = a(this, _e), l = t - o[0], c = s - o[1];
    if (a(this, ai) === n && a(this, oi) === r)
      for (const {
        line: d,
        points: u
      } of a(this, ss))
        U._translate(d, l, c, d), U._translate(u, l, c, u);
    else {
      const d = a(this, ai) / n, u = a(this, oi) / r;
      p(this, ai, n), p(this, oi, r);
      for (const {
        line: f,
        points: g
      } of a(this, ss))
        U._rescale(f, l, c, d, u, f), U._rescale(g, l, c, d, u, g);
      o[2] *= d, o[3] *= u;
    }
    return o[0] = t, o[1] = s, {
      root: {
        viewBox: this.viewBox
      },
      path: {
        d: this.toSVGPath(),
        "transform-origin": `${U.svgRound(t)} ${U.svgRound(s)}`
      }
    };
  }
  get defaultSVGProperties() {
    const t = a(this, _e);
    return {
      root: {
        viewBox: this.viewBox
      },
      rootClass: {
        draw: !0
      },
      path: {
        d: this.toSVGPath(),
        "transform-origin": `${U.svgRound(t[0])} ${U.svgRound(t[1])}`,
        transform: this.rotationTransform || null
      },
      bbox: t
    };
  }
};
_e = new WeakMap(), Uc = new WeakMap(), zc = new WeakMap(), ss = new WeakMap(), ai = new WeakMap(), oi = new WeakMap(), rl = new WeakMap(), al = new WeakMap(), ol = new WeakMap(), ge = new WeakSet(), Ei = function(t = a(this, ol)) {
  const s = a(this, zc) + t / 2 * a(this, rl);
  return a(this, al) % 180 === 0 ? [s / a(this, ai), s / a(this, oi)] : [s / a(this, oi), s / a(this, ai)];
}, Xb = function() {
  const [t, s, i, n] = a(this, _e), [r, o] = v(this, ge, Ei).call(this, 0);
  return [t + r, s + o, i - 2 * r, n - 2 * o];
}, Yb = function() {
  const t = p(this, _e, new Float32Array([1 / 0, 1 / 0, -1 / 0, -1 / 0]));
  for (const {
    line: n
  } of a(this, ss)) {
    if (n.length <= 12) {
      for (let l = 4, c = n.length; l < c; l += 6) {
        const [d, u] = n.subarray(l, l + 2);
        t[0] = Math.min(t[0], d), t[1] = Math.min(t[1], u), t[2] = Math.max(t[2], d), t[3] = Math.max(t[3], u);
      }
      continue;
    }
    let r = n[4], o = n[5];
    for (let l = 6, c = n.length; l < c; l += 6) {
      const [d, u, f, g, m, y] = n.subarray(l, l + 6);
      X.bezierBoundingBox(r, o, d, u, f, g, m, y, t), r = m, o = y;
    }
  }
  const [s, i] = v(this, ge, Ei).call(this);
  t[0] = Math.min(1, Math.max(0, t[0] - s)), t[1] = Math.min(1, Math.max(0, t[1] - i)), t[2] = Math.min(1, Math.max(0, t[2] + s)), t[3] = Math.min(1, Math.max(0, t[3] + i)), t[2] -= t[0], t[3] -= t[1];
}, Kb = function(t) {
  const [s, i] = v(this, ge, Ei).call(this);
  p(this, ol, t);
  const [n, r] = v(this, ge, Ei).call(this), [o, l] = [n - s, r - i], c = a(this, _e);
  return c[0] -= o, c[1] -= l, c[2] += 2 * o, c[3] += 2 * l, c;
};
let _u = Ug;
var ll;
const zg = class zg extends sE {
  constructor(t) {
    super();
    b(this, ll);
    p(this, ll, t), super.updateProperties({
      fill: "none",
      stroke: Ot._defaultLineColor,
      "stroke-opacity": 1,
      "stroke-width": 1,
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-miterlimit": 10
    });
  }
  updateSVGProperty(t, s) {
    t === "stroke-width" && (s ?? (s = this["stroke-width"]), s *= a(this, ll).realScale), super.updateSVGProperty(t, s);
  }
  clone() {
    const t = new zg(a(this, ll));
    return t.updateAll(this), t;
  }
};
ll = new WeakMap();
let jp = zg;
var Ju, Qb;
const so = class so extends Dp {
  constructor(t) {
    super({
      ...t,
      name: "inkEditor"
    });
    b(this, Ju);
    this._willKeepAspectRatio = !0;
  }
  static initialize(t, s) {
    Ot.initialize(t, s), this._defaultDrawingOptions = new jp(s.viewParameters);
  }
  static getDefaultDrawingOptions(t) {
    const s = this._defaultDrawingOptions.clone();
    return s.updateProperties(t), s;
  }
  static get supportMultipleDrawings() {
    return !0;
  }
  static get typesMap() {
    return ht(this, "typesMap", /* @__PURE__ */ new Map([[ct.INK_THICKNESS, "stroke-width"], [ct.INK_COLOR, "stroke"], [ct.INK_OPACITY, "stroke-opacity"]]));
  }
  static createDrawerInstance(t, s, i, n, r) {
    return new iE(t, s, i, n, r, this._defaultDrawingOptions["stroke-width"]);
  }
  static deserializeDraw(t, s, i, n, r, o) {
    return _u.deserialize(t, s, i, n, r, o);
  }
  static async deserialize(t, s, i) {
    let n = null;
    if (t instanceof Bg) {
      const {
        data: {
          inkLists: o,
          rect: l,
          rotation: c,
          id: d,
          color: u,
          opacity: f,
          borderStyle: {
            rawWidth: g
          },
          popupRef: m
        },
        parent: {
          page: {
            pageNumber: y
          }
        }
      } = t;
      n = t = {
        annotationType: at.INK,
        color: Array.from(u),
        thickness: g,
        opacity: f,
        paths: {
          points: o
        },
        boxes: null,
        pageIndex: y - 1,
        rect: l.slice(0),
        rotation: c,
        id: d,
        deleted: !1,
        popupRef: m
      };
    }
    const r = await super.deserialize(t, s, i);
    return r.annotationElementId = t.id || null, r._initialData = n, r;
  }
  onScaleChanging() {
    if (!this.parent)
      return;
    super.onScaleChanging();
    const {
      _drawId: t,
      _drawingOptions: s,
      parent: i
    } = this;
    s.updateSVGProperty("stroke-width"), i.drawLayer.updateProperties(t, s.toSVGProperties());
  }
  static onScaleChangingWhenDrawing() {
    const t = this._currentParent;
    t && (super.onScaleChangingWhenDrawing(), this._defaultDrawingOptions.updateSVGProperty("stroke-width"), t.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties()));
  }
  createDrawingOptions({
    color: t,
    thickness: s,
    opacity: i
  }) {
    this._drawingOptions = so.getDefaultDrawingOptions({
      stroke: X.makeHexColor(...t),
      "stroke-width": s,
      "stroke-opacity": i
    });
  }
  serialize(t = !1) {
    if (this.isEmpty())
      return null;
    if (this.deleted)
      return this.serializeDeleted();
    const {
      lines: s,
      points: i,
      rect: n
    } = this.serializeDraw(t), {
      _drawingOptions: {
        stroke: r,
        "stroke-opacity": o,
        "stroke-width": l
      }
    } = this, c = {
      annotationType: at.INK,
      color: Ot._colorManager.convert(r),
      opacity: o,
      thickness: l,
      paths: {
        lines: s,
        points: i
      },
      pageIndex: this.pageIndex,
      rect: n,
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId
    };
    return t ? c : this.annotationElementId && !v(this, Ju, Qb).call(this, c) ? null : (c.id = this.annotationElementId, c);
  }
  renderAnnotationElement(t) {
    const {
      points: s,
      rect: i
    } = this.serializeDraw(!1);
    return t.updateEdited({
      rect: i,
      thickness: this._drawingOptions["stroke-width"],
      points: s
    }), null;
  }
};
Ju = new WeakSet(), Qb = function(t) {
  const {
    color: s,
    thickness: i,
    opacity: n,
    pageIndex: r
  } = this._initialData;
  return this._hasBeenMoved || this._hasBeenResized || t.color.some((o, l) => o !== s[l]) || t.thickness !== i || t.opacity !== n || t.pageIndex !== r;
}, K(so, "_type", "ink"), K(so, "_editorType", at.INK), K(so, "_defaultDrawingOptions", null);
let Hp = so;
var Mt, fe, $n, Yi, Vn, hl, li, hi, is, cl, gt, ih, nh, cu, Vp, du, Up, uu, Zb;
const ph = class ph extends Ot {
  constructor(t) {
    super({
      ...t,
      name: "stampEditor"
    });
    b(this, gt);
    b(this, Mt, null);
    b(this, fe, null);
    b(this, $n, null);
    b(this, Yi, null);
    b(this, Vn, null);
    b(this, hl, "");
    b(this, li, null);
    b(this, hi, null);
    b(this, is, !1);
    b(this, cl, !1);
    p(this, Yi, t.bitmapUrl), p(this, Vn, t.bitmapFile);
  }
  static initialize(t, s) {
    Ot.initialize(t, s);
  }
  static get supportedTypes() {
    return ht(this, "supportedTypes", ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"].map((s) => `image/${s}`));
  }
  static get supportedTypesStr() {
    return ht(this, "supportedTypesStr", this.supportedTypes.join(","));
  }
  static isHandlingMimeForPasting(t) {
    return this.supportedTypes.includes(t);
  }
  static paste(t, s) {
    s.pasteEditor(at.STAMP, {
      bitmapFile: t.getAsFile()
    });
  }
  altTextFinish() {
    this._uiManager.useNewAltTextFlow && (this.div.hidden = !1), super.altTextFinish();
  }
  get telemetryFinalData() {
    var t;
    return {
      type: "stamp",
      hasAltText: !!((t = this.altTextData) != null && t.altText)
    };
  }
  static computeTelemetryFinalData(t) {
    const s = t.get("hasAltText");
    return {
      hasAltText: s.get(!0) ?? 0,
      hasNoAltText: s.get(!1) ?? 0
    };
  }
  async mlGuessAltText(t = null, s = !0) {
    if (this.hasAltTextData())
      return null;
    const {
      mlManager: i
    } = this._uiManager;
    if (!i)
      throw new Error("No ML.");
    if (!await i.isEnabledFor("altText"))
      throw new Error("ML isn't enabled for alt text.");
    const {
      data: n,
      width: r,
      height: o
    } = t || this.copyCanvas(null, null, !0).imageData, l = await i.guess({
      name: "altText",
      request: {
        data: n,
        width: r,
        height: o,
        channels: n.length / (r * o)
      }
    });
    if (!l)
      throw new Error("No response from the AI service.");
    if (l.error)
      throw new Error("Error from the AI service.");
    if (l.cancel)
      return null;
    if (!l.output)
      throw new Error("No valid response from the AI service.");
    const c = l.output;
    return await this.setGuessedAltText(c), s && !this.hasAltTextData() && (this.altTextData = {
      alt: c,
      decorative: !1
    }), c;
  }
  remove() {
    var t;
    a(this, fe) && (p(this, Mt, null), this._uiManager.imageManager.deleteId(a(this, fe)), (t = a(this, li)) == null || t.remove(), p(this, li, null), a(this, hi) && (clearTimeout(a(this, hi)), p(this, hi, null))), super.remove();
  }
  rebuild() {
    if (!this.parent) {
      a(this, fe) && v(this, gt, cu).call(this);
      return;
    }
    super.rebuild(), this.div !== null && (a(this, fe) && a(this, li) === null && v(this, gt, cu).call(this), this.isAttachedToDOM || this.parent.add(this));
  }
  onceAdded(t) {
    this._isDraggable = !0, t && this.div.focus();
  }
  isEmpty() {
    return !(a(this, $n) || a(this, Mt) || a(this, Yi) || a(this, Vn) || a(this, fe));
  }
  get isResizable() {
    return !0;
  }
  render() {
    if (this.div)
      return this.div;
    let t, s;
    if (this.width && (t = this.x, s = this.y), super.render(), this.div.hidden = !0, this.div.setAttribute("role", "figure"), this.addAltTextButton(), a(this, Mt) ? v(this, gt, Vp).call(this) : v(this, gt, cu).call(this), this.width && !this.annotationElementId) {
      const [i, n] = this.parentDimensions;
      this.setAt(t * i, s * n, this.width * i, this.height * n);
    }
    return this._uiManager.addShouldRescale(this), this.div;
  }
  _onResized() {
    this.onScaleChanging();
  }
  onScaleChanging() {
    if (!this.parent)
      return;
    a(this, hi) !== null && clearTimeout(a(this, hi)), p(this, hi, setTimeout(() => {
      p(this, hi, null), v(this, gt, Up).call(this);
    }, 200));
  }
  copyCanvas(t, s, i = !1) {
    var g;
    t || (t = 224);
    const {
      width: n,
      height: r
    } = a(this, Mt), o = new Bf();
    let l = a(this, Mt), c = n, d = r, u = null;
    if (s) {
      if (n > s || r > s) {
        const _ = Math.min(s / n, s / r);
        c = Math.floor(n * _), d = Math.floor(r * _);
      }
      u = document.createElement("canvas");
      const m = u.width = Math.ceil(c * o.sx), y = u.height = Math.ceil(d * o.sy);
      a(this, is) || (l = v(this, gt, du).call(this, m, y));
      const w = u.getContext("2d");
      w.filter = this._uiManager.hcmFilter;
      let A = "white", E = "#cfcfd8";
      this._uiManager.hcmFilter !== "none" ? E = "black" : (g = window.matchMedia) != null && g.call(window, "(prefers-color-scheme: dark)").matches && (A = "#8f8f9d", E = "#42414d");
      const S = 15, T = S * o.sx, P = S * o.sy, C = new OffscreenCanvas(T * 2, P * 2), R = C.getContext("2d");
      R.fillStyle = A, R.fillRect(0, 0, T * 2, P * 2), R.fillStyle = E, R.fillRect(0, 0, T, P), R.fillRect(T, P, T, P), w.fillStyle = w.createPattern(C, "repeat"), w.fillRect(0, 0, m, y), w.drawImage(l, 0, 0, l.width, l.height, 0, 0, m, y);
    }
    let f = null;
    if (i) {
      let m, y;
      if (o.symmetric && l.width < t && l.height < t)
        m = l.width, y = l.height;
      else if (l = a(this, Mt), n > t || r > t) {
        const E = Math.min(t / n, t / r);
        m = Math.floor(n * E), y = Math.floor(r * E), a(this, is) || (l = v(this, gt, du).call(this, m, y));
      }
      const A = new OffscreenCanvas(m, y).getContext("2d", {
        willReadFrequently: !0
      });
      A.drawImage(l, 0, 0, l.width, l.height, 0, 0, m, y), f = {
        width: m,
        height: y,
        data: A.getImageData(0, 0, m, y).data
      };
    }
    return {
      canvas: u,
      width: c,
      height: d,
      imageData: f
    };
  }
  getImageForAltText() {
    return a(this, li);
  }
  static async deserialize(t, s, i) {
    var y;
    let n = null;
    if (t instanceof vb) {
      const {
        data: {
          rect: w,
          rotation: A,
          id: E,
          structParent: S,
          popupRef: T
        },
        container: P,
        parent: {
          page: {
            pageNumber: C
          }
        }
      } = t, R = P.querySelector("canvas"), _ = i.imageManager.getFromCanvas(P.id, R);
      R.remove();
      const x = ((y = await s._structTree.getAriaAttributes(`${Lg}${E}`)) == null ? void 0 : y.get("aria-label")) || "";
      n = t = {
        annotationType: at.STAMP,
        bitmapId: _.id,
        bitmap: _.bitmap,
        pageIndex: C - 1,
        rect: w.slice(0),
        rotation: A,
        id: E,
        deleted: !1,
        accessibilityData: {
          decorative: !1,
          altText: x
        },
        isSvg: !1,
        structParent: S,
        popupRef: T
      };
    }
    const r = await super.deserialize(t, s, i), {
      rect: o,
      bitmap: l,
      bitmapUrl: c,
      bitmapId: d,
      isSvg: u,
      accessibilityData: f
    } = t;
    d && i.imageManager.isValidId(d) ? (p(r, fe, d), l && p(r, Mt, l)) : p(r, Yi, c), p(r, is, u);
    const [g, m] = r.pageDimensions;
    return r.width = (o[2] - o[0]) / g, r.height = (o[3] - o[1]) / m, r.annotationElementId = t.id || null, f && (r.altTextData = f), r._initialData = n, p(r, cl, !!n), r;
  }
  serialize(t = !1, s = null) {
    if (this.isEmpty())
      return null;
    if (this.deleted)
      return this.serializeDeleted();
    const i = {
      annotationType: at.STAMP,
      bitmapId: a(this, fe),
      pageIndex: this.pageIndex,
      rect: this.getRect(0, 0),
      rotation: this.rotation,
      isSvg: a(this, is),
      structTreeParentId: this._structTreeParentId
    };
    if (t)
      return i.bitmapUrl = v(this, gt, uu).call(this, !0), i.accessibilityData = this.serializeAltText(!0), i;
    const {
      decorative: n,
      altText: r
    } = this.serializeAltText(!1);
    if (!n && r && (i.accessibilityData = {
      type: "Figure",
      alt: r
    }), this.annotationElementId) {
      const l = v(this, gt, Zb).call(this, i);
      if (l.isSame)
        return null;
      l.isSameAltText ? delete i.accessibilityData : i.accessibilityData.structParent = this._initialData.structParent ?? -1;
    }
    if (i.id = this.annotationElementId, s === null)
      return i;
    s.stamps || (s.stamps = /* @__PURE__ */ new Map());
    const o = a(this, is) ? (i.rect[2] - i.rect[0]) * (i.rect[3] - i.rect[1]) : null;
    if (!s.stamps.has(a(this, fe)))
      s.stamps.set(a(this, fe), {
        area: o,
        serialized: i
      }), i.bitmap = v(this, gt, uu).call(this, !1);
    else if (a(this, is)) {
      const l = s.stamps.get(a(this, fe));
      o > l.area && (l.area = o, l.serialized.bitmap.close(), l.serialized.bitmap = v(this, gt, uu).call(this, !1));
    }
    return i;
  }
  renderAnnotationElement(t) {
    return t.updateEdited({
      rect: this.getRect(0, 0)
    }), null;
  }
};
Mt = new WeakMap(), fe = new WeakMap(), $n = new WeakMap(), Yi = new WeakMap(), Vn = new WeakMap(), hl = new WeakMap(), li = new WeakMap(), hi = new WeakMap(), is = new WeakMap(), cl = new WeakMap(), gt = new WeakSet(), ih = function(t, s = !1) {
  if (!t) {
    this.remove();
    return;
  }
  p(this, Mt, t.bitmap), s || (p(this, fe, t.id), p(this, is, t.isSvg)), t.file && p(this, hl, t.file.name), v(this, gt, Vp).call(this);
}, nh = function() {
  if (p(this, $n, null), this._uiManager.enableWaiting(!1), !!a(this, li)) {
    if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && a(this, Mt)) {
      this._editToolbar.hide(), this._uiManager.editAltText(this, !0);
      return;
    }
    if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && a(this, Mt)) {
      this._reportTelemetry({
        action: "pdfjs.image.image_added",
        data: {
          alt_text_modal: !1,
          alt_text_type: "empty"
        }
      });
      try {
        this.mlGuessAltText();
      } catch {
      }
    }
    this.div.focus();
  }
}, cu = function() {
  if (a(this, fe)) {
    this._uiManager.enableWaiting(!0), this._uiManager.imageManager.getFromId(a(this, fe)).then((i) => v(this, gt, ih).call(this, i, !0)).finally(() => v(this, gt, nh).call(this));
    return;
  }
  if (a(this, Yi)) {
    const i = a(this, Yi);
    p(this, Yi, null), this._uiManager.enableWaiting(!0), p(this, $n, this._uiManager.imageManager.getFromUrl(i).then((n) => v(this, gt, ih).call(this, n)).finally(() => v(this, gt, nh).call(this)));
    return;
  }
  if (a(this, Vn)) {
    const i = a(this, Vn);
    p(this, Vn, null), this._uiManager.enableWaiting(!0), p(this, $n, this._uiManager.imageManager.getFromFile(i).then((n) => v(this, gt, ih).call(this, n)).finally(() => v(this, gt, nh).call(this)));
    return;
  }
  const t = document.createElement("input");
  t.type = "file", t.accept = ph.supportedTypesStr;
  const s = this._uiManager._signal;
  p(this, $n, new Promise((i) => {
    t.addEventListener("change", async () => {
      if (!t.files || t.files.length === 0)
        this.remove();
      else {
        this._uiManager.enableWaiting(!0);
        const n = await this._uiManager.imageManager.getFromFile(t.files[0]);
        this._reportTelemetry({
          action: "pdfjs.image.image_selected",
          data: {
            alt_text_modal: this._uiManager.useNewAltTextFlow
          }
        }), v(this, gt, ih).call(this, n);
      }
      i();
    }, {
      signal: s
    }), t.addEventListener("cancel", () => {
      this.remove(), i();
    }, {
      signal: s
    });
  }).finally(() => v(this, gt, nh).call(this))), t.click();
}, Vp = function() {
  var u;
  const {
    div: t
  } = this;
  let {
    width: s,
    height: i
  } = a(this, Mt);
  const [n, r] = this.pageDimensions, o = 0.75;
  if (this.width)
    s = this.width * n, i = this.height * r;
  else if (s > o * n || i > o * r) {
    const f = Math.min(o * n / s, o * r / i);
    s *= f, i *= f;
  }
  const [l, c] = this.parentDimensions;
  this.setDims(s * l / n, i * c / r), this._uiManager.enableWaiting(!1);
  const d = p(this, li, document.createElement("canvas"));
  d.setAttribute("role", "img"), this.addContainer(d), this.width = s / n, this.height = i / r, (u = this._initialOptions) != null && u.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, (!this._uiManager.useNewAltTextWhenAddingImage || !this._uiManager.useNewAltTextFlow || this.annotationElementId) && (t.hidden = !1), v(this, gt, Up).call(this), a(this, cl) || (this.parent.addUndoableEditor(this), p(this, cl, !0)), this._reportTelemetry({
    action: "inserted_image"
  }), a(this, hl) && d.setAttribute("aria-label", a(this, hl));
}, du = function(t, s) {
  const {
    width: i,
    height: n
  } = a(this, Mt);
  let r = i, o = n, l = a(this, Mt);
  for (; r > 2 * t || o > 2 * s; ) {
    const c = r, d = o;
    r > 2 * t && (r = r >= 16384 ? Math.floor(r / 2) - 1 : Math.ceil(r / 2)), o > 2 * s && (o = o >= 16384 ? Math.floor(o / 2) - 1 : Math.ceil(o / 2));
    const u = new OffscreenCanvas(r, o);
    u.getContext("2d").drawImage(l, 0, 0, c, d, 0, 0, r, o), l = u.transferToImageBitmap();
  }
  return l;
}, Up = function() {
  const [t, s] = this.parentDimensions, {
    width: i,
    height: n
  } = this, r = new Bf(), o = Math.ceil(i * t * r.sx), l = Math.ceil(n * s * r.sy), c = a(this, li);
  if (!c || c.width === o && c.height === l)
    return;
  c.width = o, c.height = l;
  const d = a(this, is) ? a(this, Mt) : v(this, gt, du).call(this, o, l), u = c.getContext("2d");
  u.filter = this._uiManager.hcmFilter, u.drawImage(d, 0, 0, d.width, d.height, 0, 0, o, l);
}, uu = function(t) {
  if (t) {
    if (a(this, is)) {
      const n = this._uiManager.imageManager.getSvgUrl(a(this, fe));
      if (n)
        return n;
    }
    const s = document.createElement("canvas");
    return {
      width: s.width,
      height: s.height
    } = a(this, Mt), s.getContext("2d").drawImage(a(this, Mt), 0, 0), s.toDataURL();
  }
  if (a(this, is)) {
    const [s, i] = this.pageDimensions, n = Math.round(this.width * s * Ll.PDF_TO_CSS_UNITS), r = Math.round(this.height * i * Ll.PDF_TO_CSS_UNITS), o = new OffscreenCanvas(n, r);
    return o.getContext("2d").drawImage(a(this, Mt), 0, 0, a(this, Mt).width, a(this, Mt).height, 0, 0, n, r), o.transferToImageBitmap();
  }
  return structuredClone(a(this, Mt));
}, Zb = function(t) {
  var o;
  const {
    pageIndex: s,
    accessibilityData: {
      altText: i
    }
  } = this._initialData, n = t.pageIndex === s, r = (((o = t.accessibilityData) == null ? void 0 : o.alt) || "") === i;
  return {
    isSame: !this._hasBeenMoved && !this._hasBeenResized && n && r,
    isSameAltText: r
  };
}, K(ph, "_type", "stamp"), K(ph, "_editorType", at.STAMP);
let $p = ph;
var Sa, dl, ci, Un, Ki, vs, zn, ul, xa, Ds, Qi, Ee, Zi, G, ze, Wn, _t, Jb, Gs, zp, Wp, fu;
let nE = (ze = class {
  constructor({
    uiManager: e,
    pageIndex: t,
    div: s,
    structTreeLayer: i,
    accessibilityManager: n,
    annotationLayer: r,
    drawLayer: o,
    textLayer: l,
    viewport: c,
    l10n: d
  }) {
    b(this, _t);
    b(this, Sa);
    b(this, dl, !1);
    b(this, ci, null);
    b(this, Un, null);
    b(this, Ki, null);
    b(this, vs, /* @__PURE__ */ new Map());
    b(this, zn, !1);
    b(this, ul, !1);
    b(this, xa, !1);
    b(this, Ds, null);
    b(this, Qi, null);
    b(this, Ee, null);
    b(this, Zi, null);
    b(this, G);
    const u = [...a(ze, Wn).values()];
    if (!ze._initialized) {
      ze._initialized = !0;
      for (const f of u)
        f.initialize(d, e);
    }
    e.registerEditorTypes(u), p(this, G, e), this.pageIndex = t, this.div = s, p(this, Sa, n), p(this, ci, r), this.viewport = c, p(this, Ee, l), this.drawLayer = o, this._structTree = i, a(this, G).addLayer(this);
  }
  get isEmpty() {
    return a(this, vs).size === 0;
  }
  get isInvisible() {
    return this.isEmpty && a(this, G).getMode() === at.NONE;
  }
  updateToolbar(e) {
    a(this, G).updateToolbar(e);
  }
  updateMode(e = a(this, G).getMode()) {
    switch (v(this, _t, fu).call(this), e) {
      case at.NONE:
        this.disableTextSelection(), this.togglePointerEvents(!1), this.toggleAnnotationLayerPointerEvents(!0), this.disableClick();
        return;
      case at.INK:
        this.disableTextSelection(), this.togglePointerEvents(!0), this.enableClick();
        break;
      case at.HIGHLIGHT:
        this.enableTextSelection(), this.togglePointerEvents(!1), this.disableClick();
        break;
      default:
        this.disableTextSelection(), this.togglePointerEvents(!0), this.enableClick();
    }
    this.toggleAnnotationLayerPointerEvents(!1);
    const {
      classList: t
    } = this.div;
    for (const s of a(ze, Wn).values())
      t.toggle(`${s._type}Editing`, e === s._editorType);
    this.div.hidden = !1;
  }
  hasTextLayer(e) {
    var t;
    return e === ((t = a(this, Ee)) == null ? void 0 : t.div);
  }
  setEditingState(e) {
    a(this, G).setEditingState(e);
  }
  addCommands(e) {
    a(this, G).addCommands(e);
  }
  cleanUndoStack(e) {
    a(this, G).cleanUndoStack(e);
  }
  toggleDrawing(e = !1) {
    this.div.classList.toggle("drawing", !e);
  }
  togglePointerEvents(e = !1) {
    this.div.classList.toggle("disabled", !e);
  }
  toggleAnnotationLayerPointerEvents(e = !1) {
    var t;
    (t = a(this, ci)) == null || t.div.classList.toggle("disabled", !e);
  }
  async enable() {
    p(this, xa, !0), this.div.tabIndex = 0, this.togglePointerEvents(!0);
    const e = /* @__PURE__ */ new Set();
    for (const s of a(this, vs).values())
      s.enableEditing(), s.show(!0), s.annotationElementId && (a(this, G).removeChangedExistingAnnotation(s), e.add(s.annotationElementId));
    if (!a(this, ci)) {
      p(this, xa, !1);
      return;
    }
    const t = a(this, ci).getEditableAnnotations();
    for (const s of t) {
      if (s.hide(), a(this, G).isDeletedAnnotationElement(s.data.id) || e.has(s.data.id))
        continue;
      const i = await this.deserialize(s);
      i && (this.addOrRebuild(i), i.enableEditing());
    }
    p(this, xa, !1);
  }
  disable() {
    var i;
    p(this, ul, !0), this.div.tabIndex = -1, this.togglePointerEvents(!1);
    const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map();
    for (const n of a(this, vs).values())
      if (n.disableEditing(), !!n.annotationElementId) {
        if (n.serialize() !== null) {
          e.set(n.annotationElementId, n);
          continue;
        } else
          t.set(n.annotationElementId, n);
        (i = this.getEditableAnnotation(n.annotationElementId)) == null || i.show(), n.remove();
      }
    if (a(this, ci)) {
      const n = a(this, ci).getEditableAnnotations();
      for (const r of n) {
        const {
          id: o
        } = r.data;
        if (a(this, G).isDeletedAnnotationElement(o))
          continue;
        let l = t.get(o);
        if (l) {
          l.resetAnnotationElement(r), l.show(!1), r.show();
          continue;
        }
        l = e.get(o), l && (a(this, G).addChangedExistingAnnotation(l), l.renderAnnotationElement(r) && l.show(!1)), r.show();
      }
    }
    v(this, _t, fu).call(this), this.isEmpty && (this.div.hidden = !0);
    const {
      classList: s
    } = this.div;
    for (const n of a(ze, Wn).values())
      s.remove(`${n._type}Editing`);
    this.disableTextSelection(), this.toggleAnnotationLayerPointerEvents(!0), p(this, ul, !1);
  }
  getEditableAnnotation(e) {
    var t;
    return ((t = a(this, ci)) == null ? void 0 : t.getEditableAnnotation(e)) || null;
  }
  setActiveEditor(e) {
    a(this, G).getActive() !== e && a(this, G).setActiveEditor(e);
  }
  enableTextSelection() {
    var e;
    if (this.div.tabIndex = -1, (e = a(this, Ee)) != null && e.div && !a(this, Zi)) {
      p(this, Zi, new AbortController());
      const t = a(this, G).combinedSignal(a(this, Zi));
      a(this, Ee).div.addEventListener("pointerdown", v(this, _t, Jb).bind(this), {
        signal: t
      }), a(this, Ee).div.classList.add("highlighting");
    }
  }
  disableTextSelection() {
    var e;
    this.div.tabIndex = 0, (e = a(this, Ee)) != null && e.div && a(this, Zi) && (a(this, Zi).abort(), p(this, Zi, null), a(this, Ee).div.classList.remove("highlighting"));
  }
  enableClick() {
    if (a(this, Un))
      return;
    p(this, Un, new AbortController());
    const e = a(this, G).combinedSignal(a(this, Un));
    this.div.addEventListener("pointerdown", this.pointerdown.bind(this), {
      signal: e
    });
    const t = this.pointerup.bind(this);
    this.div.addEventListener("pointerup", t, {
      signal: e
    }), this.div.addEventListener("pointercancel", t, {
      signal: e
    });
  }
  disableClick() {
    var e;
    (e = a(this, Un)) == null || e.abort(), p(this, Un, null);
  }
  attach(e) {
    a(this, vs).set(e.id, e);
    const {
      annotationElementId: t
    } = e;
    t && a(this, G).isDeletedAnnotationElement(t) && a(this, G).removeDeletedAnnotationElement(e);
  }
  detach(e) {
    var t;
    a(this, vs).delete(e.id), (t = a(this, Sa)) == null || t.removePointerInTextLayer(e.contentDiv), !a(this, ul) && e.annotationElementId && a(this, G).addDeletedAnnotationElement(e);
  }
  remove(e) {
    this.detach(e), a(this, G).removeEditor(e), e.div.remove(), e.isAttachedToDOM = !1;
  }
  changeParent(e) {
    var t;
    e.parent !== this && (e.parent && e.annotationElementId && (a(this, G).addDeletedAnnotationElement(e.annotationElementId), Ot.deleteAnnotationElement(e), e.annotationElementId = null), this.attach(e), (t = e.parent) == null || t.detach(e), e.setParent(this), e.div && e.isAttachedToDOM && (e.div.remove(), this.div.append(e.div)));
  }
  add(e) {
    if (!(e.parent === this && e.isAttachedToDOM)) {
      if (this.changeParent(e), a(this, G).addEditor(e), this.attach(e), !e.isAttachedToDOM) {
        const t = e.render();
        this.div.append(t), e.isAttachedToDOM = !0;
      }
      e.fixAndSetPosition(), e.onceAdded(!a(this, xa)), a(this, G).addToAnnotationStorage(e), e._reportTelemetry(e.telemetryInitialData);
    }
  }
  moveEditorInDOM(e) {
    var s;
    if (!e.isAttachedToDOM)
      return;
    const {
      activeElement: t
    } = document;
    e.div.contains(t) && !a(this, Ki) && (e._focusEventsAllowed = !1, p(this, Ki, setTimeout(() => {
      p(this, Ki, null), e.div.contains(document.activeElement) ? e._focusEventsAllowed = !0 : (e.div.addEventListener("focusin", () => {
        e._focusEventsAllowed = !0;
      }, {
        once: !0,
        signal: a(this, G)._signal
      }), t.focus());
    }, 0))), e._structTreeParentId = (s = a(this, Sa)) == null ? void 0 : s.moveElementInDOM(this.div, e.div, e.contentDiv, !0);
  }
  addOrRebuild(e) {
    e.needsToBeRebuilt() ? (e.parent || (e.parent = this), e.rebuild(), e.show()) : this.add(e);
  }
  addUndoableEditor(e) {
    const t = () => e._uiManager.rebuild(e), s = () => {
      e.remove();
    };
    this.addCommands({
      cmd: t,
      undo: s,
      mustExec: !1
    });
  }
  getNextId() {
    return a(this, G).getId();
  }
  combinedSignal(e) {
    return a(this, G).combinedSignal(e);
  }
  canCreateNewEmptyEditor() {
    var e;
    return (e = a(this, _t, Gs)) == null ? void 0 : e.canCreateNewEmptyEditor();
  }
  pasteEditor(e, t) {
    a(this, G).updateToolbar(e), a(this, G).updateMode(e);
    const {
      offsetX: s,
      offsetY: i
    } = v(this, _t, Wp).call(this), n = this.getNextId(), r = v(this, _t, zp).call(this, {
      parent: this,
      id: n,
      x: s,
      y: i,
      uiManager: a(this, G),
      isCentered: !0,
      ...t
    });
    r && this.add(r);
  }
  async deserialize(e) {
    var t;
    return await ((t = a(ze, Wn).get(e.annotationType ?? e.annotationEditorType)) == null ? void 0 : t.deserialize(e, this, a(this, G))) || null;
  }
  createAndAddNewEditor(e, t, s = {}) {
    const i = this.getNextId(), n = v(this, _t, zp).call(this, {
      parent: this,
      id: i,
      x: e.offsetX,
      y: e.offsetY,
      uiManager: a(this, G),
      isCentered: t,
      ...s
    });
    return n && this.add(n), n;
  }
  addNewEditor() {
    this.createAndAddNewEditor(v(this, _t, Wp).call(this), !0);
  }
  setSelected(e) {
    a(this, G).setSelected(e);
  }
  toggleSelected(e) {
    a(this, G).toggleSelected(e);
  }
  unselect(e) {
    a(this, G).unselect(e);
  }
  pointerup(e) {
    var s;
    const {
      isMac: t
    } = Oe.platform;
    if (!(e.button !== 0 || e.ctrlKey && t) && e.target === this.div && a(this, zn) && (p(this, zn, !1), !((s = a(this, _t, Gs)) != null && s.isDrawer && a(this, _t, Gs).supportMultipleDrawings))) {
      if (!a(this, dl)) {
        p(this, dl, !0);
        return;
      }
      if (a(this, G).getMode() === at.STAMP) {
        a(this, G).unselectAll();
        return;
      }
      this.createAndAddNewEditor(e, !1);
    }
  }
  pointerdown(e) {
    var i;
    if (a(this, G).getMode() === at.HIGHLIGHT && this.enableTextSelection(), a(this, zn)) {
      p(this, zn, !1);
      return;
    }
    const {
      isMac: t
    } = Oe.platform;
    if (e.button !== 0 || e.ctrlKey && t || e.target !== this.div)
      return;
    if (p(this, zn, !0), (i = a(this, _t, Gs)) != null && i.isDrawer) {
      this.startDrawingSession(e);
      return;
    }
    const s = a(this, G).getActive();
    p(this, dl, !s || s.isEmpty());
  }
  startDrawingSession(e) {
    if (this.div.focus(), a(this, Ds)) {
      a(this, _t, Gs).startDrawing(this, a(this, G), !1, e);
      return;
    }
    a(this, G).setCurrentDrawingSession(this), p(this, Ds, new AbortController());
    const t = a(this, G).combinedSignal(a(this, Ds));
    this.div.addEventListener("blur", ({
      relatedTarget: s
    }) => {
      s && !this.div.contains(s) && (p(this, Qi, null), this.commitOrRemove());
    }, {
      signal: t
    }), a(this, _t, Gs).startDrawing(this, a(this, G), !1, e);
  }
  pause(e) {
    if (e) {
      const {
        activeElement: t
      } = document;
      this.div.contains(t) && p(this, Qi, t);
      return;
    }
    a(this, Qi) && setTimeout(() => {
      var t;
      (t = a(this, Qi)) == null || t.focus(), p(this, Qi, null);
    }, 0);
  }
  endDrawingSession(e = !1) {
    return a(this, Ds) ? (a(this, G).setCurrentDrawingSession(null), a(this, Ds).abort(), p(this, Ds, null), p(this, Qi, null), a(this, _t, Gs).endDrawing(e)) : null;
  }
  findNewParent(e, t, s) {
    const i = a(this, G).findParent(t, s);
    return i === null || i === this ? !1 : (i.changeParent(e), !0);
  }
  commitOrRemove() {
    return a(this, Ds) ? (this.endDrawingSession(), !0) : !1;
  }
  onScaleChanging() {
    a(this, Ds) && a(this, _t, Gs).onScaleChangingWhenDrawing(this);
  }
  destroy() {
    var e, t;
    this.commitOrRemove(), ((e = a(this, G).getActive()) == null ? void 0 : e.parent) === this && (a(this, G).commitOrRemove(), a(this, G).setActiveEditor(null)), a(this, Ki) && (clearTimeout(a(this, Ki)), p(this, Ki, null));
    for (const s of a(this, vs).values())
      (t = a(this, Sa)) == null || t.removePointerInTextLayer(s.contentDiv), s.setParent(null), s.isAttachedToDOM = !1, s.div.remove();
    this.div = null, a(this, vs).clear(), a(this, G).removeLayer(this);
  }
  render({
    viewport: e
  }) {
    this.viewport = e, Va(this.div, e);
    for (const t of a(this, G).getEditors(this.pageIndex))
      this.add(t), t.rebuild();
    this.updateMode();
  }
  update({
    viewport: e
  }) {
    a(this, G).commitOrRemove(), v(this, _t, fu).call(this);
    const t = this.viewport.rotation, s = e.rotation;
    if (this.viewport = e, Va(this.div, {
      rotation: s
    }), t !== s)
      for (const i of a(this, vs).values())
        i.rotate(s);
  }
  get pageDimensions() {
    const {
      pageWidth: e,
      pageHeight: t
    } = this.viewport.rawDims;
    return [e, t];
  }
  get scale() {
    return a(this, G).viewParameters.realScale;
  }
}, Sa = new WeakMap(), dl = new WeakMap(), ci = new WeakMap(), Un = new WeakMap(), Ki = new WeakMap(), vs = new WeakMap(), zn = new WeakMap(), ul = new WeakMap(), xa = new WeakMap(), Ds = new WeakMap(), Qi = new WeakMap(), Ee = new WeakMap(), Zi = new WeakMap(), G = new WeakMap(), Wn = new WeakMap(), _t = new WeakSet(), Jb = function(e) {
  a(this, G).unselectAll();
  const {
    target: t
  } = e;
  if (t === a(this, Ee).div || (t.getAttribute("role") === "img" || t.classList.contains("endOfContent")) && a(this, Ee).div.contains(t)) {
    const {
      isMac: s
    } = Oe.platform;
    if (e.button !== 0 || e.ctrlKey && s)
      return;
    a(this, G).showAllEditors("highlight", !0, !0), a(this, Ee).div.classList.add("free"), this.toggleDrawing(), Iu.startHighlighting(this, a(this, G).direction === "ltr", {
      target: a(this, Ee).div,
      x: e.x,
      y: e.y
    }), a(this, Ee).div.addEventListener("pointerup", () => {
      a(this, Ee).div.classList.remove("free"), this.toggleDrawing(!0);
    }, {
      once: !0,
      signal: a(this, G)._signal
    }), e.preventDefault();
  }
}, Gs = function() {
  return a(ze, Wn).get(a(this, G).getMode());
}, zp = function(e) {
  const t = a(this, _t, Gs);
  return t ? new t.prototype.constructor(e) : null;
}, Wp = function() {
  const {
    x: e,
    y: t,
    width: s,
    height: i
  } = this.div.getBoundingClientRect(), n = Math.max(0, e), r = Math.max(0, t), o = Math.min(window.innerWidth, e + s), l = Math.min(window.innerHeight, t + i), c = (n + o) / 2 - e, d = (r + l) / 2 - t, [u, f] = this.viewport.rotation % 180 === 0 ? [c, d] : [d, c];
  return {
    offsetX: u,
    offsetY: f
  };
}, fu = function() {
  for (const e of a(this, vs).values())
    e.isEmpty() && e.remove();
}, K(ze, "_initialized", !1), b(ze, Wn, new Map([Tp, Hp, $p, Iu].map((e) => [e._editorType, e]))), ze);
var ks, Wc, Le, Ta, qu, Jt, qb, bi, Gp, ty, Xp;
let rE = (Jt = class {
  constructor({
    pageIndex: e
  }) {
    b(this, bi);
    b(this, ks, null);
    b(this, Wc, 0);
    b(this, Le, /* @__PURE__ */ new Map());
    b(this, Ta, /* @__PURE__ */ new Map());
    this.pageIndex = e;
  }
  setParent(e) {
    if (!a(this, ks)) {
      p(this, ks, e);
      return;
    }
    if (a(this, ks) !== e) {
      if (a(this, Le).size > 0)
        for (const t of a(this, Le).values())
          t.remove(), e.append(t);
      p(this, ks, e);
    }
  }
  static get _svgFactory() {
    return ht(this, "_svgFactory", new Fg());
  }
  draw(e, t = !1, s = !1) {
    const i = me(this, Wc)._++, n = v(this, bi, Gp).call(this), r = Jt._svgFactory.createElement("defs");
    n.append(r);
    const o = Jt._svgFactory.createElement("path");
    r.append(o);
    const l = `path_p${this.pageIndex}_${i}`;
    o.setAttribute("id", l), o.setAttribute("vector-effect", "non-scaling-stroke"), t && a(this, Ta).set(i, o);
    const c = s ? v(this, bi, ty).call(this, r, l) : null, d = Jt._svgFactory.createElement("use");
    return n.append(d), d.setAttribute("href", `#${l}`), this.updateProperties(n, e), a(this, Le).set(i, n), {
      id: i,
      clipPathId: `url(#${c})`
    };
  }
  drawOutline(e, t) {
    const s = me(this, Wc)._++, i = v(this, bi, Gp).call(this), n = Jt._svgFactory.createElement("defs");
    i.append(n);
    const r = Jt._svgFactory.createElement("path");
    n.append(r);
    const o = `path_p${this.pageIndex}_${s}`;
    r.setAttribute("id", o), r.setAttribute("vector-effect", "non-scaling-stroke");
    let l;
    if (t) {
      const u = Jt._svgFactory.createElement("mask");
      n.append(u), l = `mask_p${this.pageIndex}_${s}`, u.setAttribute("id", l), u.setAttribute("maskUnits", "objectBoundingBox");
      const f = Jt._svgFactory.createElement("rect");
      u.append(f), f.setAttribute("width", "1"), f.setAttribute("height", "1"), f.setAttribute("fill", "white");
      const g = Jt._svgFactory.createElement("use");
      u.append(g), g.setAttribute("href", `#${o}`), g.setAttribute("stroke", "none"), g.setAttribute("fill", "black"), g.setAttribute("fill-rule", "nonzero"), g.classList.add("mask");
    }
    const c = Jt._svgFactory.createElement("use");
    i.append(c), c.setAttribute("href", `#${o}`), l && c.setAttribute("mask", `url(#${l})`);
    const d = c.cloneNode();
    return i.append(d), c.classList.add("mainOutline"), d.classList.add("secondaryOutline"), this.updateProperties(i, e), a(this, Le).set(s, i), s;
  }
  finalizeDraw(e, t) {
    a(this, Ta).delete(e), this.updateProperties(e, t);
  }
  updateProperties(e, t) {
    var l;
    if (!t)
      return;
    const {
      root: s,
      bbox: i,
      rootClass: n,
      path: r
    } = t, o = typeof e == "number" ? a(this, Le).get(e) : e;
    if (o) {
      if (s && v(this, bi, Xp).call(this, o, s), i && v(l = Jt, qu, qb).call(l, o, i), n) {
        const {
          classList: c
        } = o;
        for (const [d, u] of Object.entries(n))
          c.toggle(d, u);
      }
      if (r) {
        const d = o.firstChild.firstChild;
        v(this, bi, Xp).call(this, d, r);
      }
    }
  }
  updateParent(e, t) {
    if (t === this)
      return;
    const s = a(this, Le).get(e);
    s && (a(t, ks).append(s), a(this, Le).delete(e), a(t, Le).set(e, s));
  }
  remove(e) {
    a(this, Ta).delete(e), a(this, ks) !== null && (a(this, Le).get(e).remove(), a(this, Le).delete(e));
  }
  destroy() {
    p(this, ks, null);
    for (const e of a(this, Le).values())
      e.remove();
    a(this, Le).clear(), a(this, Ta).clear();
  }
}, ks = new WeakMap(), Wc = new WeakMap(), Le = new WeakMap(), Ta = new WeakMap(), qu = new WeakSet(), qb = function(e, [t, s, i, n]) {
  const {
    style: r
  } = e;
  r.top = `${100 * s}%`, r.left = `${100 * t}%`, r.width = `${100 * i}%`, r.height = `${100 * n}%`;
}, bi = new WeakSet(), Gp = function() {
  const e = Jt._svgFactory.create(1, 1, !0);
  return a(this, ks).append(e), e.setAttribute("aria-hidden", !0), e;
}, ty = function(e, t) {
  const s = Jt._svgFactory.createElement("clipPath");
  e.append(s);
  const i = `clip_${t}`;
  s.setAttribute("id", i), s.setAttribute("clipPathUnits", "objectBoundingBox");
  const n = Jt._svgFactory.createElement("use");
  return s.append(n), n.setAttribute("href", `#${t}`), n.classList.add("clip"), i;
}, Xp = function(e, t) {
  for (const [s, i] of Object.entries(t))
    i === null ? e.removeAttribute(s) : e.setAttribute(s, i);
}, b(Jt, qu), Jt);
globalThis.pdfjsTestingUtils = {
  HighlightOutliner: Cp
};
q.AbortException;
q.AnnotationEditorLayer;
q.AnnotationEditorParamsType;
q.AnnotationEditorType;
q.AnnotationEditorUIManager;
var aE = q.AnnotationLayer;
q.AnnotationMode;
q.ColorPicker;
q.DOMSVGFactory;
q.DrawLayer;
q.FeatureTest;
var US = q.GlobalWorkerOptions;
q.ImageKind;
q.InvalidPDFException;
q.MissingPDFException;
q.OPS;
q.OutputScale;
q.PDFDataRangeTransport;
q.PDFDateString;
q.PDFWorker;
var oE = q.PasswordResponses;
q.PermissionFlag;
q.PixelsPerInch;
q.RenderingCancelledException;
var lE = q.TextLayer;
q.TouchManager;
q.UnexpectedResponseException;
q.Util;
q.VerbosityLevel;
q.XfaLayer;
q.build;
q.createValidAbsoluteUrl;
q.fetchData;
var hE = q.getDocument;
q.getFilenameFromUrl;
q.getPdfFilenameFromUrl;
q.getXfaPageViewport;
q.isDataScheme;
q.isPdfFile;
q.noContextMenu;
q.normalizeUnicode;
q.setLayerDimensions;
q.shadow;
q.stopEvent;
q.version;
function cE(h, e, t) {
  const s = h.contentWindow.document.createElement("style");
  s.textContent = `
    @page {
      margin: 3mm;
      size: ${e}pt ${t}pt;
    }
    body {
      margin: 0;
    }
    canvas {
      width: 100%;
      page-break-after: always;
      page-break-before: avoid;
      page-break-inside: avoid;
    }
  `, h.contentWindow.document.head.appendChild(s), h.contentWindow.document.body.style.width = "100%";
}
function dE(h) {
  return new Promise((e) => {
    const t = document.createElement("iframe");
    t.width = "0", t.height = "0", t.style.position = "absolute", t.style.top = "0", t.style.left = "0", t.style.border = "none", t.style.overflow = "hidden", t.onload = () => e(t), h.appendChild(t);
  });
}
function uE(h, e) {
  const t = URL.createObjectURL(
    new Blob([h], {
      type: "application/pdf"
    })
  ), s = document.createElement("a");
  s.href = t, s.download = e, s.style.display = "none", document.body.append(s), s.click(), setTimeout(() => {
    URL.revokeObjectURL(t), document.body.removeChild(s);
  }, 1e3);
}
function gm(h) {
  for (; h != null && h.firstChild; )
    h.removeChild(h.firstChild);
}
function Sf(h) {
  h == null || h.querySelectorAll("canvas").forEach((e) => {
    var t;
    e.width = 1, e.height = 1, (t = e.getContext("2d")) == null || t.clearRect(0, 0, 1, 1);
  });
}
function mm(h) {
  return Object.prototype.hasOwnProperty.call(h, "_pdfInfo");
}
function fE({
  onError: h,
  onPasswordRequest: e,
  onProgress: t,
  source: s
}) {
  const i = xu(null), n = xu(null);
  return Qy(async () => {
    const r = Gg(s);
    if (r) {
      if (mm(r)) {
        i.value = r;
        return;
      }
      try {
        n.value = hE(
          r
        ), e && (n.value.onPassword = (o, l) => {
          e({
            callback: o,
            isWrongPassword: l === oE.INCORRECT_PASSWORD
          });
        }), t && (n.value.onProgress = t), i.value = await n.value.promise;
      } catch (o) {
        if (i.value = null, h)
          h(o);
        else
          throw o;
      }
    }
  }), Nf(i, (r, o) => {
    o == null || o.destroy();
  }), Jm(() => {
    var r, o, l, c;
    (r = n.value) != null && r.onPassword && (n.value.onPassword = null), (o = n.value) != null && o.onProgress && (n.value.onProgress = null), (l = n.value) == null || l.destroy(), mm(Gg(s)) || (c = i.value) == null || c.destroy();
  }), {
    doc: i
  };
}
var dh = {};
dh.d = (h, e) => {
  for (var t in e)
    dh.o(e, t) && !dh.o(h, t) && Object.defineProperty(h, t, { enumerable: !0, get: e[t] });
};
dh.o = (h, e) => Object.prototype.hasOwnProperty.call(h, e);
var Nt = globalThis.pdfjsViewer = {};
dh.d(Nt, {
  AnnotationLayerBuilder: () => (
    /* reexport */
    uy
  ),
  DownloadManager: () => (
    /* reexport */
    l0
  ),
  EventBus: () => (
    /* reexport */
    fy
  ),
  FindState: () => (
    /* reexport */
    un
  ),
  GenericL10n: () => (
    /* reexport */
    Ol
  ),
  LinkTarget: () => (
    /* reexport */
    vr
  ),
  PDFFindController: () => (
    /* reexport */
    YE
  ),
  PDFHistory: () => (
    /* reexport */
    rS
  ),
  PDFLinkService: () => (
    /* reexport */
    Lu
  ),
  PDFPageView: () => (
    /* reexport */
    Oy
  ),
  PDFScriptingManager: () => (
    /* reexport */
    vS
  ),
  PDFSinglePageViewer: () => (
    /* reexport */
    wS
  ),
  PDFViewer: () => (
    /* reexport */
    By
  ),
  ProgressBar: () => (
    /* reexport */
    TE
  ),
  RenderingStates: () => (
    /* reexport */
    jt
  ),
  ScrollMode: () => (
    /* reexport */
    dt
  ),
  SimpleLinkService: () => (
    /* reexport */
    jg
  ),
  SpreadMode: () => (
    /* reexport */
    Se
  ),
  StructTreeLayerBuilder: () => (
    /* reexport */
    Cy
  ),
  TextLayerBuilder: () => (
    /* reexport */
    Nu
  ),
  XfaLayerBuilder: () => (
    /* reexport */
    My
  ),
  parseQueryString: () => (
    /* reexport */
    uf
  )
});
const pE = "auto", ey = 1, vm = 1.1, gE = 0.1, mE = 10, xf = 0, vE = 1.25, bm = 40, ym = 5, jt = {
  INITIAL: 0,
  RUNNING: 1,
  PAUSED: 2,
  FINISHED: 3
}, ro = {
  UNKNOWN: 0,
  NORMAL: 1,
  CHANGING: 2,
  FULLSCREEN: 3
}, gi = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_PERMISSIONS: 2
}, dt = {
  UNKNOWN: -1,
  VERTICAL: 0,
  HORIZONTAL: 1,
  WRAPPED: 2,
  PAGE: 3
}, Se = {
  UNKNOWN: -1,
  NONE: 0,
  ODD: 1,
  EVEN: 2
};
function sy(h, e, t = !1) {
  let s = h.offsetParent;
  if (!s) {
    console.error("offsetParent is not set -- cannot scroll");
    return;
  }
  let i = h.offsetTop + h.clientTop, n = h.offsetLeft + h.clientLeft;
  for (; s.clientHeight === s.scrollHeight && s.clientWidth === s.scrollWidth || t && (s.classList.contains("markedContent") || getComputedStyle(s).overflow === "hidden"); )
    if (i += s.offsetTop, n += s.offsetLeft, s = s.offsetParent, !s)
      return;
  e && (e.top !== void 0 && (i += e.top), e.left !== void 0 && (n += e.left, s.scrollLeft = n)), s.scrollTop = i;
}
function bE(h, e, t = void 0) {
  const s = function(r) {
    n || (n = window.requestAnimationFrame(function() {
      n = null;
      const l = h.scrollLeft, c = i.lastX;
      l !== c && (i.right = l > c), i.lastX = l;
      const d = h.scrollTop, u = i.lastY;
      d !== u && (i.down = d > u), i.lastY = d, e(i);
    }));
  }, i = {
    right: !0,
    down: !0,
    lastX: h.scrollLeft,
    lastY: h.scrollTop,
    _eventHandler: s
  };
  let n = null;
  return h.addEventListener("scroll", s, {
    useCapture: !0,
    signal: t
  }), t == null || t.addEventListener("abort", () => window.cancelAnimationFrame(n), {
    once: !0
  }), i;
}
function uf(h) {
  const e = /* @__PURE__ */ new Map();
  for (const [t, s] of new URLSearchParams(h))
    e.set(t.toLowerCase(), s);
  return e;
}
const Am = /[\x00-\x1F]/g;
function uh(h, e = !1) {
  return Am.test(h) ? e ? h.replaceAll(Am, (t) => t === "\0" ? "" : " ") : h.replaceAll("\0", "") : h;
}
function yh(h, e, t = 0) {
  let s = t, i = h.length - 1;
  if (i < 0 || !e(h[i]))
    return h.length;
  if (e(h[s]))
    return s;
  for (; s < i; ) {
    const n = s + i >> 1, r = h[n];
    e(r) ? i = n : s = n + 1;
  }
  return s;
}
function wm(h) {
  if (Math.floor(h) === h)
    return [h, 1];
  const e = 1 / h, t = 8;
  if (e > t)
    return [1, t];
  if (Math.floor(e) === e)
    return [1, e];
  const s = h > 1 ? e : h;
  let i = 0, n = 1, r = 1, o = 1;
  for (; ; ) {
    const c = i + r, d = n + o;
    if (d > t)
      break;
    s <= c / d ? (r = c, o = d) : (i = c, n = d);
  }
  let l;
  return s - i / n < r / o - s ? l = s === h ? [i, n] : [n, i] : l = s === h ? [r, o] : [o, r], l;
}
function _d(h, e) {
  return h - h % e;
}
function yE(h, e, t) {
  if (h < 2)
    return h;
  let s = e[h].div, i = s.offsetTop + s.clientTop;
  i >= t && (s = e[h - 1].div, i = s.offsetTop + s.clientTop);
  for (let n = h - 2; n >= 0 && (s = e[n].div, !(s.offsetTop + s.clientTop + s.clientHeight <= i)); --n)
    h = n;
  return h;
}
function AE({
  scrollEl: h,
  views: e,
  sortByVisibility: t = !1,
  horizontal: s = !1,
  rtl: i = !1
}) {
  const n = h.scrollTop, r = n + h.clientHeight, o = h.scrollLeft, l = o + h.clientWidth;
  function c(E) {
    const S = E.div;
    return S.offsetTop + S.clientTop + S.clientHeight > n;
  }
  function d(E) {
    const S = E.div, T = S.offsetLeft + S.clientLeft, P = T + S.clientWidth;
    return i ? T < l : P > o;
  }
  const u = [], f = /* @__PURE__ */ new Set(), g = e.length;
  let m = yh(e, s ? d : c);
  m > 0 && m < g && !s && (m = yE(m, e, n));
  let y = s ? l : -1;
  for (let E = m; E < g; E++) {
    const S = e[E], T = S.div, P = T.offsetLeft + T.clientLeft, C = T.offsetTop + T.clientTop, R = T.clientWidth, _ = T.clientHeight, x = P + R, I = C + _;
    if (y === -1)
      I >= r && (y = I);
    else if ((s ? P : C) > y)
      break;
    if (I <= n || C >= r || x <= o || P >= l)
      continue;
    const L = Math.max(0, n - C) + Math.max(0, I - r), j = Math.max(0, o - P) + Math.max(0, x - l), k = (_ - L) / _, F = (R - j) / R, Y = k * F * 100 | 0;
    u.push({
      id: S.id,
      x: P,
      y: C,
      view: S,
      percent: Y,
      widthPercent: F * 100 | 0
    }), f.add(S.id);
  }
  const w = u[0], A = u.at(-1);
  return t && u.sort(function(E, S) {
    const T = E.percent - S.percent;
    return Math.abs(T) > 1e-3 ? -T : E.id - S.id;
  }), {
    first: w,
    last: A,
    views: u,
    ids: f
  };
}
function iy(h) {
  return Number.isInteger(h) && h % 90 === 0;
}
function wE(h) {
  return Number.isInteger(h) && Object.values(dt).includes(h) && h !== dt.UNKNOWN;
}
function EE(h) {
  return Number.isInteger(h) && Object.values(Se).includes(h) && h !== Se.UNKNOWN;
}
function Em(h) {
  return h.width <= h.height;
}
new Promise(function(h) {
  window.requestAnimationFrame(h);
});
const SE = document.documentElement.style;
function xE(h, e, t) {
  return Math.min(Math.max(h, e), t);
}
var Gn, Pa, Xn, fl, Ca;
class TE {
  constructor(e) {
    b(this, Gn, null);
    b(this, Pa, null);
    b(this, Xn, 0);
    b(this, fl, null);
    b(this, Ca, !0);
    p(this, Gn, e.classList), p(this, fl, e.style);
  }
  get percent() {
    return a(this, Xn);
  }
  set percent(e) {
    if (p(this, Xn, xE(e, 0, 100)), isNaN(e)) {
      a(this, Gn).add("indeterminate");
      return;
    }
    a(this, Gn).remove("indeterminate"), a(this, fl).setProperty("--progressBar-percent", `${a(this, Xn)}%`);
  }
  setWidth(e) {
    if (!e)
      return;
    const s = e.parentNode.offsetWidth - e.offsetWidth;
    s > 0 && a(this, fl).setProperty("--progressBar-end-offset", `${s}px`);
  }
  setDisableAutoFetch(e = 5e3) {
    a(this, Xn) === 100 || isNaN(a(this, Xn)) || (a(this, Pa) && clearTimeout(a(this, Pa)), this.show(), p(this, Pa, setTimeout(() => {
      p(this, Pa, null), this.hide();
    }, e)));
  }
  hide() {
    a(this, Ca) && (p(this, Ca, !1), a(this, Gn).add("hidden"));
  }
  show() {
    a(this, Ca) || (p(this, Ca, !0), a(this, Gn).remove("hidden"));
  }
}
Gn = new WeakMap(), Pa = new WeakMap(), Xn = new WeakMap(), fl = new WeakMap(), Ca = new WeakMap();
function PE(h) {
  let e = dt.VERTICAL, t = Se.NONE;
  switch (h) {
    case "SinglePage":
      e = dt.PAGE;
      break;
    case "OneColumn":
      break;
    case "TwoPageLeft":
      e = dt.PAGE;
    case "TwoColumnLeft":
      t = Se.ODD;
      break;
    case "TwoPageRight":
      e = dt.PAGE;
    case "TwoColumnRight":
      t = Se.EVEN;
      break;
  }
  return {
    scrollMode: e,
    spreadMode: t
  };
}
const Ld = function() {
  const h = document.createElement("div");
  return h.style.width = "round(down, calc(1.6666666666666665 * 792px), 1px)", h.style.width === "calc(1320px)" ? Math.fround : (e) => e;
}(), Ss = {
  SPACE: 0,
  ALPHA_LETTER: 1,
  PUNCT: 2,
  HAN_LETTER: 3,
  KATAKANA_LETTER: 4,
  HIRAGANA_LETTER: 5,
  HALFWIDTH_KATAKANA_LETTER: 6,
  THAI_LETTER: 7
};
function CE(h) {
  return h < 11904;
}
function RE(h) {
  return (h & 65408) === 0;
}
function IE(h) {
  return h >= 97 && h <= 122 || h >= 65 && h <= 90;
}
function _E(h) {
  return h >= 48 && h <= 57;
}
function LE(h) {
  return h === 32 || h === 9 || h === 13 || h === 10;
}
function ME(h) {
  return h >= 13312 && h <= 40959 || h >= 63744 && h <= 64255;
}
function OE(h) {
  return h >= 12448 && h <= 12543;
}
function NE(h) {
  return h >= 12352 && h <= 12447;
}
function DE(h) {
  return h >= 65376 && h <= 65439;
}
function kE(h) {
  return (h & 65408) === 3584;
}
function Md(h) {
  return CE(h) ? RE(h) ? LE(h) ? Ss.SPACE : IE(h) || _E(h) || h === 95 ? Ss.ALPHA_LETTER : Ss.PUNCT : kE(h) ? Ss.THAI_LETTER : h === 160 ? Ss.SPACE : Ss.ALPHA_LETTER : ME(h) ? Ss.HAN_LETTER : OE(h) ? Ss.KATAKANA_LETTER : NE(h) ? Ss.HIRAGANA_LETTER : DE(h) ? Ss.HALFWIDTH_KATAKANA_LETTER : Ss.ALPHA_LETTER;
}
let Sm;
function FE() {
  return Sm || (Sm = " ¨ª¯²-µ¸-º¼-¾Ĳ-ĳĿ-ŀŉſǄ-ǌǱ-ǳʰ-ʸ˘-˝ˠ-ˤʹͺ;΄-΅·ϐ-ϖϰ-ϲϴ-ϵϹևٵ-ٸक़-य़ড়-ঢ়য়ਲ਼ਸ਼ਖ਼-ਜ਼ਫ਼ଡ଼-ଢ଼ำຳໜ-ໝ༌གྷཌྷདྷབྷཛྷཀྵჼᴬ-ᴮᴰ-ᴺᴼ-ᵍᵏ-ᵪᵸᶛ-ᶿẚ-ẛάέήίόύώΆ᾽-῁ΈΉ῍-῏ΐΊ῝-῟ΰΎ῭-`ΌΏ´-῾ - ‑‗․-… ″-‴‶-‷‼‾⁇-⁉⁗ ⁰-ⁱ⁴-₎ₐ-ₜ₨℀-℃℅-ℇ℉-ℓℕ-№ℙ-ℝ℠-™ℤΩℨK-ℭℯ-ℱℳ-ℹ℻-⅀ⅅ-ⅉ⅐-ⅿ↉∬-∭∯-∰〈-〉①-⓪⨌⩴-⩶⫝̸ⱼ-ⱽⵯ⺟⻳⼀-⿕　〶〸-〺゛-゜ゟヿㄱ-ㆎ㆒-㆟㈀-㈞㈠-㉇㉐-㉾㊀-㏿ꚜ-ꚝꝰꟲ-ꟴꟸ-ꟹꭜ-ꭟꭩ豈-嗀塚晴凞-羽蘒諸逸-都飯-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-זּטּ-לּמּנּ-סּףּ-פּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-﷼︐-︙︰-﹄﹇-﹒﹔-﹦﹨-﹫ﹰ-ﹲﹴﹶ-ﻼ！-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ￠-￦"), Sm;
}
const un = {
  FOUND: 0,
  NOT_FOUND: 1,
  WRAPPED: 2,
  PENDING: 3
}, BE = 250, jE = -50, HE = -400, xm = {
  "‐": "-",
  "‘": "'",
  "’": "'",
  "‚": "'",
  "‛": "'",
  "“": '"',
  "”": '"',
  "„": '"',
  "‟": '"',
  "¼": "1/4",
  "½": "1/2",
  "¾": "3/4"
}, Tm = /* @__PURE__ */ new Set([12441, 12442, 2381, 2509, 2637, 2765, 2893, 3021, 3149, 3277, 3387, 3388, 3405, 3530, 3642, 3770, 3972, 4153, 4154, 5908, 5940, 6098, 6752, 6980, 7082, 7083, 7154, 7155, 11647, 43014, 43052, 43204, 43347, 43456, 43766, 44013, 3158, 3953, 3954, 3962, 3963, 3964, 3965, 3968, 3956]);
let Pm;
const $E = new RegExp("\\p{M}+", "gu"), VE = new RegExp("([.*+?^${}()|[\\]\\\\])|(\\p{P})|(\\s+)|(\\p{M})|(\\p{L})", "gu"), UE = new RegExp("([^\\p{M}])\\p{M}*$", "u"), zE = new RegExp("^\\p{M}*([^\\p{M}])", "u"), WE = /[\uAC00-\uD7AF\uFA6C\uFACF-\uFAD1\uFAD5-\uFAD7]+/g, Cm = /* @__PURE__ */ new Map(), GE = "[\\u1100-\\u1112\\ud7a4-\\ud7af\\ud84a\\ud84c\\ud850\\ud854\\ud857\\ud85f]", Rm = /* @__PURE__ */ new Map();
let Tf = null, Pf = null;
function Cf(h) {
  const e = [];
  let t;
  for (; (t = WE.exec(h)) !== null; ) {
    let {
      index: y
    } = t;
    for (const w of t[0]) {
      let A = Cm.get(w);
      A || (A = w.normalize("NFD").length, Cm.set(w, A)), e.push([A, y++]);
    }
  }
  let s;
  if (e.length === 0 && Tf)
    s = Tf;
  else if (e.length > 0 && Pf)
    s = Pf;
  else {
    const y = Object.keys(xm).join(""), w = FE(), T = `([${y}])|([${w}])|((?:゙|゚)\\n)|(\\p{M}+(?:-\\n)?)|(\\p{Ll}-\\n\\p{Lu})|(\\S-\\n)|((?:\\p{Ideographic}|[぀-ヿ])\\n)|(\\n)`;
    e.length === 0 ? s = Tf = new RegExp(T + "|(\\u0000)", "gum") : s = Pf = new RegExp(T + `|(${GE})`, "gum");
  }
  const i = [];
  for (; (t = $E.exec(h)) !== null; )
    i.push([t[0].length, t.index]);
  let n = h.normalize("NFD");
  const r = [0, 0];
  let o = 0, l = 0, c = 0, d = 0, u = 0, f = !1;
  n = n.replace(s, (y, w, A, E, S, T, P, C, R, _, x) => {
    var I, L, j;
    if (x -= d, w) {
      const k = xm[w], F = k.length;
      for (let Y = 1; Y < F; Y++)
        r.push(x - c + Y, c - Y);
      return c -= F - 1, k;
    }
    if (A) {
      let k = Rm.get(A);
      k || (k = A.normalize("NFKC"), Rm.set(A, k));
      const F = k.length;
      for (let Y = 1; Y < F; Y++)
        r.push(x - c + Y, c - Y);
      return c -= F - 1, k;
    }
    if (E)
      return f = !0, x + u === ((I = i[o]) == null ? void 0 : I[1]) ? ++o : (r.push(x - 1 - c + 1, c - 1), c -= 1, d += 1), r.push(x - c + 1, c), d += 1, u += 1, E.charAt(0);
    if (S) {
      const k = S.endsWith(`
`), F = k ? S.length - 2 : S.length;
      f = !0;
      let Y = F;
      x + u === ((L = i[o]) == null ? void 0 : L[1]) && (Y -= i[o][0], ++o);
      for (let N = 1; N <= Y; N++)
        r.push(x - 1 - c + N, c - N);
      return c -= Y, d += Y, k ? (x += F - 1, r.push(x - c + 1, 1 + c), c += 1, d += 1, u += 1, S.slice(0, F)) : S;
    }
    if (T)
      return d += 1, u += 1, T.replace(`
`, "");
    if (P) {
      const k = P.length - 2;
      return r.push(x - c + k, 1 + c), c += 1, d += 1, u += 1, P.slice(0, -2);
    }
    if (C) {
      const k = C.length - 1;
      return r.push(x - c + k, c), d += 1, u += 1, C.slice(0, -1);
    }
    if (R)
      return r.push(x - c + 1, c - 1), c -= 1, d += 1, u += 1, " ";
    if (x + u === ((j = e[l]) == null ? void 0 : j[1])) {
      const k = e[l][0] - 1;
      ++l;
      for (let F = 1; F <= k; F++)
        r.push(x - (c - F), c - F);
      c -= k, d += k;
    }
    return _;
  }), r.push(n.length, c);
  const g = new Uint32Array(r.length >> 1), m = new Int32Array(r.length >> 1);
  for (let y = 0, w = r.length; y < w; y += 2)
    g[y >> 1] = r[y], m[y >> 1] = r[y + 1];
  return [n, [g, m], f];
}
function XE(h, e, t) {
  if (!h)
    return [e, t];
  const [s, i] = h, n = e, r = e + t - 1;
  let o = yh(s, (f) => f >= n);
  s[o] > n && --o;
  let l = yh(s, (f) => f >= r, o);
  s[l] > r && --l;
  const c = n + i[o], u = r + i[l] + 1 - c;
  return [c, u];
}
var oe, pl, Ra, W, ny, Yp, Kp, ry, ay, Qp, oy, ly, pu, rh, to, hy, Zp, Jp, gu, cy, qp, tg, ah;
class YE {
  constructor({
    linkService: e,
    eventBus: t,
    updateMatchesCountOnProgress: s = !0
  }) {
    b(this, W);
    b(this, oe, null);
    b(this, pl, !0);
    b(this, Ra, 0);
    this._linkService = e, this._eventBus = t, p(this, pl, s), this.onIsPageVisible = null, v(this, W, Yp).call(this), t._on("find", v(this, W, ny).bind(this)), t._on("findbarclose", v(this, W, cy).bind(this));
  }
  get highlightMatches() {
    return this._highlightMatches;
  }
  get pageMatches() {
    return this._pageMatches;
  }
  get pageMatchesLength() {
    return this._pageMatchesLength;
  }
  get selected() {
    return this._selected;
  }
  get state() {
    return a(this, oe);
  }
  setDocument(e) {
    this._pdfDocument && v(this, W, Yp).call(this), e && (this._pdfDocument = e, this._firstPageCapability.resolve());
  }
  scrollMatchIntoView({
    element: e = null,
    selectedLeft: t = 0,
    pageIndex: s = -1,
    matchIndex: i = -1
  }) {
    if (!this._scrollMatches || !e)
      return;
    if (i === -1 || i !== this._selected.matchIdx)
      return;
    if (s === -1 || s !== this._selected.pageIdx)
      return;
    this._scrollMatches = !1;
    const n = {
      top: jE,
      left: t + HE
    };
    sy(e, n, !0);
  }
  match(e, t, s) {
    const i = this._hasDiacritics[s];
    let n = !1;
    if (typeof e == "string" ? [n, e] = v(this, W, Qp).call(this, e, i) : e = e.sort().reverse().map((u) => {
      const [f, g] = v(this, W, Qp).call(this, u, i);
      return n || (n = f), `(${g})`;
    }).join("|"), !e)
      return;
    const {
      caseSensitive: r,
      entireWord: o
    } = a(this, oe), l = `g${n ? "u" : ""}${r ? "" : "i"}`;
    e = new RegExp(e, l);
    const c = [];
    let d;
    for (; (d = e.exec(t)) !== null; )
      o && !v(this, W, ay).call(this, t, d.index, d[0].length) || c.push({
        index: d.index,
        length: d[0].length
      });
    return c;
  }
}
oe = new WeakMap(), pl = new WeakMap(), Ra = new WeakMap(), W = new WeakSet(), ny = function(e) {
  if (!e)
    return;
  const t = this._pdfDocument, {
    type: s
  } = e;
  (a(this, oe) === null || v(this, W, ry).call(this, e)) && (this._dirtyMatch = !0), p(this, oe, e), s !== "highlightallchange" && v(this, W, ah).call(this, un.PENDING), this._firstPageCapability.promise.then(() => {
    if (!this._pdfDocument || t && this._pdfDocument !== t)
      return;
    v(this, W, ly).call(this);
    const i = !this._highlightMatches, n = !!this._findTimeout;
    this._findTimeout && (clearTimeout(this._findTimeout), this._findTimeout = null), s ? this._dirtyMatch ? v(this, W, to).call(this) : s === "again" ? (v(this, W, to).call(this), i && a(this, oe).highlightAll && v(this, W, rh).call(this)) : s === "highlightallchange" ? (n ? v(this, W, to).call(this) : this._highlightMatches = !0, v(this, W, rh).call(this)) : v(this, W, to).call(this) : this._findTimeout = setTimeout(() => {
      v(this, W, to).call(this), this._findTimeout = null;
    }, BE);
  });
}, Yp = function() {
  this._highlightMatches = !1, this._scrollMatches = !1, this._pdfDocument = null, this._pageMatches = [], this._pageMatchesLength = [], p(this, Ra, 0), p(this, oe, null), this._selected = {
    pageIdx: -1,
    matchIdx: -1
  }, this._offset = {
    pageIdx: null,
    matchIdx: null,
    wrapped: !1
  }, this._extractTextPromises = [], this._pageContents = [], this._pageDiffs = [], this._hasDiacritics = [], this._matchesCountTotal = 0, this._pagesToSearch = null, this._pendingFindMatches = /* @__PURE__ */ new Set(), this._resumePageIdx = null, this._dirtyMatch = !1, clearTimeout(this._findTimeout), this._findTimeout = null, this._firstPageCapability = Promise.withResolvers();
}, Kp = function() {
  const {
    query: e
  } = a(this, oe);
  return typeof e == "string" ? (e !== this._rawQuery && (this._rawQuery = e, [this._normalizedQuery] = Cf(e)), this._normalizedQuery) : (e || []).filter((t) => !!t).map((t) => Cf(t)[0]);
}, ry = function(e) {
  var r;
  const t = e.query, s = a(this, oe).query, i = typeof t;
  if (i !== typeof s)
    return !0;
  if (i === "string") {
    if (t !== s)
      return !0;
  } else if (JSON.stringify(t) !== JSON.stringify(s))
    return !0;
  switch (e.type) {
    case "again":
      const o = this._selected.pageIdx + 1, l = this._linkService;
      return o >= 1 && o <= l.pagesCount && o !== l.page && !(((r = this.onIsPageVisible) == null ? void 0 : r.call(this, o)) ?? !0);
    case "highlightallchange":
      return !1;
  }
  return !0;
}, ay = function(e, t, s) {
  let i = e.slice(0, t).match(UE);
  if (i) {
    const n = e.charCodeAt(t), r = i[1].charCodeAt(0);
    if (Md(n) === Md(r))
      return !1;
  }
  if (i = e.slice(t + s).match(zE), i) {
    const n = e.charCodeAt(t + s - 1), r = i[1].charCodeAt(0);
    if (Md(n) === Md(r))
      return !1;
  }
  return !0;
}, Qp = function(e, t) {
  const {
    matchDiacritics: s
  } = a(this, oe);
  let i = !1;
  e = e.replaceAll(VE, (r, o, l, c, d, u) => o ? `[ ]*\\${o}[ ]*` : l ? `[ ]*${l}[ ]*` : c ? "[ ]+" : s ? d || u : d ? Tm.has(d.charCodeAt(0)) ? d : "" : t ? (i = !0, `${u}\\p{M}*`) : u);
  const n = "[ ]*";
  return e.endsWith(n) && (e = e.slice(0, e.length - n.length)), s && t && (Pm || (Pm = String.fromCharCode(...Tm)), i = !0, e = `${e}(?=[${Pm}]|[^\\p{M}]|$)`), [i, e];
}, oy = function(e) {
  const t = a(this, W, Kp);
  if (t.length === 0)
    return;
  const s = this._pageContents[e], i = this.match(t, s, e), n = this._pageMatches[e] = [], r = this._pageMatchesLength[e] = [], o = this._pageDiffs[e];
  i == null || i.forEach(({
    index: c,
    length: d
  }) => {
    const [u, f] = XE(o, c, d);
    f && (n.push(u), r.push(f));
  }), a(this, oe).highlightAll && v(this, W, pu).call(this, e), this._resumePageIdx === e && (this._resumePageIdx = null, v(this, W, Zp).call(this));
  const l = n.length;
  this._matchesCountTotal += l, a(this, pl) ? l > 0 && v(this, W, tg).call(this) : ++me(this, Ra)._ === this._linkService.pagesCount && v(this, W, tg).call(this);
}, ly = function() {
  if (this._extractTextPromises.length > 0)
    return;
  let e = Promise.resolve();
  const t = {
    disableNormalization: !0
  };
  for (let s = 0, i = this._linkService.pagesCount; s < i; s++) {
    const {
      promise: n,
      resolve: r
    } = Promise.withResolvers();
    this._extractTextPromises[s] = n, e = e.then(() => this._pdfDocument.getPage(s + 1).then((o) => o.getTextContent(t)).then((o) => {
      const l = [];
      for (const c of o.items)
        l.push(c.str), c.hasEOL && l.push(`
`);
      [this._pageContents[s], this._pageDiffs[s], this._hasDiacritics[s]] = Cf(l.join("")), r();
    }, (o) => {
      console.error(`Unable to get text content for page ${s + 1}`, o), this._pageContents[s] = "", this._pageDiffs[s] = null, this._hasDiacritics[s] = !1, r();
    }));
  }
}, pu = function(e) {
  this._scrollMatches && this._selected.pageIdx === e && (this._linkService.page = e + 1), this._eventBus.dispatch("updatetextlayermatches", {
    source: this,
    pageIndex: e
  });
}, rh = function() {
  this._eventBus.dispatch("updatetextlayermatches", {
    source: this,
    pageIndex: -1
  });
}, to = function() {
  const e = a(this, oe).findPrevious, t = this._linkService.page - 1, s = this._linkService.pagesCount;
  if (this._highlightMatches = !0, this._dirtyMatch) {
    this._dirtyMatch = !1, this._selected.pageIdx = this._selected.matchIdx = -1, this._offset.pageIdx = t, this._offset.matchIdx = null, this._offset.wrapped = !1, this._resumePageIdx = null, this._pageMatches.length = 0, this._pageMatchesLength.length = 0, p(this, Ra, 0), this._matchesCountTotal = 0, v(this, W, rh).call(this);
    for (let r = 0; r < s; r++)
      this._pendingFindMatches.has(r) || (this._pendingFindMatches.add(r), this._extractTextPromises[r].then(() => {
        this._pendingFindMatches.delete(r), v(this, W, oy).call(this, r);
      }));
  }
  if (a(this, W, Kp).length === 0) {
    v(this, W, ah).call(this, un.FOUND);
    return;
  }
  if (this._resumePageIdx)
    return;
  const n = this._offset;
  if (this._pagesToSearch = s, n.matchIdx !== null) {
    const r = this._pageMatches[n.pageIdx].length;
    if (!e && n.matchIdx + 1 < r || e && n.matchIdx > 0) {
      n.matchIdx = e ? n.matchIdx - 1 : n.matchIdx + 1, v(this, W, gu).call(this, !0);
      return;
    }
    v(this, W, Jp).call(this, e);
  }
  v(this, W, Zp).call(this);
}, hy = function(e) {
  const t = this._offset, s = e.length, i = a(this, oe).findPrevious;
  return s ? (t.matchIdx = i ? s - 1 : 0, v(this, W, gu).call(this, !0), !0) : (v(this, W, Jp).call(this, i), t.wrapped && (t.matchIdx = null, this._pagesToSearch < 0) ? (v(this, W, gu).call(this, !1), !0) : !1);
}, Zp = function() {
  this._resumePageIdx !== null && console.error("There can only be one pending page.");
  let e = null;
  do {
    const t = this._offset.pageIdx;
    if (e = this._pageMatches[t], !e) {
      this._resumePageIdx = t;
      break;
    }
  } while (!v(this, W, hy).call(this, e));
}, Jp = function(e) {
  const t = this._offset, s = this._linkService.pagesCount;
  t.pageIdx = e ? t.pageIdx - 1 : t.pageIdx + 1, t.matchIdx = null, this._pagesToSearch--, (t.pageIdx >= s || t.pageIdx < 0) && (t.pageIdx = e ? s - 1 : 0, t.wrapped = !0);
}, gu = function(e = !1) {
  let t = un.NOT_FOUND;
  const s = this._offset.wrapped;
  if (this._offset.wrapped = !1, e) {
    const i = this._selected.pageIdx;
    this._selected.pageIdx = this._offset.pageIdx, this._selected.matchIdx = this._offset.matchIdx, t = s ? un.WRAPPED : un.FOUND, i !== -1 && i !== this._selected.pageIdx && v(this, W, pu).call(this, i);
  }
  v(this, W, ah).call(this, t, a(this, oe).findPrevious), this._selected.pageIdx !== -1 && (this._scrollMatches = !0, v(this, W, pu).call(this, this._selected.pageIdx));
}, cy = function(e) {
  const t = this._pdfDocument;
  this._firstPageCapability.promise.then(() => {
    !this._pdfDocument || t && this._pdfDocument !== t || (this._findTimeout && (clearTimeout(this._findTimeout), this._findTimeout = null), this._resumePageIdx && (this._resumePageIdx = null, this._dirtyMatch = !0), v(this, W, ah).call(this, un.FOUND), this._highlightMatches = !1, v(this, W, rh).call(this));
  });
}, qp = function() {
  var n;
  const {
    pageIdx: e,
    matchIdx: t
  } = this._selected;
  let s = 0, i = this._matchesCountTotal;
  if (t !== -1) {
    for (let r = 0; r < e; r++)
      s += ((n = this._pageMatches[r]) == null ? void 0 : n.length) || 0;
    s += t + 1;
  }
  return (s < 1 || s > i) && (s = i = 0), {
    current: s,
    total: i
  };
}, tg = function() {
  this._eventBus.dispatch("updatefindmatchescount", {
    source: this,
    matchesCount: v(this, W, qp).call(this)
  });
}, ah = function(e, t = !1) {
  var s, i;
  !a(this, pl) && (a(this, Ra) !== this._linkService.pagesCount || e === un.PENDING) || this._eventBus.dispatch("updatefindcontrolstate", {
    source: this,
    state: e,
    previous: t,
    entireWord: ((s = a(this, oe)) == null ? void 0 : s.entireWord) ?? null,
    matchesCount: v(this, W, qp).call(this),
    rawQuery: ((i = a(this, oe)) == null ? void 0 : i.query) ?? null
  });
};
const KE = "noopener noreferrer nofollow", vr = {
  NONE: 0,
  SELF: 1,
  BLANK: 2,
  PARENT: 3,
  TOP: 4
};
var tf, dy;
const ef = class ef {
  constructor({
    eventBus: e,
    externalLinkTarget: t = null,
    externalLinkRel: s = null,
    ignoreDestinationZoom: i = !1
  } = {}) {
    K(this, "externalLinkEnabled", !0);
    this.eventBus = e, this.externalLinkTarget = t, this.externalLinkRel = s, this._ignoreDestinationZoom = i, this.baseUrl = null, this.pdfDocument = null, this.pdfViewer = null, this.pdfHistory = null;
  }
  setDocument(e, t = null) {
    this.baseUrl = t, this.pdfDocument = e;
  }
  setViewer(e) {
    this.pdfViewer = e;
  }
  setHistory(e) {
    this.pdfHistory = e;
  }
  get pagesCount() {
    return this.pdfDocument ? this.pdfDocument.numPages : 0;
  }
  get page() {
    return this.pdfDocument ? this.pdfViewer.currentPageNumber : 1;
  }
  set page(e) {
    this.pdfDocument && (this.pdfViewer.currentPageNumber = e);
  }
  get rotation() {
    return this.pdfDocument ? this.pdfViewer.pagesRotation : 0;
  }
  set rotation(e) {
    this.pdfDocument && (this.pdfViewer.pagesRotation = e);
  }
  get isInPresentationMode() {
    return this.pdfDocument ? this.pdfViewer.isInPresentationMode : !1;
  }
  async goToDestination(e) {
    if (!this.pdfDocument)
      return;
    let t, s, i;
    if (typeof e == "string" ? (t = e, s = await this.pdfDocument.getDestination(e)) : (t = null, s = await e), !Array.isArray(s)) {
      console.error(`goToDestination: "${s}" is not a valid destination array, for dest="${e}".`);
      return;
    }
    const [n] = s;
    if (n && typeof n == "object") {
      if (i = this.pdfDocument.cachedPageNumber(n), !i)
        try {
          i = await this.pdfDocument.getPageIndex(n) + 1;
        } catch {
          console.error(`goToDestination: "${n}" is not a valid page reference, for dest="${e}".`);
          return;
        }
    } else Number.isInteger(n) && (i = n + 1);
    if (!i || i < 1 || i > this.pagesCount) {
      console.error(`goToDestination: "${i}" is not a valid page number, for dest="${e}".`);
      return;
    }
    this.pdfHistory && (this.pdfHistory.pushCurrentPosition(), this.pdfHistory.push({
      namedDest: t,
      explicitDest: s,
      pageNumber: i
    })), this.pdfViewer.scrollPageIntoView({
      pageNumber: i,
      destArray: s,
      ignoreDestinationZoom: this._ignoreDestinationZoom
    });
  }
  goToPage(e) {
    if (!this.pdfDocument)
      return;
    const t = typeof e == "string" && this.pdfViewer.pageLabelToPageNumber(e) || e | 0;
    if (!(Number.isInteger(t) && t > 0 && t <= this.pagesCount)) {
      console.error(`PDFLinkService.goToPage: "${e}" is not a valid page.`);
      return;
    }
    this.pdfHistory && (this.pdfHistory.pushCurrentPosition(), this.pdfHistory.pushPage(t)), this.pdfViewer.scrollPageIntoView({
      pageNumber: t
    });
  }
  addLinkAttributes(e, t, s = !1) {
    if (!t || typeof t != "string")
      throw new Error('A valid "url" parameter must provided.');
    const i = s ? vr.BLANK : this.externalLinkTarget, n = this.externalLinkRel;
    this.externalLinkEnabled ? e.href = e.title = t : (e.href = "", e.title = `Disabled: ${t}`, e.onclick = () => !1);
    let r = "";
    switch (i) {
      case vr.NONE:
        break;
      case vr.SELF:
        r = "_self";
        break;
      case vr.BLANK:
        r = "_blank";
        break;
      case vr.PARENT:
        r = "_parent";
        break;
      case vr.TOP:
        r = "_top";
        break;
    }
    e.target = r, e.rel = typeof n == "string" ? n : KE;
  }
  getDestinationHash(e) {
    if (typeof e == "string") {
      if (e.length > 0)
        return this.getAnchorUrl("#" + escape(e));
    } else if (Array.isArray(e)) {
      const t = JSON.stringify(e);
      if (t.length > 0)
        return this.getAnchorUrl("#" + escape(t));
    }
    return this.getAnchorUrl("");
  }
  getAnchorUrl(e) {
    return this.baseUrl ? this.baseUrl + e : e;
  }
  setHash(e) {
    var i;
    if (!this.pdfDocument)
      return;
    let t, s;
    if (e.includes("=")) {
      const n = uf(e);
      if (n.has("search")) {
        const r = n.get("search").replaceAll('"', ""), o = n.get("phrase") === "true";
        this.eventBus.dispatch("findfromurlhash", {
          source: this,
          query: o ? r : r.match(/\S+/g)
        });
      }
      if (n.has("page") && (t = n.get("page") | 0 || 1), n.has("zoom")) {
        const r = n.get("zoom").split(","), o = r[0], l = parseFloat(o);
        o.includes("Fit") ? o === "Fit" || o === "FitB" ? s = [null, {
          name: o
        }] : o === "FitH" || o === "FitBH" || o === "FitV" || o === "FitBV" ? s = [null, {
          name: o
        }, r.length > 1 ? r[1] | 0 : null] : o === "FitR" ? r.length !== 5 ? console.error('PDFLinkService.setHash: Not enough parameters for "FitR".') : s = [null, {
          name: o
        }, r[1] | 0, r[2] | 0, r[3] | 0, r[4] | 0] : console.error(`PDFLinkService.setHash: "${o}" is not a valid zoom value.`) : s = [null, {
          name: "XYZ"
        }, r.length > 1 ? r[1] | 0 : null, r.length > 2 ? r[2] | 0 : null, l ? l / 100 : o];
      }
      s ? this.pdfViewer.scrollPageIntoView({
        pageNumber: t || this.page,
        destArray: s,
        allowNegativeOffset: !0
      }) : t && (this.page = t), n.has("pagemode") && this.eventBus.dispatch("pagemode", {
        source: this,
        mode: n.get("pagemode")
      }), n.has("nameddest") && this.goToDestination(n.get("nameddest"));
      return;
    }
    s = unescape(e);
    try {
      s = JSON.parse(s), Array.isArray(s) || (s = s.toString());
    } catch {
    }
    if (typeof s == "string" || v(i = ef, tf, dy).call(i, s)) {
      this.goToDestination(s);
      return;
    }
    console.error(`PDFLinkService.setHash: "${unescape(e)}" is not a valid destination.`);
  }
  executeNamedAction(e) {
    var t, s;
    if (this.pdfDocument) {
      switch (e) {
        case "GoBack":
          (t = this.pdfHistory) == null || t.back();
          break;
        case "GoForward":
          (s = this.pdfHistory) == null || s.forward();
          break;
        case "NextPage":
          this.pdfViewer.nextPage();
          break;
        case "PrevPage":
          this.pdfViewer.previousPage();
          break;
        case "LastPage":
          this.page = this.pagesCount;
          break;
        case "FirstPage":
          this.page = 1;
          break;
      }
      this.eventBus.dispatch("namedaction", {
        source: this,
        action: e
      });
    }
  }
  async executeSetOCGState(e) {
    if (!this.pdfDocument)
      return;
    const t = this.pdfDocument, s = await this.pdfViewer.optionalContentConfigPromise;
    t === this.pdfDocument && (s.setOCGState(e), this.pdfViewer.optionalContentConfigPromise = Promise.resolve(s));
  }
};
tf = new WeakSet(), dy = function(e) {
  if (!Array.isArray(e) || e.length < 2)
    return !1;
  const [t, s, ...i] = e;
  if (!(typeof t == "object" && Number.isInteger(t == null ? void 0 : t.num) && Number.isInteger(t == null ? void 0 : t.gen)) && !Number.isInteger(t) || !(typeof s == "object" && typeof (s == null ? void 0 : s.name) == "string"))
    return !1;
  const n = i.length;
  let r = !0;
  switch (s.name) {
    case "XYZ":
      if (n < 2 || n > 3)
        return !1;
      break;
    case "Fit":
    case "FitB":
      return n === 0;
    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (n > 1)
        return !1;
      break;
    case "FitR":
      if (n !== 4)
        return !1;
      r = !1;
      break;
    default:
      return !1;
  }
  for (const o of i)
    if (!(typeof o == "number" || r && o === null))
      return !1;
  return !0;
}, b(ef, tf);
let Lu = ef;
class jg extends Lu {
  setDocument(e, t = null) {
  }
}
const {
  AbortException: QE,
  AnnotationEditorLayer: ZE,
  AnnotationEditorParamsType: zS,
  AnnotationEditorType: We,
  AnnotationEditorUIManager: JE,
  AnnotationLayer: qE,
  AnnotationMode: nn,
  build: WS,
  ColorPicker: GS,
  createValidAbsoluteUrl: t0,
  DOMSVGFactory: XS,
  DrawLayer: e0,
  FeatureTest: YS,
  fetchData: Im,
  getDocument: KS,
  getFilenameFromUrl: QS,
  getPdfFilenameFromUrl: s0,
  getXfaPageViewport: ZS,
  GlobalWorkerOptions: JS,
  ImageKind: qS,
  InvalidPDFException: tx,
  isDataScheme: ex,
  isPdfFile: i0,
  MissingPDFException: sx,
  noContextMenu: ix,
  normalizeUnicode: n0,
  OPS: nx,
  OutputScale: r0,
  PasswordResponses: rx,
  PDFDataRangeTransport: ax,
  PDFDateString: ox,
  PDFWorker: lx,
  PermissionFlag: Od,
  PixelsPerInch: Pi,
  RenderingCancelledException: eg,
  setLayerDimensions: a0,
  shadow: Mu,
  stopEvent: sg,
  TextLayer: o0,
  TouchManager: hx,
  UnexpectedResponseException: cx,
  Util: dx,
  VerbosityLevel: ux,
  version: _m,
  XfaLayer: Rf
} = globalThis.pdfjsLib;
var Gc, Yn, Xc, ig;
class uy {
  constructor({
    pdfPage: e,
    linkService: t,
    downloadManager: s,
    annotationStorage: i = null,
    imageResourcesPath: n = "",
    renderForms: r = !0,
    enableScripting: o = !1,
    hasJSActionsPromise: l = null,
    fieldObjectsPromise: c = null,
    annotationCanvasMap: d = null,
    accessibilityManager: u = null,
    annotationEditorUIManager: f = null,
    onAppend: g = null
  }) {
    b(this, Xc);
    b(this, Gc, null);
    b(this, Yn, null);
    this.pdfPage = e, this.linkService = t, this.downloadManager = s, this.imageResourcesPath = n, this.renderForms = r, this.annotationStorage = i, this.enableScripting = o, this._hasJSActionsPromise = l || Promise.resolve(!1), this._fieldObjectsPromise = c || Promise.resolve(null), this._annotationCanvasMap = d, this._accessibilityManager = u, this._annotationEditorUIManager = f, p(this, Gc, g), this.annotationLayer = null, this.div = null, this._cancelled = !1, this._eventBus = t.eventBus;
  }
  async render(e, t, s = "display") {
    var l, c;
    if (this.div) {
      if (this._cancelled || !this.annotationLayer)
        return;
      this.annotationLayer.update({
        viewport: e.clone({
          dontFlip: !0
        })
      });
      return;
    }
    const [i, n, r] = await Promise.all([this.pdfPage.getAnnotations({
      intent: s
    }), this._hasJSActionsPromise, this._fieldObjectsPromise]);
    if (this._cancelled)
      return;
    const o = this.div = document.createElement("div");
    if (o.className = "annotationLayer", (l = a(this, Gc)) == null || l.call(this, o), i.length === 0) {
      this.hide();
      return;
    }
    this.annotationLayer = new qE({
      div: o,
      accessibilityManager: this._accessibilityManager,
      annotationCanvasMap: this._annotationCanvasMap,
      annotationEditorUIManager: this._annotationEditorUIManager,
      page: this.pdfPage,
      viewport: e.clone({
        dontFlip: !0
      }),
      structTreeLayer: (t == null ? void 0 : t.structTreeLayer) || null
    }), await this.annotationLayer.render({
      annotations: i,
      imageResourcesPath: this.imageResourcesPath,
      renderForms: this.renderForms,
      linkService: this.linkService,
      downloadManager: this.downloadManager,
      annotationStorage: this.annotationStorage,
      enableScripting: this.enableScripting,
      hasJSActions: n,
      fieldObjects: r
    }), this.linkService.isInPresentationMode && v(this, Xc, ig).call(this, ro.FULLSCREEN), a(this, Yn) || (p(this, Yn, new AbortController()), (c = this._eventBus) == null || c._on("presentationmodechanged", (d) => {
      v(this, Xc, ig).call(this, d.state);
    }, {
      signal: a(this, Yn).signal
    }));
  }
  cancel() {
    var e;
    this._cancelled = !0, (e = a(this, Yn)) == null || e.abort(), p(this, Yn, null);
  }
  hide() {
    this.div && (this.div.hidden = !0);
  }
  hasEditableAnnotations() {
    var e;
    return !!((e = this.annotationLayer) != null && e.hasEditableAnnotations());
  }
}
Gc = new WeakMap(), Yn = new WeakMap(), Xc = new WeakSet(), ig = function(e) {
  if (!this.div)
    return;
  let t = !1;
  switch (e) {
    case ro.FULLSCREEN:
      t = !0;
      break;
    case ro.NORMAL:
      break;
    default:
      return;
  }
  for (const s of this.div.childNodes)
    s.hasAttribute("data-internal-link") || (s.inert = t);
};
function Lm(h, e) {
  const t = document.createElement("a");
  if (!t.click)
    throw new Error('DownloadManager: "a.click()" is not supported.');
  t.href = h, t.target = "_parent", "download" in t && (t.download = e), (document.body || document.documentElement).append(t), t.click(), t.remove();
}
var Ig;
class l0 {
  constructor() {
    b(this, Ig, /* @__PURE__ */ new WeakMap());
  }
  downloadData(e, t, s) {
    const i = URL.createObjectURL(new Blob([e], {
      type: s
    }));
    Lm(i, t);
  }
  openOrDownloadData(e, t, s = null) {
    const n = i0(t) ? "application/pdf" : "";
    return this.downloadData(e, t, n), !1;
  }
  download(e, t, s) {
    let i;
    if (e)
      i = URL.createObjectURL(new Blob([e], {
        type: "application/pdf"
      }));
    else {
      if (!t0(t, "http://example.com")) {
        console.error(`download - not a valid URL: ${t}`);
        return;
      }
      i = t + "#pdfjs.action=download";
    }
    Lm(i, s);
  }
}
Ig = new WeakMap();
const Mm = {
  EVENT: "event",
  TIMEOUT: "timeout"
};
async function h0({
  target: h,
  name: e,
  delay: t = 0
}) {
  if (typeof h != "object" || !(e && typeof e == "string") || !(Number.isInteger(t) && t >= 0))
    throw new Error("waitOnEventOrTimeout - invalid parameters.");
  const {
    promise: s,
    resolve: i
  } = Promise.withResolvers(), n = new AbortController();
  function r(c) {
    n.abort(), clearTimeout(l), i(c);
  }
  const o = h instanceof fy ? "_on" : "addEventListener";
  h[o](e, r.bind(null, Mm.EVENT), {
    signal: n.signal
  });
  const l = setTimeout(r.bind(null, Mm.TIMEOUT), t);
  return s;
}
var gl;
class fy {
  constructor() {
    b(this, gl, /* @__PURE__ */ Object.create(null));
  }
  on(e, t, s = null) {
    this._on(e, t, {
      external: !0,
      once: s == null ? void 0 : s.once,
      signal: s == null ? void 0 : s.signal
    });
  }
  off(e, t, s = null) {
    this._off(e, t);
  }
  dispatch(e, t) {
    const s = a(this, gl)[e];
    if (!s || s.length === 0)
      return;
    let i;
    for (const {
      listener: n,
      external: r,
      once: o
    } of s.slice(0)) {
      if (o && this._off(e, n), r) {
        (i || (i = [])).push(n);
        continue;
      }
      n(t);
    }
    if (i) {
      for (const n of i)
        n(t);
      i = null;
    }
  }
  _on(e, t, s = null) {
    var r;
    let i = null;
    if ((s == null ? void 0 : s.signal) instanceof AbortSignal) {
      const {
        signal: o
      } = s;
      if (o.aborted) {
        console.error("Cannot use an `aborted` signal.");
        return;
      }
      const l = () => this._off(e, t);
      i = () => o.removeEventListener("abort", l), o.addEventListener("abort", l);
    }
    ((r = a(this, gl))[e] || (r[e] = [])).push({
      listener: t,
      external: (s == null ? void 0 : s.external) === !0,
      once: (s == null ? void 0 : s.once) === !0,
      rmAbort: i
    });
  }
  _off(e, t, s = null) {
    var n;
    const i = a(this, gl)[e];
    if (i)
      for (let r = 0, o = i.length; r < o; r++) {
        const l = i[r];
        if (l.listener === t) {
          (n = l.rmAbort) == null || n.call(l), i.splice(r, 1);
          return;
        }
      }
  }
}
gl = new WeakMap();
class ff {
  constructor(e) {
    this.value = e;
  }
  valueOf() {
    return this.value;
  }
}
class Gt extends ff {
  constructor(e = "???") {
    super(e);
  }
  toString(e) {
    return `{${this.value}}`;
  }
}
class an extends ff {
  constructor(e, t = {}) {
    super(e), this.opts = t;
  }
  toString(e) {
    try {
      return e.memoizeIntlObject(Intl.NumberFormat, this.opts).format(this.value);
    } catch (t) {
      return e.reportError(t), this.value.toString(10);
    }
  }
}
class fh extends ff {
  constructor(e, t = {}) {
    super(e), this.opts = t;
  }
  toString(e) {
    try {
      return e.memoizeIntlObject(Intl.DateTimeFormat, this.opts).format(this.value);
    } catch (t) {
      return e.reportError(t), new Date(this.value).toISOString();
    }
  }
}
const Om = 100, c0 = "⁨", d0 = "⁩";
function u0(h, e, t) {
  if (t === e || t instanceof an && e instanceof an && t.value === e.value)
    return !0;
  if (e instanceof an && typeof t == "string") {
    let s = h.memoizeIntlObject(Intl.PluralRules, e.opts).select(e.value);
    if (t === s)
      return !0;
  }
  return !1;
}
function Nm(h, e, t) {
  return e[t] ? Ml(h, e[t].value) : (h.reportError(new RangeError("No default")), new Gt());
}
function ng(h, e) {
  const t = [], s = /* @__PURE__ */ Object.create(null);
  for (const i of e)
    i.type === "narg" ? s[i.name] = Ah(h, i.value) : t.push(Ah(h, i));
  return {
    positional: t,
    named: s
  };
}
function Ah(h, e) {
  switch (e.type) {
    case "str":
      return e.value;
    case "num":
      return new an(e.value, {
        minimumFractionDigits: e.precision
      });
    case "var":
      return f0(h, e);
    case "mesg":
      return p0(h, e);
    case "term":
      return g0(h, e);
    case "func":
      return m0(h, e);
    case "select":
      return v0(h, e);
    default:
      return new Gt();
  }
}
function f0(h, {
  name: e
}) {
  let t;
  if (h.params)
    if (Object.prototype.hasOwnProperty.call(h.params, e))
      t = h.params[e];
    else
      return new Gt(`$${e}`);
  else if (h.args && Object.prototype.hasOwnProperty.call(h.args, e))
    t = h.args[e];
  else
    return h.reportError(new ReferenceError(`Unknown variable: $${e}`)), new Gt(`$${e}`);
  if (t instanceof ff)
    return t;
  switch (typeof t) {
    case "string":
      return t;
    case "number":
      return new an(t);
    case "object":
      if (t instanceof Date)
        return new fh(t.getTime());
    default:
      return h.reportError(new TypeError(`Variable type not supported: $${e}, ${typeof t}`)), new Gt(`$${e}`);
  }
}
function p0(h, {
  name: e,
  attr: t
}) {
  const s = h.bundle._messages.get(e);
  if (!s)
    return h.reportError(new ReferenceError(`Unknown message: ${e}`)), new Gt(e);
  if (t) {
    const i = s.attributes[t];
    return i ? Ml(h, i) : (h.reportError(new ReferenceError(`Unknown attribute: ${t}`)), new Gt(`${e}.${t}`));
  }
  return s.value ? Ml(h, s.value) : (h.reportError(new ReferenceError(`No value: ${e}`)), new Gt(e));
}
function g0(h, {
  name: e,
  attr: t,
  args: s
}) {
  const i = `-${e}`, n = h.bundle._terms.get(i);
  if (!n)
    return h.reportError(new ReferenceError(`Unknown term: ${i}`)), new Gt(i);
  if (t) {
    const o = n.attributes[t];
    if (o) {
      h.params = ng(h, s).named;
      const l = Ml(h, o);
      return h.params = null, l;
    }
    return h.reportError(new ReferenceError(`Unknown attribute: ${t}`)), new Gt(`${i}.${t}`);
  }
  h.params = ng(h, s).named;
  const r = Ml(h, n.value);
  return h.params = null, r;
}
function m0(h, {
  name: e,
  args: t
}) {
  let s = h.bundle._functions[e];
  if (!s)
    return h.reportError(new ReferenceError(`Unknown function: ${e}()`)), new Gt(`${e}()`);
  if (typeof s != "function")
    return h.reportError(new TypeError(`Function ${e}() is not callable`)), new Gt(`${e}()`);
  try {
    let i = ng(h, t);
    return s(i.positional, i.named);
  } catch (i) {
    return h.reportError(i), new Gt(`${e}()`);
  }
}
function v0(h, {
  selector: e,
  variants: t,
  star: s
}) {
  let i = Ah(h, e);
  if (i instanceof Gt)
    return Nm(h, t, s);
  for (const n of t) {
    const r = Ah(h, n.key);
    if (u0(h, i, r))
      return Ml(h, n.value);
  }
  return Nm(h, t, s);
}
function py(h, e) {
  if (h.dirty.has(e))
    return h.reportError(new RangeError("Cyclic reference")), new Gt();
  h.dirty.add(e);
  const t = [], s = h.bundle._useIsolating && e.length > 1;
  for (const i of e) {
    if (typeof i == "string") {
      t.push(h.bundle._transform(i));
      continue;
    }
    if (h.placeables++, h.placeables > Om)
      throw h.dirty.delete(e), new RangeError(`Too many placeables expanded: ${h.placeables}, max allowed is ${Om}`);
    s && t.push(c0), t.push(Ah(h, i).toString(h)), s && t.push(d0);
  }
  return h.dirty.delete(e), t.join("");
}
function Ml(h, e) {
  return typeof e == "string" ? h.bundle._transform(e) : py(h, e);
}
class b0 {
  constructor(e, t, s) {
    this.dirty = /* @__PURE__ */ new WeakSet(), this.params = null, this.placeables = 0, this.bundle = e, this.errors = t, this.args = s;
  }
  reportError(e) {
    if (!this.errors || !(e instanceof Error))
      throw e;
    this.errors.push(e);
  }
  memoizeIntlObject(e, t) {
    let s = this.bundle._intls.get(e);
    s || (s = {}, this.bundle._intls.set(e, s));
    let i = JSON.stringify(t);
    return s[i] || (s[i] = new e(this.bundle.locales, t)), s[i];
  }
}
function Ou(h, e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const [s, i] of Object.entries(h))
    e.includes(s) && (t[s] = i.valueOf());
  return t;
}
const Dm = ["unitDisplay", "currencyDisplay", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits"];
function y0(h, e) {
  let t = h[0];
  if (t instanceof Gt)
    return new Gt(`NUMBER(${t.valueOf()})`);
  if (t instanceof an)
    return new an(t.valueOf(), {
      ...t.opts,
      ...Ou(e, Dm)
    });
  if (t instanceof fh)
    return new an(t.valueOf(), {
      ...Ou(e, Dm)
    });
  throw new TypeError("Invalid argument to NUMBER");
}
const km = ["dateStyle", "timeStyle", "fractionalSecondDigits", "dayPeriod", "hour12", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName"];
function A0(h, e) {
  let t = h[0];
  if (t instanceof Gt)
    return new Gt(`DATETIME(${t.valueOf()})`);
  if (t instanceof fh)
    return new fh(t.valueOf(), {
      ...t.opts,
      ...Ou(e, km)
    });
  if (t instanceof an)
    return new fh(t.valueOf(), {
      ...Ou(e, km)
    });
  throw new TypeError("Invalid argument to DATETIME");
}
const Fm = /* @__PURE__ */ new Map();
function w0(h) {
  const e = Array.isArray(h) ? h.join(" ") : h;
  let t = Fm.get(e);
  return t === void 0 && (t = /* @__PURE__ */ new Map(), Fm.set(e, t)), t;
}
class E0 {
  constructor(e, {
    functions: t,
    useIsolating: s = !0,
    transform: i = (n) => n
  } = {}) {
    this._terms = /* @__PURE__ */ new Map(), this._messages = /* @__PURE__ */ new Map(), this.locales = Array.isArray(e) ? e : [e], this._functions = {
      NUMBER: y0,
      DATETIME: A0,
      ...t
    }, this._useIsolating = s, this._transform = i, this._intls = w0(e);
  }
  hasMessage(e) {
    return this._messages.has(e);
  }
  getMessage(e) {
    return this._messages.get(e);
  }
  addResource(e, {
    allowOverrides: t = !1
  } = {}) {
    const s = [];
    for (let i = 0; i < e.body.length; i++) {
      let n = e.body[i];
      if (n.id.startsWith("-")) {
        if (t === !1 && this._terms.has(n.id)) {
          s.push(new Error(`Attempt to override an existing term: "${n.id}"`));
          continue;
        }
        this._terms.set(n.id, n);
      } else {
        if (t === !1 && this._messages.has(n.id)) {
          s.push(new Error(`Attempt to override an existing message: "${n.id}"`));
          continue;
        }
        this._messages.set(n.id, n);
      }
    }
    return s;
  }
  formatPattern(e, t = null, s = null) {
    if (typeof e == "string")
      return this._transform(e);
    let i = new b0(this, s, t);
    try {
      return py(i, e).toString(i);
    } catch (n) {
      if (i.errors && n instanceof Error)
        return i.errors.push(n), new Gt().toString(i);
      throw n;
    }
  }
}
const If = /^(-?[a-zA-Z][\w-]*) *= */gm, Bm = /\.([a-zA-Z][\w-]*) *= */y, S0 = /\*?\[/y, _f = /(-?[0-9]+(?:\.([0-9]+))?)/y, x0 = /([a-zA-Z][\w-]*)/y, jm = /([$-])?([a-zA-Z][\w-]*)(?:\.([a-zA-Z][\w-]*))?/y, T0 = /^[A-Z][A-Z0-9_-]*$/, Nd = /([^{}\n\r]+)/y, P0 = /([^\\"\n\r]*)/y, Hm = /\\([\\"])/y, $m = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{6})/y, C0 = /^\n+/, Vm = / +$/, R0 = / *\r?\n/g, I0 = /( *)$/, _0 = /{\s*/y, Um = /\s*}/y, L0 = /\[\s*/y, M0 = /\s*] */y, O0 = /\s*\(\s*/y, N0 = /\s*->\s*/y, D0 = /\s*:\s*/y, k0 = /\s*,?\s*/y, F0 = /\s+/y;
class B0 {
  constructor(e) {
    this.body = [], If.lastIndex = 0;
    let t = 0;
    for (; ; ) {
      let x = If.exec(e);
      if (x === null)
        break;
      t = If.lastIndex;
      try {
        this.body.push(l(x[1]));
      } catch (I) {
        if (I instanceof SyntaxError)
          continue;
        throw I;
      }
    }
    function s(x) {
      return x.lastIndex = t, x.test(e);
    }
    function i(x, I) {
      if (e[t] === x)
        return t++, !0;
      if (I)
        throw new I(`Expected ${x}`);
      return !1;
    }
    function n(x, I) {
      if (s(x))
        return t = x.lastIndex, !0;
      if (I)
        throw new I(`Expected ${x.toString()}`);
      return !1;
    }
    function r(x) {
      x.lastIndex = t;
      let I = x.exec(e);
      if (I === null)
        throw new SyntaxError(`Expected ${x.toString()}`);
      return t = x.lastIndex, I;
    }
    function o(x) {
      return r(x)[1];
    }
    function l(x) {
      let I = d(), L = c();
      if (I === null && Object.keys(L).length === 0)
        throw new SyntaxError("Expected message value or attributes");
      return {
        id: x,
        value: I,
        attributes: L
      };
    }
    function c() {
      let x = /* @__PURE__ */ Object.create(null);
      for (; s(Bm); ) {
        let I = o(Bm), L = d();
        if (L === null)
          throw new SyntaxError("Expected attribute value");
        x[I] = L;
      }
      return x;
    }
    function d() {
      let x;
      if (s(Nd) && (x = o(Nd)), e[t] === "{" || e[t] === "}")
        return u(x ? [x] : [], 1 / 0);
      let I = C();
      return I ? x ? u([x, I], I.length) : (I.value = R(I.value, C0), u([I], I.length)) : x ? R(x, Vm) : null;
    }
    function u(x = [], I) {
      for (; ; ) {
        if (s(Nd)) {
          x.push(o(Nd));
          continue;
        }
        if (e[t] === "{") {
          x.push(f());
          continue;
        }
        if (e[t] === "}")
          throw new SyntaxError("Unbalanced closing brace");
        let F = C();
        if (F) {
          x.push(F), I = Math.min(I, F.length);
          continue;
        }
        break;
      }
      let L = x.length - 1, j = x[L];
      typeof j == "string" && (x[L] = R(j, Vm));
      let k = [];
      for (let F of x)
        F instanceof zm && (F = F.value.slice(0, F.value.length - I)), F && k.push(F);
      return k;
    }
    function f() {
      n(_0, SyntaxError);
      let x = g();
      if (n(Um))
        return x;
      if (n(N0)) {
        let I = w();
        return n(Um, SyntaxError), {
          type: "select",
          selector: x,
          ...I
        };
      }
      throw new SyntaxError("Unclosed placeable");
    }
    function g() {
      if (e[t] === "{")
        return f();
      if (s(jm)) {
        let [, x, I, L = null] = r(jm);
        if (x === "$")
          return {
            type: "var",
            name: I
          };
        if (n(O0)) {
          let j = m();
          if (x === "-")
            return {
              type: "term",
              name: I,
              attr: L,
              args: j
            };
          if (T0.test(I))
            return {
              type: "func",
              name: I,
              args: j
            };
          throw new SyntaxError("Function names must be all upper-case");
        }
        return x === "-" ? {
          type: "term",
          name: I,
          attr: L,
          args: []
        } : {
          type: "mesg",
          name: I,
          attr: L
        };
      }
      return E();
    }
    function m() {
      let x = [];
      for (; ; ) {
        switch (e[t]) {
          case ")":
            return t++, x;
          case void 0:
            throw new SyntaxError("Unclosed argument list");
        }
        x.push(y()), n(k0);
      }
    }
    function y() {
      let x = g();
      return x.type !== "mesg" ? x : n(D0) ? {
        type: "narg",
        name: x.name,
        value: E()
      } : x;
    }
    function w() {
      let x = [], I = 0, L;
      for (; s(S0); ) {
        i("*") && (L = I);
        let j = A(), k = d();
        if (k === null)
          throw new SyntaxError("Expected variant value");
        x[I++] = {
          key: j,
          value: k
        };
      }
      if (I === 0)
        return null;
      if (L === void 0)
        throw new SyntaxError("Expected default variant");
      return {
        variants: x,
        star: L
      };
    }
    function A() {
      n(L0, SyntaxError);
      let x;
      return s(_f) ? x = S() : x = {
        type: "str",
        value: o(x0)
      }, n(M0, SyntaxError), x;
    }
    function E() {
      if (s(_f))
        return S();
      if (e[t] === '"')
        return T();
      throw new SyntaxError("Invalid expression");
    }
    function S() {
      let [, x, I = ""] = r(_f), L = I.length;
      return {
        type: "num",
        value: parseFloat(x),
        precision: L
      };
    }
    function T() {
      i('"', SyntaxError);
      let x = "";
      for (; ; ) {
        if (x += o(P0), e[t] === "\\") {
          x += P();
          continue;
        }
        if (i('"'))
          return {
            type: "str",
            value: x
          };
        throw new SyntaxError("Unclosed string literal");
      }
    }
    function P() {
      if (s(Hm))
        return o(Hm);
      if (s($m)) {
        let [, x, I] = r($m), L = parseInt(x || I, 16);
        return L <= 55295 || 57344 <= L ? String.fromCodePoint(L) : "�";
      }
      throw new SyntaxError("Unknown escape sequence");
    }
    function C() {
      let x = t;
      switch (n(F0), e[t]) {
        case ".":
        case "[":
        case "*":
        case "}":
        case void 0:
          return !1;
        case "{":
          return _(e.slice(x, t));
      }
      return e[t - 1] === " " ? _(e.slice(x, t)) : !1;
    }
    function R(x, I) {
      return x.replace(I, "");
    }
    function _(x) {
      let I = x.replace(R0, `
`), L = I0.exec(x)[1].length;
      return new zm(I, L);
    }
  }
}
class zm {
  constructor(e, t) {
    this.value = e, this.length = t;
  }
}
const j0 = /<|&#?\w+;/, H0 = {
  "http://www.w3.org/1999/xhtml": ["em", "strong", "small", "s", "cite", "q", "dfn", "abbr", "data", "time", "code", "var", "samp", "kbd", "sub", "sup", "i", "b", "u", "mark", "bdi", "bdo", "span", "br", "wbr"]
}, $0 = {
  "http://www.w3.org/1999/xhtml": {
    global: ["title", "aria-label", "aria-valuetext"],
    a: ["download"],
    area: ["download", "alt"],
    input: ["alt", "placeholder"],
    menuitem: ["label"],
    menu: ["label"],
    optgroup: ["label"],
    option: ["label"],
    track: ["label"],
    img: ["alt"],
    textarea: ["placeholder"],
    th: ["abbr"]
  },
  "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul": {
    global: ["accesskey", "aria-label", "aria-valuetext", "label", "title", "tooltiptext"],
    description: ["value"],
    key: ["key", "keycode"],
    label: ["value"],
    textbox: ["placeholder", "value"]
  }
};
function V0(h, e) {
  const {
    value: t
  } = e;
  if (typeof t == "string")
    if (h.localName === "title" && h.namespaceURI === "http://www.w3.org/1999/xhtml")
      h.textContent = t;
    else if (!j0.test(t))
      h.textContent = t;
    else {
      const s = h.ownerDocument.createElementNS("http://www.w3.org/1999/xhtml", "template");
      s.innerHTML = t, U0(s.content, h);
    }
  gy(e, h);
}
function U0(h, e) {
  for (const t of h.childNodes)
    if (t.nodeType !== t.TEXT_NODE) {
      if (t.hasAttribute("data-l10n-name")) {
        const s = W0(e, t);
        h.replaceChild(s, t);
        continue;
      }
      if (X0(t)) {
        const s = G0(t);
        h.replaceChild(s, t);
        continue;
      }
      console.warn(`An element of forbidden type "${t.localName}" was found in the translation. Only safe text-level elements and elements with data-l10n-name are allowed.`), h.replaceChild(rg(t), t);
    }
  e.textContent = "", e.appendChild(h);
}
function z0(h, e) {
  if (!h)
    return !1;
  for (let t of h)
    if (t.name === e)
      return !0;
  return !1;
}
function gy(h, e) {
  const t = e.hasAttribute("data-l10n-attrs") ? e.getAttribute("data-l10n-attrs").split(",").map((s) => s.trim()) : null;
  for (const s of Array.from(e.attributes))
    Wm(s.name, e, t) && !z0(h.attributes, s.name) && e.removeAttribute(s.name);
  if (h.attributes)
    for (const s of Array.from(h.attributes))
      Wm(s.name, e, t) && e.getAttribute(s.name) !== s.value && e.setAttribute(s.name, s.value);
}
function W0(h, e) {
  const t = e.getAttribute("data-l10n-name"), s = h.querySelector(`[data-l10n-name="${t}"]`);
  if (!s)
    return console.warn(`An element named "${t}" wasn't found in the source.`), rg(e);
  if (s.localName !== e.localName)
    return console.warn(`An element named "${t}" was found in the translation but its type ${e.localName} didn't match the element found in the source (${s.localName}).`), rg(e);
  h.removeChild(s);
  const i = s.cloneNode(!1);
  return my(e, i);
}
function G0(h) {
  const e = h.ownerDocument.createElement(h.localName);
  return my(h, e);
}
function rg(h) {
  return h.ownerDocument.createTextNode(h.textContent);
}
function X0(h) {
  const e = H0[h.namespaceURI];
  return e && e.includes(h.localName);
}
function Wm(h, e, t = null) {
  if (t && t.includes(h))
    return !0;
  const s = $0[e.namespaceURI];
  if (!s)
    return !1;
  const i = h.toLowerCase(), n = e.localName;
  if (s.global.includes(i))
    return !0;
  if (!s[n])
    return !1;
  if (s[n].includes(i))
    return !0;
  if (e.namespaceURI === "http://www.w3.org/1999/xhtml" && n === "input" && i === "value") {
    const r = e.type.toLowerCase();
    if (r === "submit" || r === "button" || r === "reset")
      return !0;
  }
  return !1;
}
function my(h, e) {
  return e.textContent = h.textContent, gy(h, e), e;
}
class Y0 extends Array {
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
}
class K0 extends Y0 {
  constructor(e) {
    if (super(), Symbol.asyncIterator in Object(e))
      this.iterator = e[Symbol.asyncIterator]();
    else if (Symbol.iterator in Object(e))
      this.iterator = e[Symbol.iterator]();
    else
      throw new TypeError("Argument must implement the iteration protocol.");
  }
  [Symbol.asyncIterator]() {
    const e = this;
    let t = 0;
    return {
      async next() {
        return e.length <= t && e.push(e.iterator.next()), e[t++];
      }
    };
  }
  async touchNext(e = 1) {
    let t = 0;
    for (; t++ < e; ) {
      const s = this[this.length - 1];
      if (s && (await s).done)
        break;
      this.push(this.iterator.next());
    }
    return this[this.length - 1];
  }
}
class Q0 {
  constructor(e = [], t) {
    this.resourceIds = e, this.generateBundles = t, this.onChange(!0);
  }
  addResourceIds(e, t = !1) {
    return this.resourceIds.push(...e), this.onChange(t), this.resourceIds.length;
  }
  removeResourceIds(e) {
    return this.resourceIds = this.resourceIds.filter((t) => !e.includes(t)), this.onChange(), this.resourceIds.length;
  }
  async formatWithFallback(e, t) {
    const s = [];
    let i = !1;
    for await (const n of this.bundles) {
      i = !0;
      const r = q0(t, n, e, s);
      if (r.size === 0)
        break;
      if (typeof console < "u") {
        const o = n.locales[0], l = Array.from(r).join(", ");
        console.warn(`[fluent] Missing translations in ${o}: ${l}`);
      }
    }
    return !i && typeof console < "u" && console.warn(`[fluent] Request for keys failed because no resource bundles got generated.
  keys: ${JSON.stringify(e)}.
  resourceIds: ${JSON.stringify(this.resourceIds)}.`), s;
  }
  formatMessages(e) {
    return this.formatWithFallback(e, J0);
  }
  formatValues(e) {
    return this.formatWithFallback(e, Z0);
  }
  async formatValue(e, t) {
    const [s] = await this.formatValues([{
      id: e,
      args: t
    }]);
    return s;
  }
  handleEvent() {
    this.onChange();
  }
  onChange(e = !1) {
    this.bundles = K0.from(this.generateBundles(this.resourceIds)), e && this.bundles.touchNext(2);
  }
}
function Z0(h, e, t, s) {
  return t.value ? h.formatPattern(t.value, s, e) : null;
}
function J0(h, e, t, s) {
  const i = {
    value: null,
    attributes: null
  };
  t.value && (i.value = h.formatPattern(t.value, s, e));
  let n = Object.keys(t.attributes);
  if (n.length > 0) {
    i.attributes = new Array(n.length);
    for (let [r, o] of n.entries()) {
      let l = h.formatPattern(t.attributes[o], s, e);
      i.attributes[r] = {
        name: o,
        value: l
      };
    }
  }
  return i;
}
function q0(h, e, t, s) {
  const i = [], n = /* @__PURE__ */ new Set();
  return t.forEach(({
    id: r,
    args: o
  }, l) => {
    if (s[l] !== void 0)
      return;
    let c = e.getMessage(r);
    if (c) {
      if (i.length = 0, s[l] = h(e, i, c, o), i.length > 0 && typeof console < "u") {
        const d = e.locales[0], u = i.join(", ");
        console.warn(`[fluent][resolver] errors in ${d}/${r}: ${u}.`);
      }
    } else
      n.add(r);
  }), n;
}
const br = "data-l10n-id", Vl = "data-l10n-args", tS = `[${br}]`;
class eS extends Q0 {
  constructor(e, t) {
    super(e, t), this.roots = /* @__PURE__ */ new Set(), this.pendingrAF = null, this.pendingElements = /* @__PURE__ */ new Set(), this.windowElement = null, this.mutationObserver = null, this.observerConfig = {
      attributes: !0,
      characterData: !1,
      childList: !0,
      subtree: !0,
      attributeFilter: [br, Vl]
    };
  }
  onChange(e = !1) {
    super.onChange(e), this.roots && this.translateRoots();
  }
  setAttributes(e, t, s) {
    return e.setAttribute(br, t), s ? e.setAttribute(Vl, JSON.stringify(s)) : e.removeAttribute(Vl), e;
  }
  getAttributes(e) {
    return {
      id: e.getAttribute(br),
      args: JSON.parse(e.getAttribute(Vl) || null)
    };
  }
  connectRoot(e) {
    for (const t of this.roots)
      if (t === e || t.contains(e) || e.contains(t))
        throw new Error("Cannot add a root that overlaps with existing root.");
    if (this.windowElement) {
      if (this.windowElement !== e.ownerDocument.defaultView)
        throw new Error(`Cannot connect a root:
          DOMLocalization already has a root from a different window.`);
    } else
      this.windowElement = e.ownerDocument.defaultView, this.mutationObserver = new this.windowElement.MutationObserver((t) => this.translateMutations(t));
    this.roots.add(e), this.mutationObserver.observe(e, this.observerConfig);
  }
  disconnectRoot(e) {
    return this.roots.delete(e), this.pauseObserving(), this.roots.size === 0 ? (this.mutationObserver = null, this.windowElement && this.pendingrAF && this.windowElement.cancelAnimationFrame(this.pendingrAF), this.windowElement = null, this.pendingrAF = null, this.pendingElements.clear(), !0) : (this.resumeObserving(), !1);
  }
  translateRoots() {
    const e = Array.from(this.roots);
    return Promise.all(e.map((t) => this.translateFragment(t)));
  }
  pauseObserving() {
    this.mutationObserver && (this.translateMutations(this.mutationObserver.takeRecords()), this.mutationObserver.disconnect());
  }
  resumeObserving() {
    if (this.mutationObserver)
      for (const e of this.roots)
        this.mutationObserver.observe(e, this.observerConfig);
  }
  translateMutations(e) {
    for (const t of e)
      switch (t.type) {
        case "attributes":
          t.target.hasAttribute("data-l10n-id") && this.pendingElements.add(t.target);
          break;
        case "childList":
          for (const s of t.addedNodes)
            if (s.nodeType === s.ELEMENT_NODE)
              if (s.childElementCount)
                for (const i of this.getTranslatables(s))
                  this.pendingElements.add(i);
              else s.hasAttribute(br) && this.pendingElements.add(s);
          break;
      }
    this.pendingElements.size > 0 && this.pendingrAF === null && (this.pendingrAF = this.windowElement.requestAnimationFrame(() => {
      this.translateElements(Array.from(this.pendingElements)), this.pendingElements.clear(), this.pendingrAF = null;
    }));
  }
  translateFragment(e) {
    return this.translateElements(this.getTranslatables(e));
  }
  async translateElements(e) {
    if (!e.length)
      return;
    const t = e.map(this.getKeysForElement), s = await this.formatMessages(t);
    return this.applyTranslations(e, s);
  }
  applyTranslations(e, t) {
    this.pauseObserving();
    for (let s = 0; s < e.length; s++)
      t[s] !== void 0 && V0(e[s], t[s]);
    this.resumeObserving();
  }
  getTranslatables(e) {
    const t = Array.from(e.querySelectorAll(tS));
    return typeof e.hasAttribute == "function" && e.hasAttribute(br) && t.push(e), t;
  }
  getKeysForElement(e) {
    return {
      id: e.getAttribute(br),
      args: JSON.parse(e.getAttribute(Vl) || null)
    };
  }
}
var Yc, Kn, ml, $e, Nl, vy, by;
const gh = class gh {
  constructor({
    lang: e,
    isRTL: t
  }, s = null) {
    b(this, Yc);
    b(this, Kn);
    b(this, ml);
    b(this, $e);
    var i, n;
    p(this, ml, v(i = gh, Nl, vy).call(i, e)), p(this, $e, s), p(this, Yc, t ?? v(n = gh, Nl, by).call(n, a(this, ml)) ? "rtl" : "ltr");
  }
  _setL10n(e) {
    p(this, $e, e);
  }
  getLanguage() {
    return a(this, ml);
  }
  getDirection() {
    return a(this, Yc);
  }
  async get(e, t = null, s) {
    var n;
    return Array.isArray(e) ? (e = e.map((o) => ({
      id: o
    })), (await a(this, $e).formatMessages(e)).map((o) => o.value)) : ((n = (await a(this, $e).formatMessages([{
      id: e,
      args: t
    }]))[0]) == null ? void 0 : n.value) || s;
  }
  async translate(e) {
    (a(this, Kn) || p(this, Kn, /* @__PURE__ */ new Set())).add(e);
    try {
      a(this, $e).connectRoot(e), await a(this, $e).translateRoots();
    } catch {
    }
  }
  async translateOnce(e) {
    try {
      await a(this, $e).translateElements([e]);
    } catch (t) {
      console.error("translateOnce:", t);
    }
  }
  async destroy() {
    if (a(this, Kn)) {
      for (const e of a(this, Kn))
        a(this, $e).disconnectRoot(e);
      a(this, Kn).clear(), p(this, Kn, null);
    }
    a(this, $e).pauseObserving();
  }
  pause() {
    a(this, $e).pauseObserving();
  }
  resume() {
    a(this, $e).resumeObserving();
  }
};
Yc = new WeakMap(), Kn = new WeakMap(), ml = new WeakMap(), $e = new WeakMap(), Nl = new WeakSet(), vy = function(e) {
  return e = (e == null ? void 0 : e.toLowerCase()) || "en-us", {
    en: "en-us",
    es: "es-es",
    fy: "fy-nl",
    ga: "ga-ie",
    gu: "gu-in",
    hi: "hi-in",
    hy: "hy-am",
    nb: "nb-no",
    ne: "ne-np",
    nn: "nn-no",
    pa: "pa-in",
    pt: "pt-pt",
    sv: "sv-se",
    zh: "zh-cn"
  }[e] || e;
}, by = function(e) {
  const t = e.split("-", 1)[0];
  return ["ar", "he", "fa", "ps", "ur"].includes(t);
}, b(gh, Nl);
let ag = gh;
function Gm(h, e) {
  const t = new B0(e), s = new E0(h), i = s.addResource(t);
  return i.length && console.error("L10n errors", i), s;
}
var hs, yy, Ay, wy, Ey, og;
const wr = class wr extends ag {
  constructor(e) {
    super({
      lang: e
    });
    const t = e ? v(wr, hs, yy).bind(wr, "en-us", this.getLanguage()) : v(wr, hs, Ey).bind(wr, this.getLanguage());
    this._setL10n(new eS([], t));
  }
};
hs = new WeakSet(), yy = async function* (e, t) {
  const {
    baseURL: s,
    paths: i
  } = await v(this, hs, wy).call(this), n = [t];
  if (e !== t) {
    const r = t.split("-", 1)[0];
    r !== t && n.push(r), n.push(e);
  }
  for (const r of n) {
    const o = await v(this, hs, Ay).call(this, r, s, i);
    o ? yield o : r === "en-us" && (yield v(this, hs, og).call(this, r));
  }
}, Ay = async function(e, t, s) {
  const i = s[e];
  if (!i)
    return null;
  const n = new URL(i, t), r = await Im(n, "text");
  return Gm(e, r);
}, wy = async function() {
  try {
    const {
      href: e
    } = document.querySelector('link[type="application/l10n"]'), t = await Im(e, "json");
    return {
      baseURL: e.replace(/[^/]*$/, "") || "./",
      paths: t
    };
  } catch {
  }
  return {
    baseURL: "./",
    paths: /* @__PURE__ */ Object.create(null)
  };
}, Ey = async function* (e) {
  yield v(this, hs, og).call(this, e);
}, og = async function(e) {
  return Gm(e, `pdfjs-previous-button =
    .title = Previous Page
pdfjs-previous-button-label = Previous
pdfjs-next-button =
    .title = Next Page
pdfjs-next-button-label = Next
pdfjs-page-input =
    .title = Page
pdfjs-of-pages = of { $pagesCount }
pdfjs-page-of-pages = ({ $pageNumber } of { $pagesCount })
pdfjs-zoom-out-button =
    .title = Zoom Out
pdfjs-zoom-out-button-label = Zoom Out
pdfjs-zoom-in-button =
    .title = Zoom In
pdfjs-zoom-in-button-label = Zoom In
pdfjs-zoom-select =
    .title = Zoom
pdfjs-presentation-mode-button =
    .title = Switch to Presentation Mode
pdfjs-presentation-mode-button-label = Presentation Mode
pdfjs-open-file-button =
    .title = Open File
pdfjs-open-file-button-label = Open
pdfjs-print-button =
    .title = Print
pdfjs-print-button-label = Print
pdfjs-save-button =
    .title = Save
pdfjs-save-button-label = Save
pdfjs-download-button =
    .title = Download
pdfjs-download-button-label = Download
pdfjs-bookmark-button =
    .title = Current Page (View URL from Current Page)
pdfjs-bookmark-button-label = Current Page
pdfjs-tools-button =
    .title = Tools
pdfjs-tools-button-label = Tools
pdfjs-first-page-button =
    .title = Go to First Page
pdfjs-first-page-button-label = Go to First Page
pdfjs-last-page-button =
    .title = Go to Last Page
pdfjs-last-page-button-label = Go to Last Page
pdfjs-page-rotate-cw-button =
    .title = Rotate Clockwise
pdfjs-page-rotate-cw-button-label = Rotate Clockwise
pdfjs-page-rotate-ccw-button =
    .title = Rotate Counterclockwise
pdfjs-page-rotate-ccw-button-label = Rotate Counterclockwise
pdfjs-cursor-text-select-tool-button =
    .title = Enable Text Selection Tool
pdfjs-cursor-text-select-tool-button-label = Text Selection Tool
pdfjs-cursor-hand-tool-button =
    .title = Enable Hand Tool
pdfjs-cursor-hand-tool-button-label = Hand Tool
pdfjs-scroll-page-button =
    .title = Use Page Scrolling
pdfjs-scroll-page-button-label = Page Scrolling
pdfjs-scroll-vertical-button =
    .title = Use Vertical Scrolling
pdfjs-scroll-vertical-button-label = Vertical Scrolling
pdfjs-scroll-horizontal-button =
    .title = Use Horizontal Scrolling
pdfjs-scroll-horizontal-button-label = Horizontal Scrolling
pdfjs-scroll-wrapped-button =
    .title = Use Wrapped Scrolling
pdfjs-scroll-wrapped-button-label = Wrapped Scrolling
pdfjs-spread-none-button =
    .title = Do not join page spreads
pdfjs-spread-none-button-label = No Spreads
pdfjs-spread-odd-button =
    .title = Join page spreads starting with odd-numbered pages
pdfjs-spread-odd-button-label = Odd Spreads
pdfjs-spread-even-button =
    .title = Join page spreads starting with even-numbered pages
pdfjs-spread-even-button-label = Even Spreads
pdfjs-document-properties-button =
    .title = Document Properties…
pdfjs-document-properties-button-label = Document Properties…
pdfjs-document-properties-file-name = File name:
pdfjs-document-properties-file-size = File size:
pdfjs-document-properties-size-kb = { NUMBER($kb, maximumSignificantDigits: 3) } KB ({ $b } bytes)
pdfjs-document-properties-size-mb = { NUMBER($mb, maximumSignificantDigits: 3) } MB ({ $b } bytes)
pdfjs-document-properties-title = Title:
pdfjs-document-properties-author = Author:
pdfjs-document-properties-subject = Subject:
pdfjs-document-properties-keywords = Keywords:
pdfjs-document-properties-creation-date = Creation Date:
pdfjs-document-properties-modification-date = Modification Date:
pdfjs-document-properties-date-time-string = { DATETIME($dateObj, dateStyle: "short", timeStyle: "medium") }
pdfjs-document-properties-creator = Creator:
pdfjs-document-properties-producer = PDF Producer:
pdfjs-document-properties-version = PDF Version:
pdfjs-document-properties-page-count = Page Count:
pdfjs-document-properties-page-size = Page Size:
pdfjs-document-properties-page-size-unit-inches = in
pdfjs-document-properties-page-size-unit-millimeters = mm
pdfjs-document-properties-page-size-orientation-portrait = portrait
pdfjs-document-properties-page-size-orientation-landscape = landscape
pdfjs-document-properties-page-size-name-a-three = A3
pdfjs-document-properties-page-size-name-a-four = A4
pdfjs-document-properties-page-size-name-letter = Letter
pdfjs-document-properties-page-size-name-legal = Legal
pdfjs-document-properties-page-size-dimension-string = { $width } × { $height } { $unit } ({ $orientation })
pdfjs-document-properties-page-size-dimension-name-string = { $width } × { $height } { $unit } ({ $name }, { $orientation })
pdfjs-document-properties-linearized = Fast Web View:
pdfjs-document-properties-linearized-yes = Yes
pdfjs-document-properties-linearized-no = No
pdfjs-document-properties-close-button = Close
pdfjs-print-progress-message = Preparing document for printing…
pdfjs-print-progress-percent = { $progress }%
pdfjs-print-progress-close-button = Cancel
pdfjs-printing-not-supported = Warning: Printing is not fully supported by this browser.
pdfjs-printing-not-ready = Warning: The PDF is not fully loaded for printing.
pdfjs-toggle-sidebar-button =
    .title = Toggle Sidebar
pdfjs-toggle-sidebar-notification-button =
    .title = Toggle Sidebar (document contains outline/attachments/layers)
pdfjs-toggle-sidebar-button-label = Toggle Sidebar
pdfjs-document-outline-button =
    .title = Show Document Outline (double-click to expand/collapse all items)
pdfjs-document-outline-button-label = Document Outline
pdfjs-attachments-button =
    .title = Show Attachments
pdfjs-attachments-button-label = Attachments
pdfjs-layers-button =
    .title = Show Layers (double-click to reset all layers to the default state)
pdfjs-layers-button-label = Layers
pdfjs-thumbs-button =
    .title = Show Thumbnails
pdfjs-thumbs-button-label = Thumbnails
pdfjs-current-outline-item-button =
    .title = Find Current Outline Item
pdfjs-current-outline-item-button-label = Current Outline Item
pdfjs-findbar-button =
    .title = Find in Document
pdfjs-findbar-button-label = Find
pdfjs-additional-layers = Additional Layers
pdfjs-thumb-page-title =
    .title = Page { $page }
pdfjs-thumb-page-canvas =
    .aria-label = Thumbnail of Page { $page }
pdfjs-find-input =
    .title = Find
    .placeholder = Find in document…
pdfjs-find-previous-button =
    .title = Find the previous occurrence of the phrase
pdfjs-find-previous-button-label = Previous
pdfjs-find-next-button =
    .title = Find the next occurrence of the phrase
pdfjs-find-next-button-label = Next
pdfjs-find-highlight-checkbox = Highlight All
pdfjs-find-match-case-checkbox-label = Match Case
pdfjs-find-match-diacritics-checkbox-label = Match Diacritics
pdfjs-find-entire-word-checkbox-label = Whole Words
pdfjs-find-reached-top = Reached top of document, continued from bottom
pdfjs-find-reached-bottom = Reached end of document, continued from top
pdfjs-find-match-count =
    { $total ->
        [one] { $current } of { $total } match
       *[other] { $current } of { $total } matches
    }
pdfjs-find-match-count-limit =
    { $limit ->
        [one] More than { $limit } match
       *[other] More than { $limit } matches
    }
pdfjs-find-not-found = Phrase not found
pdfjs-page-scale-width = Page Width
pdfjs-page-scale-fit = Page Fit
pdfjs-page-scale-auto = Automatic Zoom
pdfjs-page-scale-actual = Actual Size
pdfjs-page-scale-percent = { $scale }%
pdfjs-page-landmark =
    .aria-label = Page { $page }
pdfjs-loading-error = An error occurred while loading the PDF.
pdfjs-invalid-file-error = Invalid or corrupted PDF file.
pdfjs-missing-file-error = Missing PDF file.
pdfjs-unexpected-response-error = Unexpected server response.
pdfjs-rendering-error = An error occurred while rendering the page.
pdfjs-annotation-date-time-string = { DATETIME($dateObj, dateStyle: "short", timeStyle: "medium") }
pdfjs-text-annotation-type =
    .alt = [{ $type } Annotation]
pdfjs-password-label = Enter the password to open this PDF file.
pdfjs-password-invalid = Invalid password. Please try again.
pdfjs-password-ok-button = OK
pdfjs-password-cancel-button = Cancel
pdfjs-web-fonts-disabled = Web fonts are disabled: unable to use embedded PDF fonts.
pdfjs-editor-free-text-button =
    .title = Text
pdfjs-editor-free-text-button-label = Text
pdfjs-editor-ink-button =
    .title = Draw
pdfjs-editor-ink-button-label = Draw
pdfjs-editor-stamp-button =
    .title = Add or edit images
pdfjs-editor-stamp-button-label = Add or edit images
pdfjs-editor-highlight-button =
    .title = Highlight
pdfjs-editor-highlight-button-label = Highlight
pdfjs-highlight-floating-button1 =
    .title = Highlight
    .aria-label = Highlight
pdfjs-highlight-floating-button-label = Highlight
pdfjs-editor-remove-ink-button =
    .title = Remove drawing
pdfjs-editor-remove-freetext-button =
    .title = Remove text
pdfjs-editor-remove-stamp-button =
    .title = Remove image
pdfjs-editor-remove-highlight-button =
    .title = Remove highlight
pdfjs-editor-free-text-color-input = Color
pdfjs-editor-free-text-size-input = Size
pdfjs-editor-ink-color-input = Color
pdfjs-editor-ink-thickness-input = Thickness
pdfjs-editor-ink-opacity-input = Opacity
pdfjs-editor-stamp-add-image-button =
    .title = Add image
pdfjs-editor-stamp-add-image-button-label = Add image
pdfjs-editor-free-highlight-thickness-input = Thickness
pdfjs-editor-free-highlight-thickness-title =
    .title = Change thickness when highlighting items other than text
pdfjs-free-text2 =
    .aria-label = Text Editor
    .default-content = Start typing…
pdfjs-ink =
    .aria-label = Draw Editor
pdfjs-ink-canvas =
    .aria-label = User-created image
pdfjs-editor-alt-text-button =
    .aria-label = Alt text
pdfjs-editor-alt-text-button-label = Alt text
pdfjs-editor-alt-text-edit-button =
    .aria-label = Edit alt text
pdfjs-editor-alt-text-dialog-label = Choose an option
pdfjs-editor-alt-text-dialog-description = Alt text (alternative text) helps when people can’t see the image or when it doesn’t load.
pdfjs-editor-alt-text-add-description-label = Add a description
pdfjs-editor-alt-text-add-description-description = Aim for 1-2 sentences that describe the subject, setting, or actions.
pdfjs-editor-alt-text-mark-decorative-label = Mark as decorative
pdfjs-editor-alt-text-mark-decorative-description = This is used for ornamental images, like borders or watermarks.
pdfjs-editor-alt-text-cancel-button = Cancel
pdfjs-editor-alt-text-save-button = Save
pdfjs-editor-alt-text-decorative-tooltip = Marked as decorative
pdfjs-editor-alt-text-textarea =
    .placeholder = For example, “A young man sits down at a table to eat a meal”
pdfjs-editor-resizer-top-left =
    .aria-label = Top left corner — resize
pdfjs-editor-resizer-top-middle =
    .aria-label = Top middle — resize
pdfjs-editor-resizer-top-right =
    .aria-label = Top right corner — resize
pdfjs-editor-resizer-middle-right =
    .aria-label = Middle right — resize
pdfjs-editor-resizer-bottom-right =
    .aria-label = Bottom right corner — resize
pdfjs-editor-resizer-bottom-middle =
    .aria-label = Bottom middle — resize
pdfjs-editor-resizer-bottom-left =
    .aria-label = Bottom left corner — resize
pdfjs-editor-resizer-middle-left =
    .aria-label = Middle left — resize
pdfjs-editor-highlight-colorpicker-label = Highlight color
pdfjs-editor-colorpicker-button =
    .title = Change color
pdfjs-editor-colorpicker-dropdown =
    .aria-label = Color choices
pdfjs-editor-colorpicker-yellow =
    .title = Yellow
pdfjs-editor-colorpicker-green =
    .title = Green
pdfjs-editor-colorpicker-blue =
    .title = Blue
pdfjs-editor-colorpicker-pink =
    .title = Pink
pdfjs-editor-colorpicker-red =
    .title = Red
pdfjs-editor-highlight-show-all-button-label = Show all
pdfjs-editor-highlight-show-all-button =
    .title = Show all
pdfjs-editor-new-alt-text-dialog-edit-label = Edit alt text (image description)
pdfjs-editor-new-alt-text-dialog-add-label = Add alt text (image description)
pdfjs-editor-new-alt-text-textarea =
    .placeholder = Write your description here…
pdfjs-editor-new-alt-text-description = Short description for people who can’t see the image or when the image doesn’t load.
pdfjs-editor-new-alt-text-disclaimer1 = This alt text was created automatically and may be inaccurate.
pdfjs-editor-new-alt-text-disclaimer-learn-more-url = Learn more
pdfjs-editor-new-alt-text-create-automatically-button-label = Create alt text automatically
pdfjs-editor-new-alt-text-not-now-button = Not now
pdfjs-editor-new-alt-text-error-title = Couldn’t create alt text automatically
pdfjs-editor-new-alt-text-error-description = Please write your own alt text or try again later.
pdfjs-editor-new-alt-text-error-close-button = Close
pdfjs-editor-new-alt-text-ai-model-downloading-progress = Downloading alt text AI model ({ $downloadedSize } of { $totalSize } MB)
    .aria-valuetext = Downloading alt text AI model ({ $downloadedSize } of { $totalSize } MB)
pdfjs-editor-new-alt-text-added-button =
    .aria-label = Alt text added
pdfjs-editor-new-alt-text-added-button-label = Alt text added
pdfjs-editor-new-alt-text-missing-button =
    .aria-label = Missing alt text
pdfjs-editor-new-alt-text-missing-button-label = Missing alt text
pdfjs-editor-new-alt-text-to-review-button =
    .aria-label = Review alt text
pdfjs-editor-new-alt-text-to-review-button-label = Review alt text
pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer = Created automatically: { $generatedAltText }
pdfjs-image-alt-text-settings-button =
    .title = Image alt text settings
pdfjs-image-alt-text-settings-button-label = Image alt text settings
pdfjs-editor-alt-text-settings-dialog-label = Image alt text settings
pdfjs-editor-alt-text-settings-automatic-title = Automatic alt text
pdfjs-editor-alt-text-settings-create-model-button-label = Create alt text automatically
pdfjs-editor-alt-text-settings-create-model-description = Suggests descriptions to help people who can’t see the image or when the image doesn’t load.
pdfjs-editor-alt-text-settings-download-model-label = Alt text AI model ({ $totalSize } MB)
pdfjs-editor-alt-text-settings-ai-model-description = Runs locally on your device so your data stays private. Required for automatic alt text.
pdfjs-editor-alt-text-settings-delete-model-button = Delete
pdfjs-editor-alt-text-settings-download-model-button = Download
pdfjs-editor-alt-text-settings-downloading-model-button = Downloading…
pdfjs-editor-alt-text-settings-editor-title = Alt text editor
pdfjs-editor-alt-text-settings-show-dialog-button-label = Show alt text editor right away when adding an image
pdfjs-editor-alt-text-settings-show-dialog-description = Helps you make sure all your images have alt text.
pdfjs-editor-alt-text-settings-close-button = Close
pdfjs-editor-undo-bar-message-highlight = Highlight removed
pdfjs-editor-undo-bar-message-freetext = Text removed
pdfjs-editor-undo-bar-message-ink = Drawing removed
pdfjs-editor-undo-bar-message-stamp = Image removed
pdfjs-editor-undo-bar-message-multiple =
    { $count ->
        [one] { $count } annotation removed
       *[other] { $count } annotations removed
    }
pdfjs-editor-undo-bar-undo-button =
    .title = Undo
pdfjs-editor-undo-bar-undo-button-label = Undo
pdfjs-editor-undo-bar-close-button =
    .title = Close
pdfjs-editor-undo-bar-close-button-label = Close`);
}, b(wr, hs);
let Ol = wr;
const sS = 1e3, iS = 50, nS = 1e3;
function Lf() {
  return document.location.hash;
}
var Qn, it, Si, mu, vu, oh, bu, lg, Sy, xy, hg, Ty, Py;
class rS {
  constructor({
    linkService: e,
    eventBus: t
  }) {
    b(this, it);
    b(this, Qn, null);
    this.linkService = e, this.eventBus = t, this._initialized = !1, this._fingerprint = "", this.reset(), this.eventBus._on("pagesinit", () => {
      this._isPagesLoaded = !1, this.eventBus._on("pagesloaded", (s) => {
        this._isPagesLoaded = !!s.pagesCount;
      }, {
        once: !0
      });
    });
  }
  initialize({
    fingerprint: e,
    resetHistory: t = !1,
    updateUrl: s = !1
  }) {
    if (!e || typeof e != "string") {
      console.error('PDFHistory.initialize: The "fingerprint" must be a non-empty string.');
      return;
    }
    this._initialized && this.reset();
    const i = this._fingerprint !== "" && this._fingerprint !== e;
    this._fingerprint = e, this._updateUrl = s === !0, this._initialized = !0, v(this, it, Ty).call(this);
    const n = window.history.state;
    if (this._popStateInProgress = !1, this._blockHashChange = 0, this._currentHash = Lf(), this._numPositionUpdates = 0, this._uid = this._maxUid = 0, this._destination = null, this._position = null, !v(this, it, oh).call(this, n, !0) || t) {
      const {
        hash: o,
        page: l,
        rotation: c
      } = v(this, it, lg).call(this, !0);
      if (!o || i || t) {
        v(this, it, Si).call(this, null, !0);
        return;
      }
      v(this, it, Si).call(this, {
        hash: o,
        page: l,
        rotation: c
      }, !0);
      return;
    }
    const r = n.destination;
    v(this, it, bu).call(this, r, n.uid, !0), r.rotation !== void 0 && (this._initialRotation = r.rotation), r.dest ? (this._initialBookmark = JSON.stringify(r.dest), this._destination.page = null) : r.hash ? this._initialBookmark = r.hash : r.page && (this._initialBookmark = `page=${r.page}`);
  }
  reset() {
    this._initialized && (v(this, it, hg).call(this), this._initialized = !1, v(this, it, Py).call(this)), this._updateViewareaTimeout && (clearTimeout(this._updateViewareaTimeout), this._updateViewareaTimeout = null), this._initialBookmark = null, this._initialRotation = null;
  }
  push({
    namedDest: e = null,
    explicitDest: t,
    pageNumber: s
  }) {
    if (!this._initialized)
      return;
    if (e && typeof e != "string") {
      console.error(`PDFHistory.push: "${e}" is not a valid namedDest parameter.`);
      return;
    } else if (Array.isArray(t)) {
      if (!v(this, it, vu).call(this, s) && (s !== null || this._destination)) {
        console.error(`PDFHistory.push: "${s}" is not a valid pageNumber parameter.`);
        return;
      }
    } else {
      console.error(`PDFHistory.push: "${t}" is not a valid explicitDest parameter.`);
      return;
    }
    const i = e || JSON.stringify(t);
    if (!i)
      return;
    let n = !1;
    if (this._destination && (aS(this._destination.hash, i) || oS(this._destination.dest, t))) {
      if (this._destination.page)
        return;
      n = !0;
    }
    this._popStateInProgress && !n || (v(this, it, Si).call(this, {
      dest: t,
      hash: i,
      page: s,
      rotation: this.linkService.rotation
    }, n), this._popStateInProgress || (this._popStateInProgress = !0, Promise.resolve().then(() => {
      this._popStateInProgress = !1;
    })));
  }
  pushPage(e) {
    var t;
    if (this._initialized) {
      if (!v(this, it, vu).call(this, e)) {
        console.error(`PDFHistory.pushPage: "${e}" is not a valid page number.`);
        return;
      }
      ((t = this._destination) == null ? void 0 : t.page) !== e && (this._popStateInProgress || (v(this, it, Si).call(this, {
        dest: null,
        hash: `page=${e}`,
        page: e,
        rotation: this.linkService.rotation
      }), this._popStateInProgress || (this._popStateInProgress = !0, Promise.resolve().then(() => {
        this._popStateInProgress = !1;
      }))));
    }
  }
  pushCurrentPosition() {
    !this._initialized || this._popStateInProgress || v(this, it, mu).call(this);
  }
  back() {
    if (!this._initialized || this._popStateInProgress)
      return;
    const e = window.history.state;
    v(this, it, oh).call(this, e) && e.uid > 0 && window.history.back();
  }
  forward() {
    if (!this._initialized || this._popStateInProgress)
      return;
    const e = window.history.state;
    v(this, it, oh).call(this, e) && e.uid < this._maxUid && window.history.forward();
  }
  get popStateInProgress() {
    return this._initialized && (this._popStateInProgress || this._blockHashChange > 0);
  }
  get initialBookmark() {
    return this._initialized ? this._initialBookmark : null;
  }
  get initialRotation() {
    return this._initialized ? this._initialRotation : null;
  }
}
Qn = new WeakMap(), it = new WeakSet(), Si = function(e, t = !1) {
  const s = t || !this._destination, i = {
    fingerprint: this._fingerprint,
    uid: s ? this._uid : this._uid + 1,
    destination: e
  };
  v(this, it, bu).call(this, e, i.uid);
  let n;
  if (this._updateUrl && (e != null && e.hash)) {
    const r = document.location.href.split("#", 1)[0];
    r.startsWith("file://") || (n = `${r}#${e.hash}`);
  }
  s ? window.history.replaceState(i, "", n) : window.history.pushState(i, "", n);
}, mu = function(e = !1) {
  if (!this._position)
    return;
  let t = this._position;
  if (e && (t = Object.assign(/* @__PURE__ */ Object.create(null), this._position), t.temporary = !0), !this._destination) {
    v(this, it, Si).call(this, t);
    return;
  }
  if (this._destination.temporary) {
    v(this, it, Si).call(this, t, !0);
    return;
  }
  if (this._destination.hash === t.hash || !this._destination.page && this._numPositionUpdates <= iS)
    return;
  let s = !1;
  if (this._destination.page >= t.first && this._destination.page <= t.page) {
    if (this._destination.dest !== void 0 || !this._destination.first)
      return;
    s = !0;
  }
  v(this, it, Si).call(this, t, s);
}, vu = function(e) {
  return Number.isInteger(e) && e > 0 && e <= this.linkService.pagesCount;
}, oh = function(e, t = !1) {
  if (!e)
    return !1;
  if (e.fingerprint !== this._fingerprint)
    if (t) {
      if (typeof e.fingerprint != "string" || e.fingerprint.length !== this._fingerprint.length)
        return !1;
      const [s] = performance.getEntriesByType("navigation");
      if ((s == null ? void 0 : s.type) !== "reload")
        return !1;
    } else
      return !1;
  return !(!Number.isInteger(e.uid) || e.uid < 0 || e.destination === null || typeof e.destination != "object");
}, bu = function(e, t, s = !1) {
  this._updateViewareaTimeout && (clearTimeout(this._updateViewareaTimeout), this._updateViewareaTimeout = null), s && (e != null && e.temporary) && delete e.temporary, this._destination = e, this._uid = t, this._maxUid = Math.max(this._maxUid, t), this._numPositionUpdates = 0;
}, lg = function(e = !1) {
  const t = unescape(Lf()).substring(1), s = uf(t), i = s.get("nameddest") || "";
  let n = s.get("page") | 0;
  return (!v(this, it, vu).call(this, n) || e && i.length > 0) && (n = null), {
    hash: t,
    page: n,
    rotation: this.linkService.rotation
  };
}, Sy = function({
  location: e
}) {
  this._updateViewareaTimeout && (clearTimeout(this._updateViewareaTimeout), this._updateViewareaTimeout = null), this._position = {
    hash: e.pdfOpenParams.substring(1),
    page: this.linkService.page,
    first: e.pageNumber,
    rotation: e.rotation
  }, !this._popStateInProgress && (this._isPagesLoaded && this._destination && !this._destination.page && this._numPositionUpdates++, this._updateViewareaTimeout = setTimeout(() => {
    this._popStateInProgress || v(this, it, mu).call(this, !0), this._updateViewareaTimeout = null;
  }, nS));
}, xy = function({
  state: e
}) {
  const t = Lf(), s = this._currentHash !== t;
  if (this._currentHash = t, !e) {
    this._uid++;
    const {
      hash: n,
      page: r,
      rotation: o
    } = v(this, it, lg).call(this);
    v(this, it, Si).call(this, {
      hash: n,
      page: r,
      rotation: o
    }, !0);
    return;
  }
  if (!v(this, it, oh).call(this, e))
    return;
  this._popStateInProgress = !0, s && (this._blockHashChange++, h0({
    target: window,
    name: "hashchange",
    delay: sS
  }).then(() => {
    this._blockHashChange--;
  }));
  const i = e.destination;
  v(this, it, bu).call(this, i, e.uid, !0), iy(i.rotation) && (this.linkService.rotation = i.rotation), i.dest ? this.linkService.goToDestination(i.dest) : i.hash ? this.linkService.setHash(i.hash) : i.page && (this.linkService.page = i.page), Promise.resolve().then(() => {
    this._popStateInProgress = !1;
  });
}, hg = function() {
  (!this._destination || this._destination.temporary) && v(this, it, mu).call(this);
}, Ty = function() {
  if (a(this, Qn))
    return;
  p(this, Qn, new AbortController());
  const {
    signal: e
  } = a(this, Qn);
  this.eventBus._on("updateviewarea", v(this, it, Sy).bind(this), {
    signal: e
  }), window.addEventListener("popstate", v(this, it, xy).bind(this), {
    signal: e
  }), window.addEventListener("pagehide", v(this, it, hg).bind(this), {
    signal: e
  });
}, Py = function() {
  var e;
  (e = a(this, Qn)) == null || e.abort(), p(this, Qn, null);
};
function aS(h, e) {
  return typeof h != "string" || typeof e != "string" ? !1 : h === e || uf(h).get("nameddest") === e;
}
function oS(h, e) {
  function t(s, i) {
    if (typeof s != typeof i || Array.isArray(s) || Array.isArray(i))
      return !1;
    if (s !== null && typeof s == "object" && i !== null) {
      if (Object.keys(s).length !== Object.keys(i).length)
        return !1;
      for (const n in s)
        if (!t(s[n], i[n]))
          return !1;
      return !0;
    }
    return s === i || Number.isNaN(s) && Number.isNaN(i);
  }
  if (!(Array.isArray(h) && Array.isArray(e)) || h.length !== e.length)
    return !1;
  for (let s = 0, i = h.length; s < i; s++)
    if (!t(h[s], e[s]))
      return !1;
  return !0;
}
var Kc, Qc, Zc, Jc, qc, vl;
class lS {
  constructor(e) {
    b(this, Kc, null);
    b(this, Qc, null);
    b(this, Zc, null);
    b(this, Jc, null);
    b(this, qc, null);
    b(this, vl);
    this.pdfPage = e.pdfPage, this.accessibilityManager = e.accessibilityManager, this.l10n = e.l10n, this.l10n || (this.l10n = new Ol()), this.annotationEditorLayer = null, this.div = null, this._cancelled = !1, p(this, vl, e.uiManager), p(this, Kc, e.annotationLayer || null), p(this, qc, e.textLayer || null), p(this, Qc, e.drawLayer || null), p(this, Zc, e.onAppend || null), p(this, Jc, e.structTreeLayer || null);
  }
  async render(e, t = "display") {
    var r;
    if (t !== "display" || this._cancelled)
      return;
    const s = e.clone({
      dontFlip: !0
    });
    if (this.div) {
      this.annotationEditorLayer.update({
        viewport: s
      }), this.show();
      return;
    }
    const i = this.div = document.createElement("div");
    i.className = "annotationEditorLayer", i.hidden = !0, i.dir = a(this, vl).direction, (r = a(this, Zc)) == null || r.call(this, i), this.annotationEditorLayer = new ZE({
      uiManager: a(this, vl),
      div: i,
      structTreeLayer: a(this, Jc),
      accessibilityManager: this.accessibilityManager,
      pageIndex: this.pdfPage.pageNumber - 1,
      l10n: this.l10n,
      viewport: s,
      annotationLayer: a(this, Kc),
      textLayer: a(this, qc),
      drawLayer: a(this, Qc)
    });
    const n = {
      viewport: s,
      div: i,
      annotations: null,
      intent: t
    };
    this.annotationEditorLayer.render(n), this.show();
  }
  cancel() {
    this._cancelled = !0, this.div && this.annotationEditorLayer.destroy();
  }
  hide() {
    this.div && (this.annotationEditorLayer.pause(!0), this.div.hidden = !0);
  }
  show() {
    !this.div || this.annotationEditorLayer.isInvisible || (this.div.hidden = !1, this.annotationEditorLayer.pause(!1));
  }
}
Kc = new WeakMap(), Qc = new WeakMap(), Zc = new WeakMap(), Jc = new WeakMap(), qc = new WeakMap(), vl = new WeakMap();
{
  var cg = /* @__PURE__ */ new Map();
  const h = navigator.userAgent || "", e = navigator.platform || "", t = navigator.maxTouchPoints || 1, s = /Android/.test(h), i = /\b(iPad|iPhone|iPod)(?=;)/.test(h) || e === "MacIntel" && t > 1;
  (function() {
    (i || s) && cg.set("maxCanvasPixels", 5242880);
  })(), function() {
    s && cg.set("useSystemFonts", !1);
  }();
}
const M = {
  BROWSER: 1,
  VIEWER: 2,
  API: 4,
  WORKER: 8,
  EVENT_DISPATCH: 16,
  PREFERENCE: 128
}, dg = {
  BOOLEAN: 1,
  NUMBER: 2,
  OBJECT: 4,
  STRING: 8,
  UNDEFINED: 16
}, vi = {
  allowedGlobalEvents: {
    value: null,
    kind: M.BROWSER
  },
  canvasMaxAreaInBytes: {
    value: -1,
    kind: M.BROWSER + M.API
  },
  isInAutomation: {
    value: !1,
    kind: M.BROWSER
  },
  localeProperties: {
    value: {
      lang: navigator.language || "en-US"
    },
    kind: M.BROWSER
  },
  nimbusDataStr: {
    value: "",
    kind: M.BROWSER
  },
  supportsCaretBrowsingMode: {
    value: !1,
    kind: M.BROWSER
  },
  supportsDocumentFonts: {
    value: !0,
    kind: M.BROWSER
  },
  supportsIntegratedFind: {
    value: !1,
    kind: M.BROWSER
  },
  supportsMouseWheelZoomCtrlKey: {
    value: !0,
    kind: M.BROWSER
  },
  supportsMouseWheelZoomMetaKey: {
    value: !0,
    kind: M.BROWSER
  },
  supportsPinchToZoom: {
    value: !0,
    kind: M.BROWSER
  },
  toolbarDensity: {
    value: 0,
    kind: M.BROWSER + M.EVENT_DISPATCH
  },
  altTextLearnMoreUrl: {
    value: "",
    kind: M.VIEWER + M.PREFERENCE
  },
  annotationEditorMode: {
    value: 0,
    kind: M.VIEWER + M.PREFERENCE
  },
  annotationMode: {
    value: 2,
    kind: M.VIEWER + M.PREFERENCE
  },
  cursorToolOnLoad: {
    value: 0,
    kind: M.VIEWER + M.PREFERENCE
  },
  debuggerSrc: {
    value: "./debugger.mjs",
    kind: M.VIEWER
  },
  defaultZoomDelay: {
    value: 400,
    kind: M.VIEWER + M.PREFERENCE
  },
  defaultZoomValue: {
    value: "",
    kind: M.VIEWER + M.PREFERENCE
  },
  disableHistory: {
    value: !1,
    kind: M.VIEWER
  },
  disablePageLabels: {
    value: !1,
    kind: M.VIEWER + M.PREFERENCE
  },
  enableAltText: {
    value: !1,
    kind: M.VIEWER + M.PREFERENCE
  },
  enableAltTextModelDownload: {
    value: !0,
    kind: M.VIEWER + M.PREFERENCE + M.EVENT_DISPATCH
  },
  enableGuessAltText: {
    value: !0,
    kind: M.VIEWER + M.PREFERENCE + M.EVENT_DISPATCH
  },
  enableHighlightFloatingButton: {
    value: !1,
    kind: M.VIEWER + M.PREFERENCE
  },
  enableNewAltTextWhenAddingImage: {
    value: !0,
    kind: M.VIEWER + M.PREFERENCE
  },
  enablePermissions: {
    value: !1,
    kind: M.VIEWER + M.PREFERENCE
  },
  enablePrintAutoRotate: {
    value: !0,
    kind: M.VIEWER + M.PREFERENCE
  },
  enableScripting: {
    value: !0,
    kind: M.VIEWER + M.PREFERENCE
  },
  enableUpdatedAddImage: {
    value: !1,
    kind: M.VIEWER + M.PREFERENCE
  },
  externalLinkRel: {
    value: "noopener noreferrer nofollow",
    kind: M.VIEWER
  },
  externalLinkTarget: {
    value: 0,
    kind: M.VIEWER + M.PREFERENCE
  },
  highlightEditorColors: {
    value: "yellow=#FFFF98,green=#53FFBC,blue=#80EBFF,pink=#FFCBE6,red=#FF4F5F",
    kind: M.VIEWER + M.PREFERENCE
  },
  historyUpdateUrl: {
    value: !1,
    kind: M.VIEWER + M.PREFERENCE
  },
  ignoreDestinationZoom: {
    value: !1,
    kind: M.VIEWER + M.PREFERENCE
  },
  imageResourcesPath: {
    value: "./images/",
    kind: M.VIEWER
  },
  maxCanvasPixels: {
    value: 2 ** 25,
    kind: M.VIEWER
  },
  forcePageColors: {
    value: !1,
    kind: M.VIEWER + M.PREFERENCE
  },
  pageColorsBackground: {
    value: "Canvas",
    kind: M.VIEWER + M.PREFERENCE
  },
  pageColorsForeground: {
    value: "CanvasText",
    kind: M.VIEWER + M.PREFERENCE
  },
  pdfBugEnabled: {
    value: !1,
    kind: M.VIEWER + M.PREFERENCE
  },
  printResolution: {
    value: 150,
    kind: M.VIEWER
  },
  sidebarViewOnLoad: {
    value: -1,
    kind: M.VIEWER + M.PREFERENCE
  },
  scrollModeOnLoad: {
    value: -1,
    kind: M.VIEWER + M.PREFERENCE
  },
  spreadModeOnLoad: {
    value: -1,
    kind: M.VIEWER + M.PREFERENCE
  },
  textLayerMode: {
    value: 1,
    kind: M.VIEWER + M.PREFERENCE
  },
  viewOnLoad: {
    value: 0,
    kind: M.VIEWER + M.PREFERENCE
  },
  cMapPacked: {
    value: !0,
    kind: M.API
  },
  cMapUrl: {
    value: "../web/cmaps/",
    kind: M.API
  },
  disableAutoFetch: {
    value: !1,
    kind: M.API + M.PREFERENCE
  },
  disableFontFace: {
    value: !1,
    kind: M.API + M.PREFERENCE
  },
  disableRange: {
    value: !1,
    kind: M.API + M.PREFERENCE
  },
  disableStream: {
    value: !1,
    kind: M.API + M.PREFERENCE
  },
  docBaseUrl: {
    value: "",
    kind: M.API
  },
  enableHWA: {
    value: !0,
    kind: M.API + M.VIEWER + M.PREFERENCE
  },
  enableXfa: {
    value: !0,
    kind: M.API + M.PREFERENCE
  },
  fontExtraProperties: {
    value: !1,
    kind: M.API
  },
  isEvalSupported: {
    value: !0,
    kind: M.API
  },
  isOffscreenCanvasSupported: {
    value: !0,
    kind: M.API
  },
  maxImageSize: {
    value: -1,
    kind: M.API
  },
  pdfBug: {
    value: !1,
    kind: M.API
  },
  standardFontDataUrl: {
    value: "../web/standard_fonts/",
    kind: M.API
  },
  useSystemFonts: {
    value: void 0,
    kind: M.API,
    type: dg.BOOLEAN + dg.UNDEFINED
  },
  verbosity: {
    value: 1,
    kind: M.API
  },
  workerPort: {
    value: null,
    kind: M.WORKER
  },
  workerSrc: {
    value: "../build/pdf.worker.mjs",
    kind: M.WORKER
  }
};
vi.defaultUrl = {
  value: "compressed.tracemonkey-pldi-09.pdf",
  kind: M.VIEWER
}, vi.sandboxBundleSrc = {
  value: "../build/pdf.sandbox.mjs",
  kind: M.VIEWER
}, vi.viewerCssTheme = {
  value: 0,
  kind: M.VIEWER + M.PREFERENCE
}, vi.enableFakeMLManager = {
  value: !0,
  kind: M.VIEWER
};
vi.disablePreferences = {
  value: !1,
  kind: M.VIEWER
};
var Zn;
const Xs = class Xs {
  static get(e) {
    return a(this, Zn).get(e);
  }
  static getAll(e = null, t = !1) {
    const s = /* @__PURE__ */ Object.create(null);
    for (const i in vi) {
      const n = vi[i];
      e && !(e & n.kind) || (s[i] = t ? n.value : a(this, Zn).get(i));
    }
    return s;
  }
  static set(e, t) {
    this.setAll({
      [e]: t
    });
  }
  static setAll(e, t = !1) {
    this._hasInvokedSet || (this._hasInvokedSet = !0);
    let s;
    for (const i in e) {
      const n = vi[i], r = e[i];
      if (!n || !(typeof r == typeof n.value || dg[(typeof r).toUpperCase()] & n.type))
        continue;
      const {
        kind: o
      } = n;
      t && !(o & M.BROWSER || o & M.PREFERENCE) || (this.eventBus && o & M.EVENT_DISPATCH && (s || (s = /* @__PURE__ */ new Map())).set(i, r), a(this, Zn).set(i, r));
    }
    if (s)
      for (const [i, n] of s)
        this.eventBus.dispatch(i.toLowerCase(), {
          source: this,
          value: n
        });
  }
};
Zn = new WeakMap(), K(Xs, "eventBus"), b(Xs, Zn, /* @__PURE__ */ new Map()), (() => {
  for (const e in vi)
    a(Xs, Zn).set(e, vi[e].value);
  for (const [e, t] of cg)
    a(Xs, Zn).set(e, t);
  Xs._hasInvokedSet = !1, Xs._checkDisablePreferences = () => Xs.get("disablePreferences") ? !0 : (Xs._hasInvokedSet && console.warn('The Preferences may override manually set AppOptions; please use the "disablePreferences"-option to prevent that.'), !1);
})();
let ug = Xs;
var di;
class hS {
  constructor(e) {
    b(this, di, null);
    this.pageIndex = e.pageIndex;
  }
  async render(e = "display") {
    e !== "display" || a(this, di) || this._cancelled || p(this, di, new e0({
      pageIndex: this.pageIndex
    }));
  }
  cancel() {
    this._cancelled = !0, a(this, di) && (a(this, di).destroy(), p(this, di, null));
  }
  setParent(e) {
    var t;
    (t = a(this, di)) == null || t.setParent(e);
  }
  getDrawLayer() {
    return a(this, di);
  }
}
di = new WeakMap();
const Xm = {
  Document: null,
  DocumentFragment: null,
  Part: "group",
  Sect: "group",
  Div: "group",
  Aside: "note",
  NonStruct: "none",
  P: null,
  H: "heading",
  Title: null,
  FENote: "note",
  Sub: "group",
  Lbl: null,
  Span: null,
  Em: null,
  Strong: null,
  Link: "link",
  Annot: "note",
  Form: "form",
  Ruby: null,
  RB: null,
  RT: null,
  RP: null,
  Warichu: null,
  WT: null,
  WP: null,
  L: "list",
  LI: "listitem",
  LBody: null,
  Table: "table",
  TR: "row",
  TH: "columnheader",
  TD: "cell",
  THead: "columnheader",
  TBody: null,
  TFoot: null,
  Caption: null,
  Figure: "figure",
  Formula: null,
  Artifact: null
}, cS = /^H(\d+)$/;
var bl, Fs, yl, Al, wl, Jn, yi, fg, Ry, pg;
class Cy {
  constructor(e, t) {
    b(this, yi);
    b(this, bl);
    b(this, Fs, null);
    b(this, yl);
    b(this, Al, /* @__PURE__ */ new Map());
    b(this, wl);
    b(this, Jn, null);
    p(this, bl, e.getStructTree()), p(this, wl, t);
  }
  async render() {
    var i;
    if (a(this, yl))
      return a(this, yl);
    const {
      promise: e,
      resolve: t,
      reject: s
    } = Promise.withResolvers();
    p(this, yl, e);
    try {
      p(this, Fs, v(this, yi, pg).call(this, await a(this, bl)));
    } catch (n) {
      s(n);
    }
    return p(this, bl, null), (i = a(this, Fs)) == null || i.classList.add("structTree"), t(a(this, Fs)), e;
  }
  async getAriaAttributes(e) {
    try {
      return await this.render(), a(this, Al).get(e);
    } catch {
    }
    return null;
  }
  hide() {
    a(this, Fs) && !a(this, Fs).hidden && (a(this, Fs).hidden = !0);
  }
  show() {
    var e;
    (e = a(this, Fs)) != null && e.hidden && (a(this, Fs).hidden = !1);
  }
  addElementsToTextLayer() {
    var e;
    if (a(this, Jn)) {
      for (const [t, s] of a(this, Jn))
        (e = document.getElementById(t)) == null || e.append(s);
      a(this, Jn).clear(), p(this, Jn, null);
    }
  }
}
bl = new WeakMap(), Fs = new WeakMap(), yl = new WeakMap(), Al = new WeakMap(), wl = new WeakMap(), Jn = new WeakMap(), yi = new WeakSet(), fg = function(e, t) {
  const {
    alt: s,
    id: i,
    lang: n
  } = e;
  if (s !== void 0) {
    let r = !1;
    const o = uh(s);
    for (const l of e.children)
      if (l.type === "annotation") {
        let c = a(this, Al).get(l.id);
        c || (c = /* @__PURE__ */ new Map(), a(this, Al).set(l.id, c)), c.set("aria-label", o), r = !0;
      }
    r || t.setAttribute("aria-label", o);
  }
  i !== void 0 && t.setAttribute("aria-owns", i), n !== void 0 && t.setAttribute("lang", uh(n, !0));
}, Ry = function(e, t) {
  const {
    alt: s,
    bbox: i,
    children: n
  } = e, r = n == null ? void 0 : n[0];
  if (!a(this, wl) || !s || !i || (r == null ? void 0 : r.type) !== "content")
    return !1;
  const {
    id: o
  } = r;
  if (!o)
    return !1;
  t.setAttribute("aria-owns", o);
  const l = document.createElement("span");
  (a(this, Jn) || p(this, Jn, /* @__PURE__ */ new Map())).set(o, l), l.setAttribute("role", "img"), l.setAttribute("aria-label", uh(s));
  const {
    pageHeight: c,
    pageX: d,
    pageY: u
  } = a(this, wl), f = "calc(var(--scale-factor)*", {
    style: g
  } = l;
  return g.width = `${f}${i[2] - i[0]}px)`, g.height = `${f}${i[3] - i[1]}px)`, g.left = `${f}${i[0] - d}px)`, g.top = `${f}${c - i[3] + u}px)`, !0;
}, pg = function(e) {
  if (!e)
    return null;
  const t = document.createElement("span");
  if ("role" in e) {
    const {
      role: s
    } = e, i = s.match(cS);
    if (i ? (t.setAttribute("role", "heading"), t.setAttribute("aria-level", i[1])) : Xm[s] && t.setAttribute("role", Xm[s]), s === "Figure" && v(this, yi, Ry).call(this, e, t))
      return t;
  }
  if (v(this, yi, fg).call(this, e, t), e.children)
    if (e.children.length === 1 && "id" in e.children[0])
      v(this, yi, fg).call(this, e.children[0], t);
    else
      for (const s of e.children)
        t.append(v(this, yi, pg).call(this, s));
  return t;
};
var Ji, bs, qi, qn, El, yu, td, mg;
const io = class io {
  constructor() {
    b(this, td);
    b(this, Ji, !1);
    b(this, bs, null);
    b(this, qi, /* @__PURE__ */ new Map());
    b(this, qn, /* @__PURE__ */ new Map());
  }
  setTextMapping(e) {
    p(this, bs, e);
  }
  enable() {
    if (a(this, Ji))
      throw new Error("TextAccessibilityManager is already enabled.");
    if (!a(this, bs))
      throw new Error("Text divs and strings have not been set.");
    if (p(this, Ji, !0), p(this, bs, a(this, bs).slice()), a(this, bs).sort(v(io, El, yu)), a(this, qi).size > 0) {
      const e = a(this, bs);
      for (const [t, s] of a(this, qi)) {
        if (!document.getElementById(t)) {
          a(this, qi).delete(t);
          continue;
        }
        v(this, td, mg).call(this, t, e[s]);
      }
    }
    for (const [e, t] of a(this, qn))
      this.addPointerInTextLayer(e, t);
    a(this, qn).clear();
  }
  disable() {
    a(this, Ji) && (a(this, qn).clear(), p(this, bs, null), p(this, Ji, !1));
  }
  removePointerInTextLayer(e) {
    if (!a(this, Ji)) {
      a(this, qn).delete(e);
      return;
    }
    const t = a(this, bs);
    if (!t || t.length === 0)
      return;
    const {
      id: s
    } = e, i = a(this, qi).get(s);
    if (i === void 0)
      return;
    const n = t[i];
    a(this, qi).delete(s);
    let r = n.getAttribute("aria-owns");
    r != null && r.includes(s) && (r = r.split(" ").filter((o) => o !== s).join(" "), r ? n.setAttribute("aria-owns", r) : (n.removeAttribute("aria-owns"), n.setAttribute("role", "presentation")));
  }
  addPointerInTextLayer(e, t) {
    const {
      id: s
    } = e;
    if (!s)
      return null;
    if (!a(this, Ji))
      return a(this, qn).set(e, t), null;
    t && this.removePointerInTextLayer(e);
    const i = a(this, bs);
    if (!i || i.length === 0)
      return null;
    const n = yh(i, (c) => {
      var d;
      return v(d = io, El, yu).call(d, e, c) < 0;
    }), r = Math.max(0, n - 1), o = i[r];
    v(this, td, mg).call(this, s, o), a(this, qi).set(s, r);
    const l = o.parentNode;
    return l != null && l.classList.contains("markedContent") ? l.id : null;
  }
  moveElementInDOM(e, t, s, i) {
    const n = this.addPointerInTextLayer(s, i);
    if (!e.hasChildNodes())
      return e.append(t), n;
    const r = Array.from(e.childNodes).filter((c) => c !== t);
    if (r.length === 0)
      return n;
    const o = s || t, l = yh(r, (c) => {
      var d;
      return v(d = io, El, yu).call(d, o, c) < 0;
    });
    return l === 0 ? r[0].before(t) : r[l - 1].after(t), n;
  }
};
Ji = new WeakMap(), bs = new WeakMap(), qi = new WeakMap(), qn = new WeakMap(), El = new WeakSet(), yu = function(e, t) {
  const s = e.getBoundingClientRect(), i = t.getBoundingClientRect();
  if (s.width === 0 && s.height === 0)
    return 1;
  if (i.width === 0 && i.height === 0)
    return -1;
  const n = s.y, r = s.y + s.height, o = s.y + s.height / 2, l = i.y, c = i.y + i.height, d = i.y + i.height / 2;
  if (o <= l && d >= r)
    return -1;
  if (d <= n && o >= c)
    return 1;
  const u = s.x + s.width / 2, f = i.x + i.width / 2;
  return u - f;
}, td = new WeakSet(), mg = function(e, t) {
  const s = t.getAttribute("aria-owns");
  s != null && s.includes(e) || t.setAttribute("aria-owns", s ? `${s} ${e}` : e), t.removeAttribute("role");
}, b(io, El);
let gg = io;
var tr;
class dS {
  constructor({
    findController: e,
    eventBus: t,
    pageIndex: s
  }) {
    b(this, tr, null);
    this.findController = e, this.matches = [], this.eventBus = t, this.pageIdx = s, this.textDivs = null, this.textContentItemsStr = null, this.enabled = !1;
  }
  setTextMapping(e, t) {
    this.textDivs = e, this.textContentItemsStr = t;
  }
  enable() {
    if (!this.textDivs || !this.textContentItemsStr)
      throw new Error("Text divs and strings have not been set.");
    if (this.enabled)
      throw new Error("TextHighlighter is already enabled.");
    this.enabled = !0, a(this, tr) || (p(this, tr, new AbortController()), this.eventBus._on("updatetextlayermatches", (e) => {
      (e.pageIndex === this.pageIdx || e.pageIndex === -1) && this._updateMatches();
    }, {
      signal: a(this, tr).signal
    })), this._updateMatches();
  }
  disable() {
    var e;
    this.enabled && (this.enabled = !1, (e = a(this, tr)) == null || e.abort(), p(this, tr, null), this._updateMatches(!0));
  }
  _convertMatches(e, t) {
    if (!e)
      return [];
    const {
      textContentItemsStr: s
    } = this;
    let i = 0, n = 0;
    const r = s.length - 1, o = [];
    for (let l = 0, c = e.length; l < c; l++) {
      let d = e[l];
      for (; i !== r && d >= n + s[i].length; )
        n += s[i].length, i++;
      i === s.length && console.error("Could not find a matching mapping");
      const u = {
        begin: {
          divIdx: i,
          offset: d - n
        }
      };
      for (d += t[l]; i !== r && d > n + s[i].length; )
        n += s[i].length, i++;
      u.end = {
        divIdx: i,
        offset: d - n
      }, o.push(u);
    }
    return o;
  }
  _renderMatches(e) {
    if (e.length === 0)
      return;
    const {
      findController: t,
      pageIdx: s
    } = this, {
      textContentItemsStr: i,
      textDivs: n
    } = this, r = s === t.selected.pageIdx, o = t.selected.matchIdx, l = t.state.highlightAll;
    let c = null;
    const d = {
      divIdx: -1,
      offset: void 0
    };
    function u(A, E) {
      const S = A.divIdx;
      return n[S].textContent = "", f(S, 0, A.offset, E);
    }
    function f(A, E, S, T) {
      let P = n[A];
      if (P.nodeType === Node.TEXT_NODE) {
        const _ = document.createElement("span");
        P.before(_), _.append(P), n[A] = _, P = _;
      }
      const C = i[A].substring(E, S), R = document.createTextNode(C);
      if (T) {
        const _ = document.createElement("span");
        if (_.className = `${T} appended`, _.append(R), P.append(_), T.includes("selected")) {
          const {
            left: x
          } = _.getClientRects()[0], I = P.getBoundingClientRect().left;
          return x - I;
        }
        return 0;
      }
      return P.append(R), 0;
    }
    let g = o, m = g + 1;
    if (l)
      g = 0, m = e.length;
    else if (!r)
      return;
    let y = -1, w = -1;
    for (let A = g; A < m; A++) {
      const E = e[A], S = E.begin;
      if (S.divIdx === y && S.offset === w)
        continue;
      y = S.divIdx, w = S.offset;
      const T = E.end, P = r && A === o, C = P ? " selected" : "";
      let R = 0;
      if (!c || S.divIdx !== c.divIdx ? (c !== null && f(c.divIdx, c.offset, d.offset), u(S)) : f(c.divIdx, c.offset, S.offset), S.divIdx === T.divIdx)
        R = f(S.divIdx, S.offset, T.offset, "highlight" + C);
      else {
        R = f(S.divIdx, S.offset, d.offset, "highlight begin" + C);
        for (let _ = S.divIdx + 1, x = T.divIdx; _ < x; _++)
          n[_].className = "highlight middle" + C;
        u(T, "highlight end" + C);
      }
      c = T, P && t.scrollMatchIntoView({
        element: n[S.divIdx],
        selectedLeft: R,
        pageIndex: s,
        matchIndex: o
      });
    }
    c && f(c.divIdx, c.offset, d.offset);
  }
  _updateMatches(e = !1) {
    if (!this.enabled && !e)
      return;
    const {
      findController: t,
      matches: s,
      pageIdx: i
    } = this, {
      textContentItemsStr: n,
      textDivs: r
    } = this;
    let o = -1;
    for (const d of s) {
      const u = Math.max(o, d.begin.divIdx);
      for (let f = u, g = d.end.divIdx; f <= g; f++) {
        const m = r[f];
        m.textContent = n[f], m.className = "";
      }
      o = d.end.divIdx + 1;
    }
    if (!(t != null && t.highlightMatches) || e)
      return;
    const l = t.pageMatches[i] || null, c = t.pageMatchesLength[i] || null;
    this.matches = this._convertMatches(l, c), this._renderMatches(this.matches);
  }
}
tr = new WeakMap();
var ed, sd, Ia, ui, Ve, er, sf, Iy, Dl, _y, Ly;
const pn = class pn {
  constructor({
    pdfPage: e,
    highlighter: t = null,
    accessibilityManager: s = null,
    enablePermissions: i = !1,
    onAppend: n = null
  }) {
    b(this, sf);
    b(this, ed, !1);
    b(this, sd, null);
    b(this, Ia, !1);
    b(this, ui, null);
    this.pdfPage = e, this.highlighter = t, this.accessibilityManager = s, p(this, ed, i === !0), p(this, sd, n), this.div = document.createElement("div"), this.div.tabIndex = 0, this.div.className = "textLayer";
  }
  async render(e, t = null) {
    var r, o, l, c, d;
    if (a(this, Ia) && a(this, ui)) {
      a(this, ui).update({
        viewport: e,
        onBefore: this.hide.bind(this)
      }), this.show();
      return;
    }
    this.cancel(), p(this, ui, new o0({
      textContentSource: this.pdfPage.streamTextContent(t || {
        includeMarkedContent: !0,
        disableNormalization: !0
      }),
      container: this.div,
      viewport: e
    }));
    const {
      textDivs: s,
      textContentItemsStr: i
    } = a(this, ui);
    (r = this.highlighter) == null || r.setTextMapping(s, i), (o = this.accessibilityManager) == null || o.setTextMapping(s), await a(this, ui).render(), p(this, Ia, !0);
    const n = document.createElement("div");
    n.className = "endOfContent", this.div.append(n), v(this, sf, Iy).call(this, n), (l = a(this, sd)) == null || l.call(this, this.div), (c = this.highlighter) == null || c.enable(), (d = this.accessibilityManager) == null || d.enable();
  }
  hide() {
    var e;
    !this.div.hidden && a(this, Ia) && ((e = this.highlighter) == null || e.disable(), this.div.hidden = !0);
  }
  show() {
    var e;
    this.div.hidden && a(this, Ia) && (this.div.hidden = !1, (e = this.highlighter) == null || e.enable());
  }
  cancel() {
    var e, t, s, i;
    (e = a(this, ui)) == null || e.cancel(), p(this, ui, null), (t = this.highlighter) == null || t.disable(), (s = this.accessibilityManager) == null || s.disable(), v(i = pn, Dl, _y).call(i, this.div);
  }
};
ed = new WeakMap(), sd = new WeakMap(), Ia = new WeakMap(), ui = new WeakMap(), Ve = new WeakMap(), er = new WeakMap(), sf = new WeakSet(), Iy = function(e) {
  var s;
  const {
    div: t
  } = this;
  t.addEventListener("mousedown", () => {
    t.classList.add("selecting");
  }), t.addEventListener("copy", (i) => {
    if (!a(this, ed)) {
      const n = document.getSelection();
      i.clipboardData.setData("text/plain", uh(n0(n.toString())));
    }
    sg(i);
  }), a(pn, Ve).set(t, e), v(s = pn, Dl, Ly).call(s);
}, Dl = new WeakSet(), _y = function(e) {
  var t;
  a(this, Ve).delete(e), a(this, Ve).size === 0 && ((t = a(this, er)) == null || t.abort(), p(this, er, null));
}, Ly = function() {
  if (a(this, er))
    return;
  p(this, er, new AbortController());
  const {
    signal: e
  } = a(this, er), t = (r, o) => {
    o.append(r), r.style.width = "", r.style.height = "", o.classList.remove("selecting");
  };
  let s = !1;
  document.addEventListener("pointerdown", () => {
    s = !0;
  }, {
    signal: e
  }), document.addEventListener("pointerup", () => {
    s = !1, a(this, Ve).forEach(t);
  }, {
    signal: e
  }), window.addEventListener("blur", () => {
    s = !1, a(this, Ve).forEach(t);
  }, {
    signal: e
  }), document.addEventListener("keyup", () => {
    s || a(this, Ve).forEach(t);
  }, {
    signal: e
  });
  var i, n;
  document.addEventListener("selectionchange", () => {
    var g;
    const r = document.getSelection();
    if (r.rangeCount === 0) {
      a(this, Ve).forEach(t);
      return;
    }
    const o = /* @__PURE__ */ new Set();
    for (let m = 0; m < r.rangeCount; m++) {
      const y = r.getRangeAt(m);
      for (const w of a(this, Ve).keys())
        !o.has(w) && y.intersectsNode(w) && o.add(w);
    }
    for (const [m, y] of a(this, Ve))
      o.has(m) ? m.classList.add("selecting") : t(y, m);
    if (i ?? (i = getComputedStyle(a(this, Ve).values().next().value).getPropertyValue("-moz-user-select") === "none"), i)
      return;
    const l = r.getRangeAt(0), c = n && (l.compareBoundaryPoints(Range.END_TO_END, n) === 0 || l.compareBoundaryPoints(Range.START_TO_END, n) === 0);
    let d = c ? l.startContainer : l.endContainer;
    d.nodeType === Node.TEXT_NODE && (d = d.parentNode);
    const u = (g = d.parentElement) == null ? void 0 : g.closest(".textLayer"), f = a(this, Ve).get(u);
    f && (f.style.width = u.style.width, f.style.height = u.style.height, d.parentElement.insertBefore(f, c ? d : d.nextSibling)), n = l.cloneRange();
  }, {
    signal: e
  });
}, b(pn, Dl), b(pn, Ve, /* @__PURE__ */ new Map()), b(pn, er, null);
let Nu = pn;
class My {
  constructor({
    pdfPage: e,
    annotationStorage: t = null,
    linkService: s,
    xfaHtml: i = null
  }) {
    this.pdfPage = e, this.annotationStorage = t, this.linkService = s, this.xfaHtml = i, this.div = null, this._cancelled = !1;
  }
  async render(e, t = "display") {
    if (t === "print") {
      const n = {
        viewport: e.clone({
          dontFlip: !0
        }),
        div: this.div,
        xfaHtml: this.xfaHtml,
        annotationStorage: this.annotationStorage,
        linkService: this.linkService,
        intent: t
      };
      return this.div = document.createElement("div"), n.div = this.div, Rf.render(n);
    }
    const s = await this.pdfPage.getXfa();
    if (this._cancelled || !s)
      return {
        textDivs: []
      };
    const i = {
      viewport: e.clone({
        dontFlip: !0
      }),
      div: this.div,
      xfaHtml: s,
      annotationStorage: this.annotationStorage,
      linkService: this.linkService,
      intent: t
    };
    return this.div ? Rf.update(i) : (this.div = document.createElement("div"), i.div = this.div, Rf.render(i));
  }
  cancel() {
    this._cancelled = !0;
  }
  hide() {
    this.div && (this.div.hidden = !0);
  }
}
const uS = {
  annotationEditorUIManager: null,
  annotationStorage: null,
  downloadManager: null,
  enableScripting: !1,
  fieldObjectsPromise: null,
  findController: null,
  hasJSActionsPromise: null,
  get linkService() {
    return new jg();
  }
}, fS = /* @__PURE__ */ new Map([["canvasWrapper", 0], ["textLayer", 1], ["annotationLayer", 2], ["annotationEditorLayer", 3], ["xfaLayer", 3]]);
var _a, sr, id, La, nd, ir, nr, Sl, rd, ad, od, Ma, xl, Tl, tn, rr, rt, eo, Au, lh, vg, bg, yg, Ag, wg, Ny, Dy, Eg, Sg;
class Oy {
  constructor(e) {
    b(this, rt);
    b(this, _a, nn.ENABLE_FORMS);
    b(this, sr, null);
    b(this, id, !1);
    b(this, La, !1);
    b(this, nd, !1);
    b(this, ir, null);
    b(this, nr, null);
    b(this, Sl, null);
    b(this, rd, null);
    b(this, ad, 1);
    b(this, od, 1);
    b(this, Ma, null);
    b(this, xl, jt.INITIAL);
    b(this, Tl, gi.ENABLE);
    b(this, tn, {
      directDrawing: !0,
      initialOptionalContent: !0,
      regularAnnotations: !0
    });
    b(this, rr, [null, null, null, null]);
    var n, r;
    const t = e.container, s = e.defaultViewport;
    this.id = e.id, this.renderingId = "page" + this.id, p(this, ir, e.layerProperties || uS), this.pdfPage = null, this.pageLabel = null, this.rotation = 0, this.scale = e.scale || ey, this.viewport = s, this.pdfPageRotate = s.rotation, this._optionalContentConfigPromise = e.optionalContentConfigPromise || null, p(this, Tl, e.textLayerMode ?? gi.ENABLE), p(this, _a, e.annotationMode ?? nn.ENABLE_FORMS), this.imageResourcesPath = e.imageResourcesPath || "", this.maxCanvasPixels = e.maxCanvasPixels ?? ug.get("maxCanvasPixels"), this.pageColors = e.pageColors || null, p(this, id, e.enableHWA || !1), this.eventBus = e.eventBus, this.renderingQueue = e.renderingQueue, this.l10n = e.l10n, this.l10n || (this.l10n = new Ol()), this.renderTask = null, this.resume = null, this._isStandalone = !((n = this.renderingQueue) != null && n.hasViewer()), this._container = t, this._annotationCanvasMap = null, this.annotationLayer = null, this.annotationEditorLayer = null, this.textLayer = null, this.xfaLayer = null, this.structTreeLayer = null, this.drawLayer = null;
    const i = document.createElement("div");
    if (i.className = "page", i.setAttribute("data-page-number", this.id), i.setAttribute("role", "region"), i.setAttribute("data-l10n-id", "pdfjs-page-landmark"), i.setAttribute("data-l10n-args", JSON.stringify({
      page: this.id
    })), this.div = i, v(this, rt, Au).call(this), t == null || t.append(i), this._isStandalone) {
      t == null || t.style.setProperty("--scale-factor", this.scale * Pi.PDF_TO_CSS_UNITS), (r = this.pageColors) != null && r.background && (t == null || t.style.setProperty("--page-bg-color", this.pageColors.background));
      const {
        optionalContentConfigPromise: o
      } = e;
      o && o.then((l) => {
        o === this._optionalContentConfigPromise && (a(this, tn).initialOptionalContent = l.hasInitialVisibility);
      }), e.l10n || this.l10n.translate(this.div);
    }
  }
  get renderingState() {
    return a(this, xl);
  }
  set renderingState(e) {
    if (e !== a(this, xl))
      switch (p(this, xl, e), a(this, nr) && (clearTimeout(a(this, nr)), p(this, nr, null)), e) {
        case jt.PAUSED:
          this.div.classList.remove("loading");
          break;
        case jt.RUNNING:
          this.div.classList.add("loadingIcon"), p(this, nr, setTimeout(() => {
            this.div.classList.add("loading"), p(this, nr, null);
          }, 0));
          break;
        case jt.INITIAL:
        case jt.FINISHED:
          this.div.classList.remove("loadingIcon", "loading");
          break;
      }
  }
  setPdfPage(e) {
    var s, i, n, r;
    this._isStandalone && (((s = this.pageColors) == null ? void 0 : s.foreground) === "CanvasText" || ((i = this.pageColors) == null ? void 0 : i.background) === "Canvas") && ((n = this._container) == null || n.style.setProperty("--hcm-highlight-filter", e.filterFactory.addHighlightHCMFilter("highlight", "CanvasText", "Canvas", "HighlightText", "Highlight")), (r = this._container) == null || r.style.setProperty("--hcm-highlight-selected-filter", e.filterFactory.addHighlightHCMFilter("highlight_selected", "CanvasText", "Canvas", "HighlightText", "Highlight"))), this.pdfPage = e, this.pdfPageRotate = e.rotate;
    const t = (this.rotation + this.pdfPageRotate) % 360;
    this.viewport = e.getViewport({
      scale: this.scale * Pi.PDF_TO_CSS_UNITS,
      rotation: t
    }), v(this, rt, Au).call(this), this.reset();
  }
  destroy() {
    var e;
    this.reset(), (e = this.pdfPage) == null || e.cleanup();
  }
  hasEditableAnnotations() {
    var e;
    return !!((e = this.annotationLayer) != null && e.hasEditableAnnotations());
  }
  get _textHighlighter() {
    return Mu(this, "_textHighlighter", new dS({
      pageIndex: this.id - 1,
      eventBus: this.eventBus,
      findController: a(this, ir).findController
    }));
  }
  reset({
    keepAnnotationLayer: e = !1,
    keepAnnotationEditorLayer: t = !1,
    keepXfaLayer: s = !1,
    keepTextLayer: i = !1,
    keepCanvasWrapper: n = !1
  } = {}) {
    var g, m, y, w, A;
    this.cancelRendering({
      keepAnnotationLayer: e,
      keepAnnotationEditorLayer: t,
      keepXfaLayer: s,
      keepTextLayer: i
    }), this.renderingState = jt.INITIAL;
    const r = this.div, o = r.childNodes, l = e && ((g = this.annotationLayer) == null ? void 0 : g.div) || null, c = t && ((m = this.annotationEditorLayer) == null ? void 0 : m.div) || null, d = s && ((y = this.xfaLayer) == null ? void 0 : y.div) || null, u = i && ((w = this.textLayer) == null ? void 0 : w.div) || null, f = n && a(this, sr) || null;
    for (let E = o.length - 1; E >= 0; E--) {
      const S = o[E];
      switch (S) {
        case l:
        case c:
        case d:
        case u:
        case f:
          continue;
      }
      S.remove();
      const T = a(this, rr).indexOf(S);
      T >= 0 && (a(this, rr)[T] = null);
    }
    r.removeAttribute("data-loaded"), l && this.annotationLayer.hide(), c && this.annotationEditorLayer.hide(), d && this.xfaLayer.hide(), u && this.textLayer.hide(), (A = this.structTreeLayer) == null || A.hide(), !n && a(this, sr) && (p(this, sr, null), v(this, rt, Eg).call(this));
  }
  toggleEditingMode(e) {
    this.hasEditableAnnotations() && (p(this, nd, e), this.reset({
      keepAnnotationLayer: !0,
      keepAnnotationEditorLayer: !0,
      keepXfaLayer: !0,
      keepTextLayer: !0,
      keepCanvasWrapper: !0
    }));
  }
  update({
    scale: e = 0,
    rotation: t = null,
    optionalContentConfigPromise: s = null,
    drawingDelay: i = -1
  }) {
    var r;
    this.scale = e || this.scale, typeof t == "number" && (this.rotation = t), s instanceof Promise && (this._optionalContentConfigPromise = s, s.then((o) => {
      s === this._optionalContentConfigPromise && (a(this, tn).initialOptionalContent = o.hasInitialVisibility);
    })), a(this, tn).directDrawing = !0;
    const n = (this.rotation + this.pdfPageRotate) % 360;
    if (this.viewport = this.viewport.clone({
      scale: this.scale * Pi.PDF_TO_CSS_UNITS,
      rotation: n
    }), v(this, rt, Au).call(this), this._isStandalone && ((r = this._container) == null || r.style.setProperty("--scale-factor", this.viewport.scale)), this.canvas) {
      let o = !1;
      if (a(this, La)) {
        if (this.maxCanvasPixels === 0)
          o = !0;
        else if (this.maxCanvasPixels > 0) {
          const {
            width: c,
            height: d
          } = this.viewport, {
            sx: u,
            sy: f
          } = this.outputScale;
          o = (Math.floor(c) * u | 0) * (Math.floor(d) * f | 0) > this.maxCanvasPixels;
        }
      }
      const l = i >= 0 && i < 1e3;
      if (l || o) {
        if (l && !o && this.renderingState !== jt.FINISHED && (this.cancelRendering({
          keepAnnotationLayer: !0,
          keepAnnotationEditorLayer: !0,
          keepXfaLayer: !0,
          keepTextLayer: !0,
          cancelExtraDelay: i
        }), this.renderingState = jt.FINISHED, a(this, tn).directDrawing = !1), this.cssTransform({
          redrawAnnotationLayer: !0,
          redrawAnnotationEditorLayer: !0,
          redrawXfaLayer: !0,
          redrawTextLayer: !l,
          hideTextLayer: l
        }), l)
          return;
        this.eventBus.dispatch("pagerendered", {
          source: this,
          pageNumber: this.id,
          cssTransform: !0,
          timestamp: performance.now(),
          error: a(this, Ma)
        });
        return;
      }
    }
    this.cssTransform({}), this.reset({
      keepAnnotationLayer: !0,
      keepAnnotationEditorLayer: !0,
      keepXfaLayer: !0,
      keepTextLayer: !0,
      keepCanvasWrapper: !0
    });
  }
  cancelRendering({
    keepAnnotationLayer: e = !1,
    keepAnnotationEditorLayer: t = !1,
    keepXfaLayer: s = !1,
    keepTextLayer: i = !1,
    cancelExtraDelay: n = 0
  } = {}) {
    var r;
    this.renderTask && (this.renderTask.cancel(n), this.renderTask = null), this.resume = null, this.textLayer && (!i || !this.textLayer.div) && (this.textLayer.cancel(), this.textLayer = null), this.annotationLayer && (!e || !this.annotationLayer.div) && (this.annotationLayer.cancel(), this.annotationLayer = null, this._annotationCanvasMap = null), this.structTreeLayer && !this.textLayer && (this.structTreeLayer = null), this.annotationEditorLayer && (!t || !this.annotationEditorLayer.div) && (this.drawLayer && (this.drawLayer.cancel(), this.drawLayer = null), this.annotationEditorLayer.cancel(), this.annotationEditorLayer = null), this.xfaLayer && (!s || !this.xfaLayer.div) && (this.xfaLayer.cancel(), this.xfaLayer = null, (r = this._textHighlighter) == null || r.disable());
  }
  cssTransform({
    redrawAnnotationLayer: e = !1,
    redrawAnnotationEditorLayer: t = !1,
    redrawXfaLayer: s = !1,
    redrawTextLayer: i = !1,
    hideTextLayer: n = !1
  }) {
    var l;
    const {
      canvas: r
    } = this;
    if (!r)
      return;
    const o = a(this, Sl);
    if (this.viewport !== o) {
      const c = (360 + this.viewport.rotation - o.rotation) % 360;
      if (c === 90 || c === 270) {
        const {
          width: d,
          height: u
        } = this.viewport, f = u / d, g = d / u;
        r.style.transform = `rotate(${c}deg) scale(${f},${g})`;
      } else
        r.style.transform = c === 0 ? "" : `rotate(${c}deg)`;
    }
    e && this.annotationLayer && v(this, rt, vg).call(this), t && this.annotationEditorLayer && (this.drawLayer && v(this, rt, yg).call(this), v(this, rt, bg).call(this)), s && this.xfaLayer && v(this, rt, Ag).call(this), this.textLayer && (n ? (this.textLayer.hide(), (l = this.structTreeLayer) == null || l.hide()) : i && v(this, rt, wg).call(this));
  }
  get width() {
    return this.viewport.width;
  }
  get height() {
    return this.viewport.height;
  }
  getPagePoint(e, t) {
    return this.viewport.convertToPdfPoint(e, t);
  }
  async draw() {
    this.renderingState !== jt.INITIAL && (console.error("Must be in new state before drawing"), this.reset());
    const {
      div: e,
      l10n: t,
      pageColors: s,
      pdfPage: i,
      viewport: n
    } = this;
    if (!i)
      throw this.renderingState = jt.FINISHED, new Error("pdfPage is not loaded");
    this.renderingState = jt.RUNNING;
    let r = a(this, sr);
    if (r || (r = p(this, sr, document.createElement("div")), r.classList.add("canvasWrapper"), v(this, rt, eo).call(this, r, "canvasWrapper")), !this.textLayer && a(this, Tl) !== gi.DISABLE && !i.isPureXfa && (this._accessibilityManager || (this._accessibilityManager = new gg()), this.textLayer = new Nu({
      pdfPage: i,
      highlighter: this._textHighlighter,
      accessibilityManager: this._accessibilityManager,
      enablePermissions: a(this, Tl) === gi.ENABLE_PERMISSIONS,
      onAppend: (L) => {
        this.l10n.pause(), v(this, rt, eo).call(this, L, "textLayer"), this.l10n.resume();
      }
    })), !this.annotationLayer && a(this, _a) !== nn.DISABLE) {
      const {
        annotationStorage: L,
        annotationEditorUIManager: j,
        downloadManager: k,
        enableScripting: F,
        fieldObjectsPromise: Y,
        hasJSActionsPromise: N,
        linkService: D
      } = a(this, ir);
      this._annotationCanvasMap || (this._annotationCanvasMap = /* @__PURE__ */ new Map()), this.annotationLayer = new uy({
        pdfPage: i,
        annotationStorage: L,
        imageResourcesPath: this.imageResourcesPath,
        renderForms: a(this, _a) === nn.ENABLE_FORMS,
        linkService: D,
        downloadManager: k,
        enableScripting: F,
        hasJSActionsPromise: N,
        fieldObjectsPromise: Y,
        annotationCanvasMap: this._annotationCanvasMap,
        accessibilityManager: this._accessibilityManager,
        annotationEditorUIManager: j,
        onAppend: (et) => {
          v(this, rt, eo).call(this, et, "annotationLayer");
        }
      });
    }
    const o = (L) => {
      if (m == null || m(!1), this.renderingQueue && !this.renderingQueue.isHighestPriority(this)) {
        this.renderingState = jt.PAUSED, this.resume = () => {
          this.renderingState = jt.RUNNING, L();
        };
        return;
      }
      L();
    }, {
      width: l,
      height: c
    } = n, d = document.createElement("canvas");
    d.setAttribute("role", "presentation");
    const u = !!(s != null && s.background && (s != null && s.foreground)), f = this.canvas, g = !f && !u;
    this.canvas = d, p(this, Sl, n);
    let m = (L) => {
      if (g) {
        r.prepend(d), m = null;
        return;
      }
      L && (f ? (f.replaceWith(d), f.width = f.height = 0) : r.prepend(d), m = null);
    };
    const y = d.getContext("2d", {
      alpha: !1,
      willReadFrequently: !a(this, id)
    }), w = this.outputScale = new r0();
    if (this.maxCanvasPixels === 0) {
      const L = 1 / this.scale;
      w.sx *= L, w.sy *= L, p(this, La, !0);
    } else if (this.maxCanvasPixels > 0) {
      const L = l * c, j = Math.sqrt(this.maxCanvasPixels / L);
      w.sx > j || w.sy > j ? (w.sx = j, w.sy = j, p(this, La, !0)) : p(this, La, !1);
    }
    const A = wm(w.sx), E = wm(w.sy), S = d.width = _d(Ld(l * w.sx), A[0]), T = d.height = _d(Ld(c * w.sy), E[0]), P = _d(Ld(l), A[1]), C = _d(Ld(c), E[1]);
    w.sx = S / P, w.sy = T / C, a(this, ad) !== A[1] && (e.style.setProperty("--scale-round-x", `${A[1]}px`), p(this, ad, A[1])), a(this, od) !== E[1] && (e.style.setProperty("--scale-round-y", `${E[1]}px`), p(this, od, E[1]));
    const R = w.scaled ? [w.sx, 0, 0, w.sy, 0, 0] : null, _ = {
      canvasContext: y,
      transform: R,
      viewport: n,
      annotationMode: a(this, _a),
      optionalContentConfigPromise: this._optionalContentConfigPromise,
      annotationCanvasMap: this._annotationCanvasMap,
      pageColors: s,
      isEditing: a(this, nd)
    }, x = this.renderTask = i.render(_);
    x.onContinue = o;
    const I = x.promise.then(async () => {
      var j;
      m == null || m(!0), await v(this, rt, Sg).call(this, x), this.structTreeLayer || (this.structTreeLayer = new Cy(i, n.rawDims)), v(this, rt, wg).call(this), this.annotationLayer && await v(this, rt, vg).call(this);
      const {
        annotationEditorUIManager: L
      } = a(this, ir);
      L && (this.drawLayer || (this.drawLayer = new hS({
        pageIndex: this.id
      })), await v(this, rt, yg).call(this), this.drawLayer.setParent(r), this.annotationEditorLayer || (this.annotationEditorLayer = new lS({
        uiManager: L,
        pdfPage: i,
        l10n: t,
        structTreeLayer: this.structTreeLayer,
        accessibilityManager: this._accessibilityManager,
        annotationLayer: (j = this.annotationLayer) == null ? void 0 : j.annotationLayer,
        textLayer: this.textLayer,
        drawLayer: this.drawLayer.getDrawLayer(),
        onAppend: (k) => {
          v(this, rt, eo).call(this, k, "annotationEditorLayer");
        }
      })), v(this, rt, bg).call(this));
    }, (L) => (L instanceof eg ? (f == null || f.remove(), v(this, rt, Eg).call(this)) : m == null || m(!0), v(this, rt, Sg).call(this, x, L)));
    if (i.isPureXfa) {
      if (!this.xfaLayer) {
        const {
          annotationStorage: L,
          linkService: j
        } = a(this, ir);
        this.xfaLayer = new My({
          pdfPage: i,
          annotationStorage: L,
          linkService: j
        });
      }
      v(this, rt, Ag).call(this);
    }
    return e.setAttribute("data-loaded", !0), this.eventBus.dispatch("pagerender", {
      source: this,
      pageNumber: this.id
    }), I;
  }
  setPageLabel(e) {
    this.pageLabel = typeof e == "string" ? e : null, this.div.setAttribute("data-l10n-args", JSON.stringify({
      page: this.pageLabel ?? this.id
    })), this.pageLabel !== null ? this.div.setAttribute("data-page-label", this.pageLabel) : this.div.removeAttribute("data-page-label");
  }
  get thumbnailCanvas() {
    const {
      directDrawing: e,
      initialOptionalContent: t,
      regularAnnotations: s
    } = a(this, tn);
    return e && t && s ? this.canvas : null;
  }
}
_a = new WeakMap(), sr = new WeakMap(), id = new WeakMap(), La = new WeakMap(), nd = new WeakMap(), ir = new WeakMap(), nr = new WeakMap(), Sl = new WeakMap(), rd = new WeakMap(), ad = new WeakMap(), od = new WeakMap(), Ma = new WeakMap(), xl = new WeakMap(), Tl = new WeakMap(), tn = new WeakMap(), rr = new WeakMap(), rt = new WeakSet(), eo = function(e, t) {
  const s = fS.get(t), i = a(this, rr)[s];
  if (a(this, rr)[s] = e, i) {
    i.replaceWith(e);
    return;
  }
  for (let n = s - 1; n >= 0; n--) {
    const r = a(this, rr)[n];
    if (r) {
      r.after(e);
      return;
    }
  }
  this.div.prepend(e);
}, Au = function() {
  const {
    viewport: e
  } = this;
  if (this.pdfPage) {
    if (a(this, rd) === e.rotation)
      return;
    p(this, rd, e.rotation);
  }
  a0(this.div, e, !0, !1);
}, lh = function(e, t) {
  this.eventBus.dispatch(e, {
    source: this,
    pageNumber: this.id,
    error: t
  });
}, vg = async function() {
  let e = null;
  try {
    await this.annotationLayer.render(this.viewport, {
      structTreeLayer: this.structTreeLayer
    }, "display");
  } catch (t) {
    console.error("#renderAnnotationLayer:", t), e = t;
  } finally {
    v(this, rt, lh).call(this, "annotationlayerrendered", e);
  }
}, bg = async function() {
  let e = null;
  try {
    await this.annotationEditorLayer.render(this.viewport, "display");
  } catch (t) {
    console.error("#renderAnnotationEditorLayer:", t), e = t;
  } finally {
    v(this, rt, lh).call(this, "annotationeditorlayerrendered", e);
  }
}, yg = async function() {
  try {
    await this.drawLayer.render("display");
  } catch (e) {
    console.error("#renderDrawLayer:", e);
  }
}, Ag = async function() {
  var t;
  let e = null;
  try {
    const s = await this.xfaLayer.render(this.viewport, "display");
    s != null && s.textDivs && this._textHighlighter && v(this, rt, Dy).call(this, s.textDivs);
  } catch (s) {
    console.error("#renderXfaLayer:", s), e = s;
  } finally {
    (t = this.xfaLayer) != null && t.div && (this.l10n.pause(), v(this, rt, eo).call(this, this.xfaLayer.div, "xfaLayer"), this.l10n.resume()), v(this, rt, lh).call(this, "xfalayerrendered", e);
  }
}, wg = async function() {
  if (!this.textLayer)
    return;
  let e = null;
  try {
    await this.textLayer.render(this.viewport);
  } catch (t) {
    if (t instanceof QE)
      return;
    console.error("#renderTextLayer:", t), e = t;
  }
  v(this, rt, lh).call(this, "textlayerrendered", e), v(this, rt, Ny).call(this);
}, Ny = async function() {
  var t, s, i;
  if (!this.textLayer)
    return;
  const e = await ((t = this.structTreeLayer) == null ? void 0 : t.render());
  e && (this.l10n.pause(), (s = this.structTreeLayer) == null || s.addElementsToTextLayer(), this.canvas && e.parentNode !== this.canvas && this.canvas.append(e), this.l10n.resume()), (i = this.structTreeLayer) == null || i.show();
}, Dy = async function(e) {
  const t = await this.pdfPage.getTextContent(), s = [];
  for (const i of t.items)
    s.push(i.str);
  this._textHighlighter.setTextMapping(e, s), this._textHighlighter.enable();
}, Eg = function() {
  const {
    canvas: e
  } = this;
  e && (e.remove(), e.width = e.height = 0, this.canvas = null, p(this, Sl, null));
}, Sg = async function(e, t = null) {
  if (e === this.renderTask && (this.renderTask = null), t instanceof eg) {
    p(this, Ma, null);
    return;
  }
  if (p(this, Ma, t), this.renderingState = jt.FINISHED, a(this, tn).regularAnnotations = !e.separateAnnots, this.eventBus.dispatch("pagerendered", {
    source: this,
    pageNumber: this.id,
    cssTransform: !1,
    timestamp: performance.now(),
    error: a(this, Ma)
  }), t)
    throw t;
};
async function pS(h) {
  const e = "", t = e.split("#", 1)[0];
  let {
    info: s,
    metadata: i,
    contentDispositionFilename: n,
    contentLength: r
  } = await h.getMetadata();
  if (!r) {
    const {
      length: o
    } = await h.getDownloadInfo();
    r = o;
  }
  return {
    ...s,
    baseURL: t,
    filesize: r,
    filename: n || s0(e),
    metadata: i == null ? void 0 : i.getRaw(),
    authors: i == null ? void 0 : i.get("dc:creator"),
    numPages: h.numPages,
    URL: e
  };
}
class gS {
  constructor(e) {
    this._ready = new Promise((t, s) => {
      import(
        /*webpackIgnore: true*/
        e
      ).then((n) => {
        t(n.QuickJSSandbox());
      }).catch(s);
    });
  }
  async createSandbox(e) {
    (await this._ready).create(e);
  }
  async dispatchEventInSandbox(e) {
    const t = await this._ready;
    setTimeout(() => t.dispatchEvent(e), 0);
  }
  async destroySandbox() {
    (await this._ready).nukeSandbox();
  }
}
var fi, Oa, ld, Na, Da, hd, Me, en, Pl, Zt, ys, le, ky, wu, xg, Fy, hh;
class mS {
  constructor({
    eventBus: e,
    externalServices: t = null,
    docProperties: s = null
  }) {
    b(this, le);
    b(this, fi, null);
    b(this, Oa, null);
    b(this, ld, null);
    b(this, Na, null);
    b(this, Da, null);
    b(this, hd, null);
    b(this, Me, null);
    b(this, en, null);
    b(this, Pl, !1);
    b(this, Zt, null);
    b(this, ys, null);
    p(this, Da, e), p(this, hd, t), p(this, ld, s);
  }
  setViewer(e) {
    p(this, en, e);
  }
  async setDocument(e) {
    var o;
    if (a(this, Me) && await v(this, le, hh).call(this), p(this, Me, e), !e)
      return;
    const [t, s, i] = await Promise.all([e.getFieldObjects(), e.getCalculationOrderIds(), e.getJSActions()]);
    if (!t && !i) {
      await v(this, le, hh).call(this);
      return;
    }
    if (e !== a(this, Me))
      return;
    try {
      p(this, Zt, v(this, le, Fy).call(this));
    } catch (l) {
      console.error("setDocument:", l), await v(this, le, hh).call(this);
      return;
    }
    const n = a(this, Da);
    p(this, Na, new AbortController());
    const {
      signal: r
    } = a(this, Na);
    n._on("updatefromsandbox", (l) => {
      (l == null ? void 0 : l.source) === window && v(this, le, ky).call(this, l.detail);
    }, {
      signal: r
    }), n._on("dispatcheventinsandbox", (l) => {
      var c;
      (c = a(this, Zt)) == null || c.dispatchEventInSandbox(l.detail);
    }, {
      signal: r
    }), n._on("pagechanging", ({
      pageNumber: l,
      previous: c
    }) => {
      l !== c && (v(this, le, xg).call(this, c), v(this, le, wu).call(this, l));
    }, {
      signal: r
    }), n._on("pagerendered", ({
      pageNumber: l
    }) => {
      this._pageOpenPending.has(l) && l === a(this, en).currentPageNumber && v(this, le, wu).call(this, l);
    }, {
      signal: r
    }), n._on("pagesdestroy", async () => {
      var l, c;
      await v(this, le, xg).call(this, a(this, en).currentPageNumber), await ((l = a(this, Zt)) == null ? void 0 : l.dispatchEventInSandbox({
        id: "doc",
        name: "WillClose"
      })), (c = a(this, fi)) == null || c.resolve();
    }, {
      signal: r
    });
    try {
      const l = await a(this, ld).call(this, e);
      if (e !== a(this, Me))
        return;
      await a(this, Zt).createSandbox({
        objects: t,
        calculationOrder: s,
        appInfo: {
          platform: navigator.platform,
          language: navigator.language
        },
        docInfo: {
          ...l,
          actions: i
        }
      }), n.dispatch("sandboxcreated", {
        source: this
      });
    } catch (l) {
      console.error("setDocument:", l), await v(this, le, hh).call(this);
      return;
    }
    await ((o = a(this, Zt)) == null ? void 0 : o.dispatchEventInSandbox({
      id: "doc",
      name: "Open"
    })), await v(this, le, wu).call(this, a(this, en).currentPageNumber, !0), Promise.resolve().then(() => {
      e === a(this, Me) && p(this, Pl, !0);
    });
  }
  async dispatchWillSave() {
    var e;
    return (e = a(this, Zt)) == null ? void 0 : e.dispatchEventInSandbox({
      id: "doc",
      name: "WillSave"
    });
  }
  async dispatchDidSave() {
    var e;
    return (e = a(this, Zt)) == null ? void 0 : e.dispatchEventInSandbox({
      id: "doc",
      name: "DidSave"
    });
  }
  async dispatchWillPrint() {
    var e;
    if (a(this, Zt)) {
      await ((e = a(this, ys)) == null ? void 0 : e.promise), p(this, ys, Promise.withResolvers());
      try {
        await a(this, Zt).dispatchEventInSandbox({
          id: "doc",
          name: "WillPrint"
        });
      } catch (t) {
        throw a(this, ys).resolve(), p(this, ys, null), t;
      }
      await a(this, ys).promise;
    }
  }
  async dispatchDidPrint() {
    var e;
    return (e = a(this, Zt)) == null ? void 0 : e.dispatchEventInSandbox({
      id: "doc",
      name: "DidPrint"
    });
  }
  get destroyPromise() {
    var e;
    return ((e = a(this, Oa)) == null ? void 0 : e.promise) || null;
  }
  get ready() {
    return a(this, Pl);
  }
  get _pageOpenPending() {
    return Mu(this, "_pageOpenPending", /* @__PURE__ */ new Set());
  }
  get _visitedPages() {
    return Mu(this, "_visitedPages", /* @__PURE__ */ new Map());
  }
}
fi = new WeakMap(), Oa = new WeakMap(), ld = new WeakMap(), Na = new WeakMap(), Da = new WeakMap(), hd = new WeakMap(), Me = new WeakMap(), en = new WeakMap(), Pl = new WeakMap(), Zt = new WeakMap(), ys = new WeakMap(), le = new WeakSet(), ky = async function(e) {
  var c, d;
  const t = a(this, en), s = t.isInPresentationMode || t.isChangingPresentationMode, {
    id: i,
    siblings: n,
    command: r,
    value: o
  } = e;
  if (!i) {
    switch (r) {
      case "clear":
        console.clear();
        break;
      case "error":
        console.error(o);
        break;
      case "layout":
        if (!s) {
          const u = PE(o);
          t.spreadMode = u.spreadMode;
        }
        break;
      case "page-num":
        t.currentPageNumber = o + 1;
        break;
      case "print":
        await t.pagesPromise, a(this, Da).dispatch("print", {
          source: this
        });
        break;
      case "println":
        console.log(o);
        break;
      case "zoom":
        s || (t.currentScaleValue = o);
        break;
      case "SaveAs":
        a(this, Da).dispatch("download", {
          source: this
        });
        break;
      case "FirstPage":
        t.currentPageNumber = 1;
        break;
      case "LastPage":
        t.currentPageNumber = t.pagesCount;
        break;
      case "NextPage":
        t.nextPage();
        break;
      case "PrevPage":
        t.previousPage();
        break;
      case "ZoomViewIn":
        s || t.increaseScale();
        break;
      case "ZoomViewOut":
        s || t.decreaseScale();
        break;
      case "WillPrintFinished":
        (c = a(this, ys)) == null || c.resolve(), p(this, ys, null);
        break;
    }
    return;
  }
  if (s && e.focus)
    return;
  delete e.id, delete e.siblings;
  const l = n ? [i, ...n] : [i];
  for (const u of l) {
    const f = document.querySelector(`[data-element-id="${u}"]`);
    f ? f.dispatchEvent(new CustomEvent("updatefromsandbox", {
      detail: e
    })) : (d = a(this, Me)) == null || d.annotationStorage.setValue(u, e);
  }
}, wu = async function(e, t = !1) {
  const s = a(this, Me), i = this._visitedPages;
  if (t && p(this, fi, Promise.withResolvers()), !a(this, fi))
    return;
  const n = a(this, en).getPageView(e - 1);
  if ((n == null ? void 0 : n.renderingState) !== jt.FINISHED) {
    this._pageOpenPending.add(e);
    return;
  }
  this._pageOpenPending.delete(e);
  const r = (async () => {
    var l, c;
    const o = await (i.has(e) ? null : (l = n.pdfPage) == null ? void 0 : l.getJSActions());
    s === a(this, Me) && await ((c = a(this, Zt)) == null ? void 0 : c.dispatchEventInSandbox({
      id: "page",
      name: "PageOpen",
      pageNumber: e,
      actions: o
    }));
  })();
  i.set(e, r);
}, xg = async function(e) {
  var n;
  const t = a(this, Me), s = this._visitedPages;
  if (!a(this, fi) || this._pageOpenPending.has(e))
    return;
  const i = s.get(e);
  i && (s.set(e, null), await i, t === a(this, Me) && await ((n = a(this, Zt)) == null ? void 0 : n.dispatchEventInSandbox({
    id: "page",
    name: "PageClose",
    pageNumber: e
  })));
}, Fy = function() {
  if (p(this, Oa, Promise.withResolvers()), a(this, Zt))
    throw new Error("#initScripting: Scripting already exists.");
  return a(this, hd).createScripting();
}, hh = async function() {
  var e, t, s, i;
  if (!a(this, Zt)) {
    p(this, Me, null), (e = a(this, Oa)) == null || e.resolve();
    return;
  }
  a(this, fi) && (await Promise.race([a(this, fi).promise, new Promise((n) => {
    setTimeout(n, 1e3);
  })]).catch(() => {
  }), p(this, fi, null)), p(this, Me, null);
  try {
    await a(this, Zt).destroySandbox();
  } catch {
  }
  (t = a(this, ys)) == null || t.reject(new Error("Scripting destroyed.")), p(this, ys, null), (s = a(this, Na)) == null || s.abort(), p(this, Na, null), this._pageOpenPending.clear(), this._visitedPages.clear(), p(this, Zt, null), p(this, Pl, !1), (i = a(this, Oa)) == null || i.resolve();
};
class vS extends mS {
  constructor(e) {
    e.externalServices || window.addEventListener("updatefromsandbox", (t) => {
      e.eventBus.dispatch("updatefromsandbox", {
        source: window,
        detail: t.detail
      });
    }), e.externalServices || (e.externalServices = {
      createScripting: () => new gS(e.sandboxBundleSrc)
    }), e.docProperties || (e.docProperties = (t) => pS(t)), super(e);
  }
}
const bS = 3e4;
class yS {
  constructor() {
    this.pdfViewer = null, this.pdfThumbnailViewer = null, this.onIdle = null, this.highestPriorityPage = null, this.idleTimeout = null, this.printing = !1, this.isThumbnailViewEnabled = !1, Object.defineProperty(this, "hasViewer", {
      value: () => !!this.pdfViewer
    });
  }
  setViewer(e) {
    this.pdfViewer = e;
  }
  setThumbnailViewer(e) {
    this.pdfThumbnailViewer = e;
  }
  isHighestPriority(e) {
    return this.highestPriorityPage === e.renderingId;
  }
  renderHighestPriority(e) {
    var t;
    this.idleTimeout && (clearTimeout(this.idleTimeout), this.idleTimeout = null), !this.pdfViewer.forceRendering(e) && (this.isThumbnailViewEnabled && ((t = this.pdfThumbnailViewer) != null && t.forceRendering()) || this.printing || this.onIdle && (this.idleTimeout = setTimeout(this.onIdle.bind(this), bS)));
  }
  getHighestPriority(e, t, s, i = !1) {
    const n = e.views, r = n.length;
    if (r === 0)
      return null;
    for (let u = 0; u < r; u++) {
      const f = n[u].view;
      if (!this.isViewFinished(f))
        return f;
    }
    const o = e.first.id, l = e.last.id;
    if (l - o + 1 > r) {
      const u = e.ids;
      for (let f = 1, g = l - o; f < g; f++) {
        const m = s ? o + f : l - f;
        if (u.has(m))
          continue;
        const y = t[m - 1];
        if (!this.isViewFinished(y))
          return y;
      }
    }
    let c = s ? l : o - 2, d = t[c];
    return d && !this.isViewFinished(d) || i && (c += s ? 1 : -1, d = t[c], d && !this.isViewFinished(d)) ? d : null;
  }
  isViewFinished(e) {
    return e.renderingState === jt.FINISHED;
  }
  renderView(e) {
    switch (e.renderingState) {
      case jt.FINISHED:
        return !1;
      case jt.PAUSED:
        this.highestPriorityPage = e.renderingId, e.resume();
        break;
      case jt.RUNNING:
        this.highestPriorityPage = e.renderingId;
        break;
      case jt.INITIAL:
        this.highestPriorityPage = e.renderingId, e.draw().finally(() => {
          this.renderHighestPriority();
        }).catch((t) => {
          t instanceof eg || console.error("renderView:", t);
        });
        break;
    }
    return !0;
  }
}
const Ym = 10, Dd = {
  FORCE_SCROLL_MODE_PAGE: 1e4,
  FORCE_LAZY_PAGE_INIT: 5e3,
  PAUSE_EAGER_PAGE_INIT: 250
};
function Km(h) {
  return Object.values(We).includes(h) && h !== We.DISABLE;
}
var sn, ka, cd, Tg;
class AS {
  constructor(e) {
    b(this, cd);
    b(this, sn, /* @__PURE__ */ new Set());
    b(this, ka, 0);
    p(this, ka, e);
  }
  push(e) {
    const t = a(this, sn);
    t.has(e) && t.delete(e), t.add(e), t.size > a(this, ka) && v(this, cd, Tg).call(this);
  }
  resize(e, t = null) {
    p(this, ka, e);
    const s = a(this, sn);
    if (t) {
      const i = s.size;
      let n = 1;
      for (const r of s)
        if (t.has(r.id) && (s.delete(r), s.add(r)), ++n > i)
          break;
    }
    for (; s.size > a(this, ka); )
      v(this, cd, Tg).call(this);
  }
  has(e) {
    return a(this, sn).has(e);
  }
  [Symbol.iterator]() {
    return a(this, sn).keys();
  }
}
sn = new WeakMap(), ka = new WeakMap(), cd = new WeakSet(), Tg = function() {
  const e = a(this, sn).keys().next().value;
  e == null || e.destroy(), a(this, sn).delete(e);
};
var ar, dd, ud, pi, ns, Fa, fd, pd, gd, md, vd, bd, yd, or, Ba, ja, Ha, Cl, lr, Rl, Ad, Il, $a, hr, wd, _l, Z, jy, Hy, $y, ch, Eu, Vy, Pg, Uy, fn, Cg, zy, Wy, Gy, Rg, Xy, Su;
class By {
  constructor(e) {
    b(this, Z);
    b(this, ar, null);
    b(this, dd, null);
    b(this, ud, null);
    b(this, pi, We.NONE);
    b(this, ns, null);
    b(this, Fa, nn.ENABLE_FORMS);
    b(this, fd, null);
    b(this, pd, null);
    b(this, gd, !1);
    b(this, md, !1);
    b(this, vd, !1);
    b(this, bd, !1);
    b(this, yd, !1);
    b(this, or, null);
    b(this, Ba, null);
    b(this, ja, null);
    b(this, Ha, null);
    b(this, Cl, !1);
    b(this, lr, null);
    b(this, Rl, !1);
    b(this, Ad, 0);
    b(this, Il, new ResizeObserver(v(this, Z, Xy).bind(this)));
    b(this, $a, null);
    b(this, hr, null);
    b(this, wd, !0);
    b(this, _l, gi.ENABLE);
    var i, n;
    const t = "4.10.38";
    if (_m !== t)
      throw new Error(`The API version "${_m}" does not match the Viewer version "${t}".`);
    if (this.container = e.container, this.viewer = e.viewer || e.container.firstElementChild, ((i = this.container) == null ? void 0 : i.tagName) !== "DIV" || ((n = this.viewer) == null ? void 0 : n.tagName) !== "DIV")
      throw new Error("Invalid `container` and/or `viewer` option.");
    if (this.container.offsetParent && getComputedStyle(this.container).position !== "absolute")
      throw new Error("The `container` must be absolutely positioned.");
    a(this, Il).observe(this.container), this.eventBus = e.eventBus, this.linkService = e.linkService || new jg(), this.downloadManager = e.downloadManager || null, this.findController = e.findController || null, p(this, dd, e.altTextManager || null), p(this, pd, e.editorUndoBar || null), this.findController && (this.findController.onIsPageVisible = (r) => this._getVisiblePages().ids.has(r)), this._scriptingManager = e.scriptingManager || null, p(this, _l, e.textLayerMode ?? gi.ENABLE), p(this, Fa, e.annotationMode ?? nn.ENABLE_FORMS), p(this, pi, e.annotationEditorMode ?? We.NONE), p(this, ud, e.annotationEditorHighlightColors || null), p(this, md, e.enableHighlightFloatingButton === !0), p(this, bd, e.enableUpdatedAddImage === !0), p(this, yd, e.enableNewAltTextWhenAddingImage === !0), this.imageResourcesPath = e.imageResourcesPath || "", this.enablePrintAutoRotate = e.enablePrintAutoRotate || !1, this.removePageBorders = e.removePageBorders || !1, this.maxCanvasPixels = e.maxCanvasPixels, this.l10n = e.l10n, this.l10n || (this.l10n = new Ol()), p(this, vd, e.enablePermissions || !1), this.pageColors = e.pageColors || null, p(this, Ba, e.mlManager || null), p(this, gd, e.enableHWA || !1), p(this, wd, e.supportsPinchToZoom !== !1), this.defaultRenderingQueue = !e.renderingQueue, this.defaultRenderingQueue ? (this.renderingQueue = new yS(), this.renderingQueue.setViewer(this)) : this.renderingQueue = e.renderingQueue;
    const {
      abortSignal: s
    } = e;
    s == null || s.addEventListener("abort", () => {
      a(this, Il).disconnect(), p(this, Il, null);
    }, {
      once: !0
    }), this.scroll = bE(this.container, this._scrollUpdate.bind(this), s), this.presentationModeState = ro.UNKNOWN, this._resetView(), this.removePageBorders && this.viewer.classList.add("removePageBorders"), v(this, Z, Rg).call(this), this.eventBus._on("thumbnailrendered", ({
      pageNumber: r,
      pdfPage: o
    }) => {
      const l = this._pages[r - 1];
      a(this, ar).has(l) || o == null || o.cleanup();
    }), e.l10n || this.l10n.translate(this.container);
  }
  get pagesCount() {
    return this._pages.length;
  }
  getPageView(e) {
    return this._pages[e];
  }
  getCachedPageViews() {
    return new Set(a(this, ar));
  }
  get pageViewsReady() {
    return this._pages.every((e) => e == null ? void 0 : e.pdfPage);
  }
  get renderForms() {
    return a(this, Fa) === nn.ENABLE_FORMS;
  }
  get enableScripting() {
    return !!this._scriptingManager;
  }
  get currentPageNumber() {
    return this._currentPageNumber;
  }
  set currentPageNumber(e) {
    if (!Number.isInteger(e))
      throw new Error("Invalid page number.");
    this.pdfDocument && (this._setCurrentPageNumber(e, !0) || console.error(`currentPageNumber: "${e}" is not a valid page.`));
  }
  _setCurrentPageNumber(e, t = !1) {
    var i;
    if (this._currentPageNumber === e)
      return t && v(this, Z, Cg).call(this), !0;
    if (!(0 < e && e <= this.pagesCount))
      return !1;
    const s = this._currentPageNumber;
    return this._currentPageNumber = e, this.eventBus.dispatch("pagechanging", {
      source: this,
      pageNumber: e,
      pageLabel: ((i = this._pageLabels) == null ? void 0 : i[e - 1]) ?? null,
      previous: s
    }), t && v(this, Z, Cg).call(this), !0;
  }
  get currentPageLabel() {
    var e;
    return ((e = this._pageLabels) == null ? void 0 : e[this._currentPageNumber - 1]) ?? null;
  }
  set currentPageLabel(e) {
    if (!this.pdfDocument)
      return;
    let t = e | 0;
    if (this._pageLabels) {
      const s = this._pageLabels.indexOf(e);
      s >= 0 && (t = s + 1);
    }
    this._setCurrentPageNumber(t, !0) || console.error(`currentPageLabel: "${e}" is not a valid page.`);
  }
  get currentScale() {
    return this._currentScale !== xf ? this._currentScale : ey;
  }
  set currentScale(e) {
    if (isNaN(e))
      throw new Error("Invalid numeric scale.");
    this.pdfDocument && v(this, Z, fn).call(this, e, {
      noScroll: !1
    });
  }
  get currentScaleValue() {
    return this._currentScaleValue;
  }
  set currentScaleValue(e) {
    this.pdfDocument && v(this, Z, fn).call(this, e, {
      noScroll: !1
    });
  }
  get pagesRotation() {
    return this._pagesRotation;
  }
  set pagesRotation(e) {
    if (!iy(e))
      throw new Error("Invalid pages rotation angle.");
    if (!this.pdfDocument || (e %= 360, e < 0 && (e += 360), this._pagesRotation === e))
      return;
    this._pagesRotation = e;
    const t = this._currentPageNumber;
    this.refresh(!0, {
      rotation: e
    }), this._currentScaleValue && v(this, Z, fn).call(this, this._currentScaleValue, {
      noScroll: !0
    }), this.eventBus.dispatch("rotationchanging", {
      source: this,
      pagesRotation: e,
      pageNumber: t
    }), this.defaultRenderingQueue && this.update();
  }
  get firstPagePromise() {
    return this.pdfDocument ? this._firstPageCapability.promise : null;
  }
  get onePageRendered() {
    return this.pdfDocument ? this._onePageRenderedCapability.promise : null;
  }
  get pagesPromise() {
    return this.pdfDocument ? this._pagesCapability.promise : null;
  }
  get _layerProperties() {
    const e = this;
    return Mu(this, "_layerProperties", {
      get annotationEditorUIManager() {
        return a(e, ns);
      },
      get annotationStorage() {
        var t;
        return (t = e.pdfDocument) == null ? void 0 : t.annotationStorage;
      },
      get downloadManager() {
        return e.downloadManager;
      },
      get enableScripting() {
        return !!e._scriptingManager;
      },
      get fieldObjectsPromise() {
        var t;
        return (t = e.pdfDocument) == null ? void 0 : t.getFieldObjects();
      },
      get findController() {
        return e.findController;
      },
      get hasJSActionsPromise() {
        var t;
        return (t = e.pdfDocument) == null ? void 0 : t.hasJSActions();
      },
      get linkService() {
        return e.linkService;
      }
    });
  }
  async getAllText() {
    const e = [], t = [];
    for (let s = 1, i = this.pdfDocument.numPages; s <= i; ++s) {
      if (a(this, Rl))
        return null;
      t.length = 0;
      const n = await this.pdfDocument.getPage(s), {
        items: r
      } = await n.getTextContent();
      for (const o of r)
        o.str && t.push(o.str), o.hasEOL && t.push(`
`);
      e.push(uh(t.join("")));
    }
    return e.join(`
`);
  }
  setDocument(e) {
    var f, g, m;
    if (this.pdfDocument && (this.eventBus.dispatch("pagesdestroy", {
      source: this
    }), this._cancelRendering(), this._resetView(), (f = this.findController) == null || f.setDocument(null), (g = this._scriptingManager) == null || g.setDocument(null), (m = a(this, ns)) == null || m.destroy(), p(this, ns, null)), this.pdfDocument = e, !e)
      return;
    const t = e.numPages, s = e.getPage(1), i = e.getOptionalContentConfig({
      intent: "display"
    }), n = a(this, vd) ? e.getPermissions() : Promise.resolve(), {
      eventBus: r,
      pageColors: o,
      viewer: l
    } = this;
    p(this, or, new AbortController());
    const {
      signal: c
    } = a(this, or);
    if (t > Dd.FORCE_SCROLL_MODE_PAGE) {
      console.warn("Forcing PAGE-scrolling for performance reasons, given the length of the document.");
      const y = this._scrollMode = dt.PAGE;
      r.dispatch("scrollmodechanged", {
        source: this,
        mode: y
      });
    }
    this._pagesCapability.promise.then(() => {
      r.dispatch("pagesloaded", {
        source: this,
        pagesCount: t
      });
    }, () => {
    });
    const d = (y) => {
      const w = this._pages[y.pageNumber - 1];
      w && a(this, ar).push(w);
    };
    r._on("pagerender", d, {
      signal: c
    });
    const u = (y) => {
      y.cssTransform || (this._onePageRenderedCapability.resolve({
        timestamp: y.timestamp
      }), r._off("pagerendered", u));
    };
    r._on("pagerendered", u, {
      signal: c
    }), Promise.all([s, n]).then(([y, w]) => {
      var R, _;
      if (e !== this.pdfDocument)
        return;
      this._firstPageCapability.resolve(y), this._optionalContentConfigPromise = i;
      const {
        annotationEditorMode: A,
        annotationMode: E,
        textLayerMode: S
      } = v(this, Z, jy).call(this, w);
      if (S !== gi.DISABLE) {
        const x = p(this, lr, document.createElement("div"));
        x.id = "hiddenCopyElement", l.before(x);
      }
      if (typeof AbortSignal.any == "function" && A !== We.DISABLE) {
        const x = A;
        e.isPureXfa ? console.warn("Warning: XFA-editing is not implemented.") : Km(x) ? (p(this, ns, new JE(this.container, l, a(this, dd), r, e, o, a(this, ud), a(this, md), a(this, bd), a(this, yd), a(this, Ba), a(this, pd), a(this, wd))), r.dispatch("annotationeditoruimanager", {
          source: this,
          uiManager: a(this, ns)
        }), x !== We.NONE && (x === We.STAMP && ((R = a(this, Ba)) == null || R.loadModel("altText")), a(this, ns).updateMode(x))) : console.error(`Invalid AnnotationEditor mode: ${x}`);
      }
      const T = this._scrollMode === dt.PAGE ? null : l, P = this.currentScale, C = y.getViewport({
        scale: P * Pi.PDF_TO_CSS_UNITS
      });
      l.style.setProperty("--scale-factor", C.scale), o != null && o.background && l.style.setProperty("--page-bg-color", o.background), ((o == null ? void 0 : o.foreground) === "CanvasText" || (o == null ? void 0 : o.background) === "Canvas") && (l.style.setProperty("--hcm-highlight-filter", e.filterFactory.addHighlightHCMFilter("highlight", "CanvasText", "Canvas", "HighlightText", "Highlight")), l.style.setProperty("--hcm-highlight-selected-filter", e.filterFactory.addHighlightHCMFilter("highlight_selected", "CanvasText", "Canvas", "HighlightText", "ButtonText")));
      for (let x = 1; x <= t; ++x) {
        const I = new Oy({
          container: T,
          eventBus: r,
          id: x,
          scale: P,
          defaultViewport: C.clone(),
          optionalContentConfigPromise: i,
          renderingQueue: this.renderingQueue,
          textLayerMode: S,
          annotationMode: E,
          imageResourcesPath: this.imageResourcesPath,
          maxCanvasPixels: this.maxCanvasPixels,
          pageColors: o,
          l10n: this.l10n,
          layerProperties: this._layerProperties,
          enableHWA: a(this, gd)
        });
        this._pages.push(I);
      }
      (_ = this._pages[0]) == null || _.setPdfPage(y), this._scrollMode === dt.PAGE ? v(this, Z, ch).call(this) : this._spreadMode !== Se.NONE && this._updateSpreadMode(), v(this, Z, Hy).call(this, c).then(async () => {
        var I, L;
        if (e !== this.pdfDocument)
          return;
        if ((I = this.findController) == null || I.setDocument(e), (L = this._scriptingManager) == null || L.setDocument(e), a(this, lr) && document.addEventListener("copy", v(this, Z, $y).bind(this, S), {
          signal: c
        }), a(this, ns) && r.dispatch("annotationeditormodechanged", {
          source: this,
          mode: a(this, pi)
        }), e.loadingParams.disableAutoFetch || t > Dd.FORCE_LAZY_PAGE_INIT) {
          this._pagesCapability.resolve();
          return;
        }
        let x = t - 1;
        if (x <= 0) {
          this._pagesCapability.resolve();
          return;
        }
        for (let j = 2; j <= t; ++j) {
          const k = e.getPage(j).then((F) => {
            const Y = this._pages[j - 1];
            Y.pdfPage || Y.setPdfPage(F), --x === 0 && this._pagesCapability.resolve();
          }, (F) => {
            console.error(`Unable to get page ${j} to initialize viewer`, F), --x === 0 && this._pagesCapability.resolve();
          });
          j % Dd.PAUSE_EAGER_PAGE_INIT === 0 && await k;
        }
      }), r.dispatch("pagesinit", {
        source: this
      }), e.getMetadata().then(({
        info: x
      }) => {
        e === this.pdfDocument && x.Language && (l.lang = x.Language);
      }), this.defaultRenderingQueue && this.update();
    }).catch((y) => {
      console.error("Unable to initialize viewer", y), this._pagesCapability.reject(y);
    });
  }
  setPageLabels(e) {
    var t;
    if (this.pdfDocument) {
      e ? Array.isArray(e) && this.pdfDocument.numPages === e.length ? this._pageLabels = e : (this._pageLabels = null, console.error("setPageLabels: Invalid page labels.")) : this._pageLabels = null;
      for (let s = 0, i = this._pages.length; s < i; s++)
        this._pages[s].setPageLabel(((t = this._pageLabels) == null ? void 0 : t[s]) ?? null);
    }
  }
  _resetView() {
    var e, t;
    this._pages = [], this._currentPageNumber = 1, this._currentScale = xf, this._currentScaleValue = null, this._pageLabels = null, p(this, ar, new AS(Ym)), this._location = null, this._pagesRotation = 0, this._optionalContentConfigPromise = null, this._firstPageCapability = Promise.withResolvers(), this._onePageRenderedCapability = Promise.withResolvers(), this._pagesCapability = Promise.withResolvers(), this._scrollMode = dt.VERTICAL, this._previousScrollMode = dt.UNKNOWN, this._spreadMode = Se.NONE, p(this, $a, {
      previousPageNumber: 1,
      scrollDown: !0,
      pages: []
    }), (e = a(this, or)) == null || e.abort(), p(this, or, null), this.viewer.textContent = "", this._updateScrollMode(), this.viewer.removeAttribute("lang"), (t = a(this, lr)) == null || t.remove(), p(this, lr, null), v(this, Z, Su).call(this);
  }
  _scrollUpdate() {
    this.pagesCount !== 0 && this.update();
  }
  pageLabelToPageNumber(e) {
    if (!this._pageLabels)
      return null;
    const t = this._pageLabels.indexOf(e);
    return t < 0 ? null : t + 1;
  }
  scrollPageIntoView({
    pageNumber: e,
    destArray: t = null,
    allowNegativeOffset: s = !1,
    ignoreDestinationZoom: i = !1
  }) {
    if (!this.pdfDocument)
      return;
    const n = Number.isInteger(e) && this._pages[e - 1];
    if (!n) {
      console.error(`scrollPageIntoView: "${e}" is not a valid pageNumber parameter.`);
      return;
    }
    if (this.isInPresentationMode || !t) {
      this._setCurrentPageNumber(e, !0);
      return;
    }
    let r = 0, o = 0, l = 0, c = 0, d, u;
    const f = n.rotation % 180 !== 0, g = (f ? n.height : n.width) / n.scale / Pi.PDF_TO_CSS_UNITS, m = (f ? n.width : n.height) / n.scale / Pi.PDF_TO_CSS_UNITS;
    let y = 0;
    switch (t[1].name) {
      case "XYZ":
        r = t[2], o = t[3], y = t[4], r = r !== null ? r : 0, o = o !== null ? o : m;
        break;
      case "Fit":
      case "FitB":
        y = "page-fit";
        break;
      case "FitH":
      case "FitBH":
        o = t[2], y = "page-width", o === null && this._location ? (r = this._location.left, o = this._location.top) : (typeof o != "number" || o < 0) && (o = m);
        break;
      case "FitV":
      case "FitBV":
        r = t[2], l = g, c = m, y = "page-height";
        break;
      case "FitR":
        r = t[2], o = t[3], l = t[4] - r, c = t[5] - o;
        let S = bm, T = ym;
        this.removePageBorders && (S = T = 0), d = (this.container.clientWidth - S) / l / Pi.PDF_TO_CSS_UNITS, u = (this.container.clientHeight - T) / c / Pi.PDF_TO_CSS_UNITS, y = Math.min(Math.abs(d), Math.abs(u));
        break;
      default:
        console.error(`scrollPageIntoView: "${t[1].name}" is not a valid destination type.`);
        return;
    }
    if (i || (y && y !== this._currentScale ? this.currentScaleValue = y : this._currentScale === xf && (this.currentScaleValue = pE)), y === "page-fit" && !t[4]) {
      v(this, Z, Eu).call(this, n);
      return;
    }
    const w = [n.viewport.convertToViewportPoint(r, o), n.viewport.convertToViewportPoint(r + l, o + c)];
    let A = Math.min(w[0][0], w[1][0]), E = Math.min(w[0][1], w[1][1]);
    s || (A = Math.max(A, 0), E = Math.max(E, 0)), v(this, Z, Eu).call(this, n, {
      left: A,
      top: E
    });
  }
  _updateLocation(e) {
    const t = this._currentScale, s = this._currentScaleValue, i = parseFloat(s) === t ? Math.round(t * 1e4) / 100 : s, n = e.id, r = this._pages[n - 1], o = this.container, l = r.getPagePoint(o.scrollLeft - e.x, o.scrollTop - e.y), c = Math.round(l[0]), d = Math.round(l[1]);
    let u = `#page=${n}`;
    this.isInPresentationMode || (u += `&zoom=${i},${c},${d}`), this._location = {
      pageNumber: n,
      scale: i,
      top: d,
      left: c,
      rotation: this._pagesRotation,
      pdfOpenParams: u
    };
  }
  update() {
    const e = this._getVisiblePages(), t = e.views, s = t.length;
    if (s === 0)
      return;
    const i = Math.max(Ym, 2 * s + 1);
    a(this, ar).resize(i, e.ids), this.renderingQueue.renderHighestPriority(e);
    const n = this._spreadMode === Se.NONE && (this._scrollMode === dt.PAGE || this._scrollMode === dt.VERTICAL), r = this._currentPageNumber;
    let o = !1;
    for (const l of t) {
      if (l.percent < 100)
        break;
      if (l.id === r && n) {
        o = !0;
        break;
      }
    }
    this._setCurrentPageNumber(o ? r : t[0].id), this._updateLocation(e.first), this.eventBus.dispatch("updateviewarea", {
      source: this,
      location: this._location
    });
  }
  containsElement(e) {
    return this.container.contains(e);
  }
  focus() {
    this.container.focus();
  }
  get _isContainerRtl() {
    return getComputedStyle(this.container).direction === "rtl";
  }
  get isInPresentationMode() {
    return this.presentationModeState === ro.FULLSCREEN;
  }
  get isChangingPresentationMode() {
    return this.presentationModeState === ro.CHANGING;
  }
  get isHorizontalScrollbarEnabled() {
    return this.isInPresentationMode ? !1 : this.container.scrollWidth > this.container.clientWidth;
  }
  get isVerticalScrollbarEnabled() {
    return this.isInPresentationMode ? !1 : this.container.scrollHeight > this.container.clientHeight;
  }
  _getVisiblePages() {
    const e = this._scrollMode === dt.PAGE ? a(this, $a).pages : this._pages, t = this._scrollMode === dt.HORIZONTAL, s = t && this._isContainerRtl;
    return AE({
      scrollEl: this.container,
      views: e,
      sortByVisibility: !0,
      horizontal: t,
      rtl: s
    });
  }
  cleanup() {
    for (const e of this._pages)
      e.renderingState !== jt.FINISHED && e.reset();
  }
  _cancelRendering() {
    for (const e of this._pages)
      e.cancelRendering();
  }
  forceRendering(e) {
    const t = e || this._getVisiblePages(), s = v(this, Z, Gy).call(this, t), i = this._spreadMode !== Se.NONE && this._scrollMode !== dt.HORIZONTAL, n = this.renderingQueue.getHighestPriority(t, this._pages, s, i);
    return n ? (v(this, Z, Wy).call(this, n).then(() => {
      this.renderingQueue.renderView(n);
    }), !0) : !1;
  }
  get hasEqualPageSizes() {
    const e = this._pages[0];
    for (let t = 1, s = this._pages.length; t < s; ++t) {
      const i = this._pages[t];
      if (i.width !== e.width || i.height !== e.height)
        return !1;
    }
    return !0;
  }
  getPagesOverview() {
    let e;
    return this._pages.map((t) => {
      const s = t.pdfPage.getViewport({
        scale: 1
      }), i = Em(s);
      if (e === void 0)
        e = i;
      else if (this.enablePrintAutoRotate && i !== e)
        return {
          width: s.height,
          height: s.width,
          rotation: (s.rotation - 90) % 360
        };
      return {
        width: s.width,
        height: s.height,
        rotation: s.rotation
      };
    });
  }
  get optionalContentConfigPromise() {
    return this.pdfDocument ? this._optionalContentConfigPromise ? this._optionalContentConfigPromise : (console.error("optionalContentConfigPromise: Not initialized yet."), this.pdfDocument.getOptionalContentConfig({
      intent: "display"
    })) : Promise.resolve(null);
  }
  set optionalContentConfigPromise(e) {
    if (!(e instanceof Promise))
      throw new Error(`Invalid optionalContentConfigPromise: ${e}`);
    this.pdfDocument && this._optionalContentConfigPromise && (this._optionalContentConfigPromise = e, this.refresh(!1, {
      optionalContentConfigPromise: e
    }), this.eventBus.dispatch("optionalcontentconfigchanged", {
      source: this,
      promise: e
    }));
  }
  get scrollMode() {
    return this._scrollMode;
  }
  set scrollMode(e) {
    if (this._scrollMode !== e) {
      if (!wE(e))
        throw new Error(`Invalid scroll mode: ${e}`);
      this.pagesCount > Dd.FORCE_SCROLL_MODE_PAGE || (this._previousScrollMode = this._scrollMode, this._scrollMode = e, this.eventBus.dispatch("scrollmodechanged", {
        source: this,
        mode: e
      }), this._updateScrollMode(this._currentPageNumber));
    }
  }
  _updateScrollMode(e = null) {
    const t = this._scrollMode, s = this.viewer;
    s.classList.toggle("scrollHorizontal", t === dt.HORIZONTAL), s.classList.toggle("scrollWrapped", t === dt.WRAPPED), !(!this.pdfDocument || !e) && (t === dt.PAGE ? v(this, Z, ch).call(this) : this._previousScrollMode === dt.PAGE && this._updateSpreadMode(), this._currentScaleValue && isNaN(this._currentScaleValue) && v(this, Z, fn).call(this, this._currentScaleValue, {
      noScroll: !0
    }), this._setCurrentPageNumber(e, !0), this.update());
  }
  get spreadMode() {
    return this._spreadMode;
  }
  set spreadMode(e) {
    if (this._spreadMode !== e) {
      if (!EE(e))
        throw new Error(`Invalid spread mode: ${e}`);
      this._spreadMode = e, this.eventBus.dispatch("spreadmodechanged", {
        source: this,
        mode: e
      }), this._updateSpreadMode(this._currentPageNumber);
    }
  }
  _updateSpreadMode(e = null) {
    if (!this.pdfDocument)
      return;
    const t = this.viewer, s = this._pages;
    if (this._scrollMode === dt.PAGE)
      v(this, Z, ch).call(this);
    else if (t.textContent = "", this._spreadMode === Se.NONE)
      for (const i of this._pages)
        t.append(i.div);
    else {
      const i = this._spreadMode - 1;
      let n = null;
      for (let r = 0, o = s.length; r < o; ++r)
        n === null ? (n = document.createElement("div"), n.className = "spread", t.append(n)) : r % 2 === i && (n = n.cloneNode(!1), t.append(n)), n.append(s[r].div);
    }
    e && (this._currentScaleValue && isNaN(this._currentScaleValue) && v(this, Z, fn).call(this, this._currentScaleValue, {
      noScroll: !0
    }), this._setCurrentPageNumber(e, !0), this.update());
  }
  _getPageAdvance(e, t = !1) {
    switch (this._scrollMode) {
      case dt.WRAPPED: {
        const {
          views: s
        } = this._getVisiblePages(), i = /* @__PURE__ */ new Map();
        for (const {
          id: n,
          y: r,
          percent: o,
          widthPercent: l
        } of s) {
          if (o === 0 || l < 100)
            continue;
          let c = i.get(r);
          c || i.set(r, c || (c = [])), c.push(n);
        }
        for (const n of i.values()) {
          const r = n.indexOf(e);
          if (r === -1)
            continue;
          const o = n.length;
          if (o === 1)
            break;
          if (t)
            for (let l = r - 1, c = 0; l >= c; l--) {
              const d = n[l], u = n[l + 1] - 1;
              if (d < u)
                return e - u;
            }
          else
            for (let l = r + 1, c = o; l < c; l++) {
              const d = n[l], u = n[l - 1] + 1;
              if (d > u)
                return u - e;
            }
          if (t) {
            const l = n[0];
            if (l < e)
              return e - l + 1;
          } else {
            const l = n[o - 1];
            if (l > e)
              return l - e + 1;
          }
          break;
        }
        break;
      }
      case dt.HORIZONTAL:
        break;
      case dt.PAGE:
      case dt.VERTICAL: {
        if (this._spreadMode === Se.NONE)
          break;
        const s = this._spreadMode - 1;
        if (t && e % 2 !== s)
          break;
        if (!t && e % 2 === s)
          break;
        const {
          views: i
        } = this._getVisiblePages(), n = t ? e - 1 : e + 1;
        for (const {
          id: r,
          percent: o,
          widthPercent: l
        } of i)
          if (r === n) {
            if (o > 0 && l === 100)
              return 2;
            break;
          }
        break;
      }
    }
    return 1;
  }
  nextPage() {
    const e = this._currentPageNumber, t = this.pagesCount;
    if (e >= t)
      return !1;
    const s = this._getPageAdvance(e, !1) || 1;
    return this.currentPageNumber = Math.min(e + s, t), !0;
  }
  previousPage() {
    const e = this._currentPageNumber;
    if (e <= 1)
      return !1;
    const t = this._getPageAdvance(e, !0) || 1;
    return this.currentPageNumber = Math.max(e - t, 1), !0;
  }
  updateScale({
    drawingDelay: e,
    scaleFactor: t = null,
    steps: s = null,
    origin: i
  }) {
    if (s === null && t === null)
      throw new Error("Invalid updateScale options: either `steps` or `scaleFactor` must be provided.");
    if (!this.pdfDocument)
      return;
    let n = this._currentScale;
    if (t > 0 && t !== 1)
      n = Math.round(n * t * 100) / 100;
    else if (s) {
      const r = s > 0 ? vm : 1 / vm, o = s > 0 ? Math.ceil : Math.floor;
      s = Math.abs(s);
      do
        n = o((n * r).toFixed(2) * 10) / 10;
      while (--s > 0);
    }
    n = Math.max(gE, Math.min(mE, n)), v(this, Z, fn).call(this, n, {
      noScroll: !1,
      drawingDelay: e,
      origin: i
    });
  }
  increaseScale(e = {}) {
    this.updateScale({
      ...e,
      steps: e.steps ?? 1
    });
  }
  decreaseScale(e = {}) {
    this.updateScale({
      ...e,
      steps: -(e.steps ?? 1)
    });
  }
  get containerTopLeft() {
    return a(this, fd) || p(this, fd, [this.container.offsetTop, this.container.offsetLeft]);
  }
  get annotationEditorMode() {
    return a(this, ns) ? a(this, pi) : We.DISABLE;
  }
  set annotationEditorMode({
    mode: e,
    editId: t = null,
    isFromKeyboard: s = !1
  }) {
    var r;
    if (!a(this, ns))
      throw new Error("The AnnotationEditor is not enabled.");
    if (a(this, pi) === e)
      return;
    if (!Km(e))
      throw new Error(`Invalid AnnotationEditor mode: ${e}`);
    if (!this.pdfDocument)
      return;
    e === We.STAMP && ((r = a(this, Ba)) == null || r.loadModel("altText"));
    const {
      eventBus: i
    } = this, n = () => {
      v(this, Z, Su).call(this), p(this, pi, e), a(this, ns).updateMode(e, t, s), i.dispatch("annotationeditormodechanged", {
        source: this,
        mode: e
      });
    };
    if (e === We.NONE || a(this, pi) === We.NONE) {
      const o = e !== We.NONE;
      o || this.pdfDocument.annotationStorage.resetModifiedIds();
      for (const c of this._pages)
        c.toggleEditingMode(o);
      const l = v(this, Z, zy).call(this);
      if (o && l) {
        v(this, Z, Su).call(this), p(this, ja, new AbortController());
        const c = AbortSignal.any([a(this, or).signal, a(this, ja).signal]);
        i._on("pagerendered", ({
          pageNumber: d
        }) => {
          l.delete(d), l.size === 0 && p(this, Ha, setTimeout(n, 0));
        }, {
          signal: c
        });
        return;
      }
    }
    n();
  }
  refresh(e = !1, t = /* @__PURE__ */ Object.create(null)) {
    if (this.pdfDocument) {
      for (const s of this._pages)
        s.update(t);
      a(this, hr) !== null && (clearTimeout(a(this, hr)), p(this, hr, null)), e || this.update();
    }
  }
}
ar = new WeakMap(), dd = new WeakMap(), ud = new WeakMap(), pi = new WeakMap(), ns = new WeakMap(), Fa = new WeakMap(), fd = new WeakMap(), pd = new WeakMap(), gd = new WeakMap(), md = new WeakMap(), vd = new WeakMap(), bd = new WeakMap(), yd = new WeakMap(), or = new WeakMap(), Ba = new WeakMap(), ja = new WeakMap(), Ha = new WeakMap(), Cl = new WeakMap(), lr = new WeakMap(), Rl = new WeakMap(), Ad = new WeakMap(), Il = new WeakMap(), $a = new WeakMap(), hr = new WeakMap(), wd = new WeakMap(), _l = new WeakMap(), Z = new WeakSet(), jy = function(e) {
  const t = {
    annotationEditorMode: a(this, pi),
    annotationMode: a(this, Fa),
    textLayerMode: a(this, _l)
  };
  return e && (!e.includes(Od.COPY) && a(this, _l) === gi.ENABLE && (t.textLayerMode = gi.ENABLE_PERMISSIONS), e.includes(Od.MODIFY_CONTENTS) || (t.annotationEditorMode = We.DISABLE), !e.includes(Od.MODIFY_ANNOTATIONS) && !e.includes(Od.FILL_INTERACTIVE_FORMS) && a(this, Fa) === nn.ENABLE_FORMS && (t.annotationMode = nn.ENABLE)), t;
}, Hy = async function(e) {
  if (document.visibilityState === "hidden" || !this.container.offsetParent || this._getVisiblePages().views.length === 0)
    return;
  const t = Promise.withResolvers(), s = new AbortController();
  document.addEventListener("visibilitychange", () => {
    document.visibilityState === "hidden" && t.resolve();
  }, {
    signal: typeof AbortSignal.any == "function" ? AbortSignal.any([e, s.signal]) : e
  }), await Promise.race([this._onePageRenderedCapability.promise, t.promise]), s.abort();
}, $y = function(e, t) {
  const s = document.getSelection(), {
    focusNode: i,
    anchorNode: n
  } = s;
  if (n && i && s.containsNode(a(this, lr))) {
    if (a(this, Cl) || e === gi.ENABLE_PERMISSIONS) {
      sg(t);
      return;
    }
    p(this, Cl, !0);
    const {
      classList: r
    } = this.viewer;
    r.add("copyAll");
    const o = new AbortController();
    window.addEventListener("keydown", (l) => p(this, Rl, l.key === "Escape"), {
      signal: o.signal
    }), this.getAllText().then(async (l) => {
      l !== null && await navigator.clipboard.writeText(l);
    }).catch((l) => {
      console.warn(`Something goes wrong when extracting the text: ${l.message}`);
    }).finally(() => {
      p(this, Cl, !1), p(this, Rl, !1), o.abort(), r.remove("copyAll");
    }), sg(t);
  }
}, ch = function() {
  if (this._scrollMode !== dt.PAGE)
    throw new Error("#ensurePageViewVisible: Invalid scrollMode value.");
  const e = this._currentPageNumber, t = a(this, $a), s = this.viewer;
  if (s.textContent = "", t.pages.length = 0, this._spreadMode === Se.NONE && !this.isInPresentationMode) {
    const i = this._pages[e - 1];
    s.append(i.div), t.pages.push(i);
  } else {
    const i = /* @__PURE__ */ new Set(), n = this._spreadMode - 1;
    n === -1 ? i.add(e - 1) : e % 2 !== n ? (i.add(e - 1), i.add(e)) : (i.add(e - 2), i.add(e - 1));
    const r = document.createElement("div");
    if (r.className = "spread", this.isInPresentationMode) {
      const o = document.createElement("div");
      o.className = "dummyPage", r.append(o);
    }
    for (const o of i) {
      const l = this._pages[o];
      l && (r.append(l.div), t.pages.push(l));
    }
    s.append(r);
  }
  t.scrollDown = e >= t.previousPageNumber, t.previousPageNumber = e;
}, Eu = function(e, t = null) {
  const {
    div: s,
    id: i
  } = e;
  if (this._currentPageNumber !== i && this._setCurrentPageNumber(i), this._scrollMode === dt.PAGE && (v(this, Z, ch).call(this), this.update()), !t && !this.isInPresentationMode) {
    const n = s.offsetLeft + s.clientLeft, r = n + s.clientWidth, {
      scrollLeft: o,
      clientWidth: l
    } = this.container;
    (this._scrollMode === dt.HORIZONTAL || n < o || r > o + l) && (t = {
      left: 0,
      top: 0
    });
  }
  sy(s, t), !this._currentScaleValue && this._location && (this._location = null);
}, Vy = function(e) {
  return e === this._currentScale || Math.abs(e - this._currentScale) < 1e-15;
}, Pg = function(e, t, {
  noScroll: s = !1,
  preset: i = !1,
  drawingDelay: n = -1,
  origin: r = null
}) {
  if (this._currentScaleValue = t.toString(), v(this, Z, Vy).call(this, e)) {
    i && this.eventBus.dispatch("scalechanging", {
      source: this,
      scale: e,
      presetValue: t
    });
    return;
  }
  this.viewer.style.setProperty("--scale-factor", e * Pi.PDF_TO_CSS_UNITS);
  const o = n >= 0 && n < 1e3;
  this.refresh(!0, {
    scale: e,
    drawingDelay: o ? n : -1
  }), o && p(this, hr, setTimeout(() => {
    p(this, hr, null), this.refresh();
  }, n));
  const l = this._currentScale;
  if (this._currentScale = e, !s) {
    let c = this._currentPageNumber, d;
    if (this._location && !(this.isInPresentationMode || this.isChangingPresentationMode) && (c = this._location.pageNumber, d = [null, {
      name: "XYZ"
    }, this._location.left, this._location.top, null]), this.scrollPageIntoView({
      pageNumber: c,
      destArray: d,
      allowNegativeOffset: !0
    }), Array.isArray(r)) {
      const u = e / l - 1, [f, g] = this.containerTopLeft;
      this.container.scrollLeft += (r[0] - g) * u, this.container.scrollTop += (r[1] - f) * u;
    }
  }
  this.eventBus.dispatch("scalechanging", {
    source: this,
    scale: e,
    presetValue: i ? t : void 0
  }), this.defaultRenderingQueue && this.update();
}, Uy = function() {
  return this._spreadMode !== Se.NONE && this._scrollMode !== dt.HORIZONTAL ? 2 : 1;
}, fn = function(e, t) {
  let s = parseFloat(e);
  if (s > 0)
    t.preset = !1, v(this, Z, Pg).call(this, s, e, t);
  else {
    const i = this._pages[this._currentPageNumber - 1];
    if (!i)
      return;
    let n = bm, r = ym;
    this.isInPresentationMode ? (n = r = 4, this._spreadMode !== Se.NONE && (n *= 2)) : this.removePageBorders ? n = r = 0 : this._scrollMode === dt.HORIZONTAL && ([n, r] = [r, n]);
    const o = (this.container.clientWidth - n) / i.width * i.scale / a(this, Z, Uy), l = (this.container.clientHeight - r) / i.height * i.scale;
    switch (e) {
      case "page-actual":
        s = 1;
        break;
      case "page-width":
        s = o;
        break;
      case "page-height":
        s = l;
        break;
      case "page-fit":
        s = Math.min(o, l);
        break;
      case "auto":
        const c = Em(i) ? o : Math.min(l, o);
        s = Math.min(vE, c);
        break;
      default:
        console.error(`#setScale: "${e}" is an unknown zoom value.`);
        return;
    }
    t.preset = !0, v(this, Z, Pg).call(this, s, e, t);
  }
}, Cg = function() {
  const e = this._pages[this._currentPageNumber - 1];
  this.isInPresentationMode && v(this, Z, fn).call(this, this._currentScaleValue, {
    noScroll: !0
  }), v(this, Z, Eu).call(this, e);
}, zy = function() {
  const e = this._getVisiblePages(), t = [], {
    ids: s,
    views: i
  } = e;
  for (const n of i) {
    const {
      view: r
    } = n;
    if (!r.hasEditableAnnotations()) {
      s.delete(r.id);
      continue;
    }
    t.push(n);
  }
  return t.length === 0 ? null : (this.renderingQueue.renderHighestPriority({
    first: t[0],
    last: t.at(-1),
    views: t,
    ids: s
  }), s);
}, Wy = async function(e) {
  if (e.pdfPage)
    return e.pdfPage;
  try {
    const t = await this.pdfDocument.getPage(e.id);
    return e.pdfPage || e.setPdfPage(t), t;
  } catch (t) {
    return console.error("Unable to get page for page view", t), null;
  }
}, Gy = function(e) {
  var t, s;
  if (((t = e.first) == null ? void 0 : t.id) === 1)
    return !0;
  if (((s = e.last) == null ? void 0 : s.id) === this.pagesCount)
    return !1;
  switch (this._scrollMode) {
    case dt.PAGE:
      return a(this, $a).scrollDown;
    case dt.HORIZONTAL:
      return this.scroll.right;
  }
  return this.scroll.down;
}, Rg = function(e = this.container.clientHeight) {
  e !== a(this, Ad) && (p(this, Ad, e), SE.setProperty("--viewer-container-height", `${e}px`));
}, Xy = function(e) {
  for (const t of e)
    if (t.target === this.container) {
      v(this, Z, Rg).call(this, Math.floor(t.borderBoxSize[0].blockSize)), p(this, fd, null);
      break;
    }
}, Su = function() {
  var e;
  (e = a(this, ja)) == null || e.abort(), p(this, ja, null), a(this, Ha) !== null && (clearTimeout(a(this, Ha)), p(this, Ha, null));
};
class wS extends By {
  _resetView() {
    super._resetView(), this._scrollMode = dt.PAGE, this._spreadMode = Se.NONE;
  }
  set scrollMode(e) {
  }
  _updateScrollMode() {
  }
  set spreadMode(e) {
  }
  _updateSpreadMode() {
  }
}
Nt.AnnotationLayerBuilder;
Nt.DownloadManager;
Nt.EventBus;
Nt.FindState;
Nt.GenericL10n;
Nt.LinkTarget;
Nt.PDFFindController;
Nt.PDFHistory;
var ES = Nt.PDFLinkService;
Nt.PDFPageView;
Nt.PDFScriptingManager;
Nt.PDFSinglePageViewer;
Nt.PDFViewer;
Nt.ProgressBar;
Nt.RenderingStates;
Nt.ScrollMode;
Nt.SimpleLinkService;
Nt.SpreadMode;
Nt.StructTreeLayerBuilder;
Nt.TextLayerBuilder;
Nt.XfaLayerBuilder;
Nt.parseQueryString;
const SS = ["id"], xS = ["id"], TS = /* @__PURE__ */ qm("canvas", null, null, -1), PS = {
  key: 0,
  class: "textLayer"
}, CS = {
  key: 1,
  class: "annotationLayer"
}, fx = /* @__PURE__ */ Zy({
  __name: "VuePdfEmbed",
  props: {
    annotationLayer: { type: Boolean },
    height: {},
    id: {},
    imageResourcesPath: {},
    linkService: {},
    page: {},
    rotation: { default: 0 },
    scale: { default: 1 },
    source: {},
    textLayer: { type: Boolean },
    width: {}
  },
  emits: ["internal-link-clicked", "loaded", "loading-failed", "password-requested", "progress", "rendered", "rendering-failed"],
  setup(h, { expose: e, emit: t }) {
    const s = h, i = xu([]), n = Jy([]), r = xu(null);
    let o = null;
    const { doc: l } = fE({
      onError: (A) => {
        i.value = [], t("loading-failed", A);
      },
      onPasswordRequest({ callback: A, isWrongPassword: E }) {
        t("password-requested", { callback: A, isWrongPassword: E });
      },
      onProgress: (A) => {
        t("progress", A);
      },
      source: qy(s, "source")
    }), c = tA(() => {
      if (!l.value || !s.annotationLayer)
        return null;
      if (s.linkService)
        return s.linkService;
      const A = new ES();
      return A.setDocument(l.value), A.setViewer({
        scrollPageIntoView: ({ pageNumber: E }) => {
          t("internal-link-clicked", E);
        }
      }), A;
    }), d = async (A) => {
      if (!l.value)
        return;
      const E = await l.value.getData(), S = await l.value.getMetadata(), T = (
        // @ts-expect-error: contentDispositionFilename is not typed
        A ?? S.contentDispositionFilename ?? ""
      );
      uE(E, T);
    }, u = (A) => {
      let E, S;
      return s.height && !s.width ? (S = s.height, E = S / A) : (E = s.width ?? r.value.clientWidth, S = E * A), [E, S];
    }, f = async (A = 300, E = "", S = !1) => {
      var x, I, L;
      if (!l.value)
        return;
      const T = A / 72, P = 96 / 72;
      let C, R, _;
      try {
        C = window.document.createElement("div"), C.style.display = "none", window.document.body.appendChild(C), R = await dE(C);
        const j = s.page && !S ? [s.page] : [...Array(l.value.numPages + 1).keys()].slice(1);
        await Promise.all(
          j.map(async (k, F) => {
            const Y = await l.value.getPage(k), N = Y.getViewport({
              scale: 1,
              rotation: 0
            });
            if (F === 0) {
              const ft = N.width * T / P, Et = N.height * T / P;
              cE(R, ft, Et);
            }
            const D = window.document.createElement("canvas");
            D.width = N.width * T, D.height = N.height * T, C.appendChild(D);
            const et = D.cloneNode();
            R.contentWindow.document.body.appendChild(et), await Y.render({
              canvasContext: D.getContext("2d"),
              intent: "print",
              transform: [T, 0, 0, T, 0, 0],
              viewport: N
            }).promise, et.getContext("2d").drawImage(D, 0, 0);
          })
        ), E && (_ = window.document.title, window.document.title = E), (x = R.contentWindow) == null || x.focus(), (I = R.contentWindow) == null || I.print();
      } finally {
        _ && (window.document.title = _), Sf(C), (L = C.parentNode) == null || L.removeChild(C);
      }
    }, g = async () => {
      if (!(!l.value || o != null && o.isAborted))
        try {
          i.value = s.page ? [s.page] : [...Array(l.value.numPages + 1).keys()].slice(1), n.value = Array(i.value.length).fill(1), await Promise.all(
            i.value.map(async (A, E) => {
              const S = await l.value.getPage(A);
              if (o != null && o.isAborted)
                return;
              const T = ((s.rotation % 90 === 0 ? s.rotation : 0) + S.rotate) % 360, [P, C, R] = Array.from(
                r.value.getElementsByClassName("vue-pdf-embed__page")[E].children
              ), _ = !!(T / 90 % 2), x = S.view[2] - S.view[0], I = S.view[3] - S.view[1], [L, j] = u(
                _ ? x / I : I / x
              ), k = `${Math.floor(L)}px`, F = `${Math.floor(j)}px`, N = L / (_ ? I : x), D = S.getViewport({
                scale: N,
                rotation: T
              });
              n.value[E] = N, P.style.display = "block", P.style.width = k, P.style.height = F;
              const et = [
                m(
                  S,
                  D.clone({
                    scale: D.scale * window.devicePixelRatio * s.scale
                  }),
                  P
                )
              ];
              return s.textLayer && et.push(
                w(
                  S,
                  D.clone({
                    dontFlip: !0
                  }),
                  C
                )
              ), s.annotationLayer && et.push(
                y(
                  S,
                  D.clone({
                    dontFlip: !0
                  }),
                  R || C
                )
              ), Promise.all(et);
            })
          ), o != null && o.isAborted || t("rendered");
        } catch (A) {
          i.value = [], n.value = [], o != null && o.isAborted || t("rendering-failed", A);
        }
    }, m = async (A, E, S) => {
      S.width = E.width, S.height = E.height, await A.render({
        canvasContext: S.getContext("2d"),
        viewport: E
      }).promise;
    }, y = async (A, E, S) => {
      gm(S), new aE({
        accessibilityManager: null,
        annotationCanvasMap: null,
        annotationEditorUIManager: null,
        div: S,
        page: A,
        structTreeLayer: null,
        viewport: E
      }).render({
        annotations: await A.getAnnotations(),
        div: S,
        imageResourcesPath: s.imageResourcesPath,
        linkService: c.value,
        page: A,
        renderForms: !1,
        viewport: E
      });
    }, w = async (A, E, S) => {
      gm(S), new lE({
        container: S,
        textContentSource: await A.getTextContent(),
        viewport: E
      }).render();
    };
    return Nf(
      l,
      (A) => {
        A && t("loaded", A);
      },
      { immediate: !0 }
    ), Nf(
      () => [
        l.value,
        s.annotationLayer,
        s.height,
        s.imageResourcesPath,
        s.page,
        s.rotation,
        s.scale,
        s.textLayer,
        s.width
      ],
      async ([A]) => {
        A && (o && (o.isAborted = !0, await o.promise), Sf(r.value), o = {
          isAborted: !1,
          promise: g()
        }, await o.promise, o = null);
      },
      { immediate: !0 }
    ), Jm(() => {
      Sf(r.value);
    }), e({
      doc: l,
      download: d,
      print: f
    }), (A, E) => (kl(), Fl("div", {
      id: A.id,
      ref_key: "root",
      ref: r,
      class: "vue-pdf-embed"
    }, [
      (kl(!0), Fl(eA, null, sA(i.value, (S, T) => (kl(), Fl("div", { key: S }, [
        Xg(A.$slots, "before-page", { page: S }),
        qm("div", {
          id: A.id && `${A.id}-${S}`,
          class: "vue-pdf-embed__page",
          style: iA({
            "--scale-factor": n.value[T],
            position: "relative"
          })
        }, [
          TS,
          A.textLayer ? (kl(), Fl("div", PS)) : Yg("", !0),
          A.annotationLayer ? (kl(), Fl("div", CS)) : Yg("", !0)
        ], 12, xS),
        Xg(A.$slots, "after-page", { page: S })
      ]))), 128))
    ], 8, SS));
  }
});
export {
  US as GlobalWorkerOptions,
  fx as default,
  fE as useVuePdfEmbed
};
